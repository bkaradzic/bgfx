// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: src/tint/utils/protos/ir/ir.proto
// Protobuf C++ Version: 6.32.0

#ifndef src_2ftint_2futils_2fprotos_2fir_2fir_2eproto_2epb_2eh
#define src_2ftint_2futils_2fprotos_2fir_2fir_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
}  // extern "C"
namespace tint {
namespace core {
namespace ir {
namespace binary {
namespace pb {
enum AccessControl : int;
extern const uint32_t AccessControl_internal_data_[];
enum AddressSpace : int;
extern const uint32_t AddressSpace_internal_data_[];
enum BinaryOp : int;
extern const uint32_t BinaryOp_internal_data_[];
enum BuiltinFn : int;
extern const uint32_t BuiltinFn_internal_data_[];
enum BuiltinValue : int;
extern const uint32_t BuiltinValue_internal_data_[];
enum InterpolationSampling : int;
extern const uint32_t InterpolationSampling_internal_data_[];
enum InterpolationType : int;
extern const uint32_t InterpolationType_internal_data_[];
enum PipelineStage : int;
extern const uint32_t PipelineStage_internal_data_[];
enum SamplerKind : int;
extern const uint32_t SamplerKind_internal_data_[];
enum TexelFormat : int;
extern const uint32_t TexelFormat_internal_data_[];
enum TextureDimension : int;
extern const uint32_t TextureDimension_internal_data_[];
enum TypeBasic : int;
extern const uint32_t TypeBasic_internal_data_[];
enum TypeBuiltinStruct : int;
extern const uint32_t TypeBuiltinStruct_internal_data_[];
enum UnaryOp : int;
extern const uint32_t UnaryOp_internal_data_[];
class AttributesFunctionParameter;
struct AttributesFunctionParameterDefaultTypeInternal;
extern AttributesFunctionParameterDefaultTypeInternal _AttributesFunctionParameter_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttributesFunctionParameter_class_data_;
class AttributesStructMember;
struct AttributesStructMemberDefaultTypeInternal;
extern AttributesStructMemberDefaultTypeInternal _AttributesStructMember_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AttributesStructMember_class_data_;
class BindingPoint;
struct BindingPointDefaultTypeInternal;
extern BindingPointDefaultTypeInternal _BindingPoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BindingPoint_class_data_;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Block_class_data_;
class BlockParameter;
struct BlockParameterDefaultTypeInternal;
extern BlockParameterDefaultTypeInternal _BlockParameter_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BlockParameter_class_data_;
class ConstantValue;
struct ConstantValueDefaultTypeInternal;
extern ConstantValueDefaultTypeInternal _ConstantValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConstantValue_class_data_;
class ConstantValueComposite;
struct ConstantValueCompositeDefaultTypeInternal;
extern ConstantValueCompositeDefaultTypeInternal _ConstantValueComposite_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConstantValueComposite_class_data_;
class ConstantValueScalar;
struct ConstantValueScalarDefaultTypeInternal;
extern ConstantValueScalarDefaultTypeInternal _ConstantValueScalar_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConstantValueScalar_class_data_;
class ConstantValueSplat;
struct ConstantValueSplatDefaultTypeInternal;
extern ConstantValueSplatDefaultTypeInternal _ConstantValueSplat_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConstantValueSplat_class_data_;
class Function;
struct FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Function_class_data_;
class FunctionParameter;
struct FunctionParameterDefaultTypeInternal;
extern FunctionParameterDefaultTypeInternal _FunctionParameter_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FunctionParameter_class_data_;
class Instruction;
struct InstructionDefaultTypeInternal;
extern InstructionDefaultTypeInternal _Instruction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Instruction_class_data_;
class InstructionAccess;
struct InstructionAccessDefaultTypeInternal;
extern InstructionAccessDefaultTypeInternal _InstructionAccess_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionAccess_class_data_;
class InstructionBinary;
struct InstructionBinaryDefaultTypeInternal;
extern InstructionBinaryDefaultTypeInternal _InstructionBinary_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionBinary_class_data_;
class InstructionBitcast;
struct InstructionBitcastDefaultTypeInternal;
extern InstructionBitcastDefaultTypeInternal _InstructionBitcast_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionBitcast_class_data_;
class InstructionBreakIf;
struct InstructionBreakIfDefaultTypeInternal;
extern InstructionBreakIfDefaultTypeInternal _InstructionBreakIf_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionBreakIf_class_data_;
class InstructionBuiltinCall;
struct InstructionBuiltinCallDefaultTypeInternal;
extern InstructionBuiltinCallDefaultTypeInternal _InstructionBuiltinCall_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionBuiltinCall_class_data_;
class InstructionConstruct;
struct InstructionConstructDefaultTypeInternal;
extern InstructionConstructDefaultTypeInternal _InstructionConstruct_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionConstruct_class_data_;
class InstructionContinue;
struct InstructionContinueDefaultTypeInternal;
extern InstructionContinueDefaultTypeInternal _InstructionContinue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionContinue_class_data_;
class InstructionConvert;
struct InstructionConvertDefaultTypeInternal;
extern InstructionConvertDefaultTypeInternal _InstructionConvert_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionConvert_class_data_;
class InstructionDiscard;
struct InstructionDiscardDefaultTypeInternal;
extern InstructionDiscardDefaultTypeInternal _InstructionDiscard_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionDiscard_class_data_;
class InstructionExitIf;
struct InstructionExitIfDefaultTypeInternal;
extern InstructionExitIfDefaultTypeInternal _InstructionExitIf_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionExitIf_class_data_;
class InstructionExitLoop;
struct InstructionExitLoopDefaultTypeInternal;
extern InstructionExitLoopDefaultTypeInternal _InstructionExitLoop_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionExitLoop_class_data_;
class InstructionExitSwitch;
struct InstructionExitSwitchDefaultTypeInternal;
extern InstructionExitSwitchDefaultTypeInternal _InstructionExitSwitch_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionExitSwitch_class_data_;
class InstructionIf;
struct InstructionIfDefaultTypeInternal;
extern InstructionIfDefaultTypeInternal _InstructionIf_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionIf_class_data_;
class InstructionLet;
struct InstructionLetDefaultTypeInternal;
extern InstructionLetDefaultTypeInternal _InstructionLet_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionLet_class_data_;
class InstructionLoad;
struct InstructionLoadDefaultTypeInternal;
extern InstructionLoadDefaultTypeInternal _InstructionLoad_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionLoad_class_data_;
class InstructionLoadVectorElement;
struct InstructionLoadVectorElementDefaultTypeInternal;
extern InstructionLoadVectorElementDefaultTypeInternal _InstructionLoadVectorElement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionLoadVectorElement_class_data_;
class InstructionLoop;
struct InstructionLoopDefaultTypeInternal;
extern InstructionLoopDefaultTypeInternal _InstructionLoop_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionLoop_class_data_;
class InstructionNextIteration;
struct InstructionNextIterationDefaultTypeInternal;
extern InstructionNextIterationDefaultTypeInternal _InstructionNextIteration_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionNextIteration_class_data_;
class InstructionResult;
struct InstructionResultDefaultTypeInternal;
extern InstructionResultDefaultTypeInternal _InstructionResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionResult_class_data_;
class InstructionReturn;
struct InstructionReturnDefaultTypeInternal;
extern InstructionReturnDefaultTypeInternal _InstructionReturn_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionReturn_class_data_;
class InstructionStore;
struct InstructionStoreDefaultTypeInternal;
extern InstructionStoreDefaultTypeInternal _InstructionStore_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionStore_class_data_;
class InstructionStoreVectorElement;
struct InstructionStoreVectorElementDefaultTypeInternal;
extern InstructionStoreVectorElementDefaultTypeInternal _InstructionStoreVectorElement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionStoreVectorElement_class_data_;
class InstructionSwitch;
struct InstructionSwitchDefaultTypeInternal;
extern InstructionSwitchDefaultTypeInternal _InstructionSwitch_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionSwitch_class_data_;
class InstructionSwizzle;
struct InstructionSwizzleDefaultTypeInternal;
extern InstructionSwizzleDefaultTypeInternal _InstructionSwizzle_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionSwizzle_class_data_;
class InstructionUnary;
struct InstructionUnaryDefaultTypeInternal;
extern InstructionUnaryDefaultTypeInternal _InstructionUnary_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionUnary_class_data_;
class InstructionUnreachable;
struct InstructionUnreachableDefaultTypeInternal;
extern InstructionUnreachableDefaultTypeInternal _InstructionUnreachable_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionUnreachable_class_data_;
class InstructionUserCall;
struct InstructionUserCallDefaultTypeInternal;
extern InstructionUserCallDefaultTypeInternal _InstructionUserCall_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionUserCall_class_data_;
class InstructionVar;
struct InstructionVarDefaultTypeInternal;
extern InstructionVarDefaultTypeInternal _InstructionVar_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InstructionVar_class_data_;
class Interpolation;
struct InterpolationDefaultTypeInternal;
extern InterpolationDefaultTypeInternal _Interpolation_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Interpolation_class_data_;
class Module;
struct ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Module_class_data_;
class SwitchCase;
struct SwitchCaseDefaultTypeInternal;
extern SwitchCaseDefaultTypeInternal _SwitchCase_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SwitchCase_class_data_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Type_class_data_;
class TypeArray;
struct TypeArrayDefaultTypeInternal;
extern TypeArrayDefaultTypeInternal _TypeArray_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeArray_class_data_;
class TypeAtomic;
struct TypeAtomicDefaultTypeInternal;
extern TypeAtomicDefaultTypeInternal _TypeAtomic_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeAtomic_class_data_;
class TypeBindingArray;
struct TypeBindingArrayDefaultTypeInternal;
extern TypeBindingArrayDefaultTypeInternal _TypeBindingArray_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeBindingArray_class_data_;
class TypeBuffer;
struct TypeBufferDefaultTypeInternal;
extern TypeBufferDefaultTypeInternal _TypeBuffer_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeBuffer_class_data_;
class TypeDepthMultisampledTexture;
struct TypeDepthMultisampledTextureDefaultTypeInternal;
extern TypeDepthMultisampledTextureDefaultTypeInternal _TypeDepthMultisampledTexture_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeDepthMultisampledTexture_class_data_;
class TypeDepthTexture;
struct TypeDepthTextureDefaultTypeInternal;
extern TypeDepthTextureDefaultTypeInternal _TypeDepthTexture_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeDepthTexture_class_data_;
class TypeExternalTexture;
struct TypeExternalTextureDefaultTypeInternal;
extern TypeExternalTextureDefaultTypeInternal _TypeExternalTexture_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeExternalTexture_class_data_;
class TypeInputAttachment;
struct TypeInputAttachmentDefaultTypeInternal;
extern TypeInputAttachmentDefaultTypeInternal _TypeInputAttachment_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeInputAttachment_class_data_;
class TypeMatrix;
struct TypeMatrixDefaultTypeInternal;
extern TypeMatrixDefaultTypeInternal _TypeMatrix_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeMatrix_class_data_;
class TypeMultisampledTexture;
struct TypeMultisampledTextureDefaultTypeInternal;
extern TypeMultisampledTextureDefaultTypeInternal _TypeMultisampledTexture_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeMultisampledTexture_class_data_;
class TypePointer;
struct TypePointerDefaultTypeInternal;
extern TypePointerDefaultTypeInternal _TypePointer_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypePointer_class_data_;
class TypeResourceBinding;
struct TypeResourceBindingDefaultTypeInternal;
extern TypeResourceBindingDefaultTypeInternal _TypeResourceBinding_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeResourceBinding_class_data_;
class TypeSampledTexture;
struct TypeSampledTextureDefaultTypeInternal;
extern TypeSampledTextureDefaultTypeInternal _TypeSampledTexture_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeSampledTexture_class_data_;
class TypeSampler;
struct TypeSamplerDefaultTypeInternal;
extern TypeSamplerDefaultTypeInternal _TypeSampler_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeSampler_class_data_;
class TypeStorageTexture;
struct TypeStorageTextureDefaultTypeInternal;
extern TypeStorageTextureDefaultTypeInternal _TypeStorageTexture_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeStorageTexture_class_data_;
class TypeStruct;
struct TypeStructDefaultTypeInternal;
extern TypeStructDefaultTypeInternal _TypeStruct_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeStruct_class_data_;
class TypeStructMember;
struct TypeStructMemberDefaultTypeInternal;
extern TypeStructMemberDefaultTypeInternal _TypeStructMember_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeStructMember_class_data_;
class TypeSubgroupMatrix;
struct TypeSubgroupMatrixDefaultTypeInternal;
extern TypeSubgroupMatrixDefaultTypeInternal _TypeSubgroupMatrix_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeSubgroupMatrix_class_data_;
class TypeTexelBuffer;
struct TypeTexelBufferDefaultTypeInternal;
extern TypeTexelBufferDefaultTypeInternal _TypeTexelBuffer_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeTexelBuffer_class_data_;
class TypeVector;
struct TypeVectorDefaultTypeInternal;
extern TypeVectorDefaultTypeInternal _TypeVector_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TypeVector_class_data_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Value_class_data_;
class WorkgroupSize;
struct WorkgroupSizeDefaultTypeInternal;
extern WorkgroupSizeDefaultTypeInternal _WorkgroupSize_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WorkgroupSize_class_data_;
}  // namespace pb
}  // namespace binary
}  // namespace ir
}  // namespace core
}  // namespace tint
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::AccessControl_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::AccessControl>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::AddressSpace_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::AddressSpace>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::BinaryOp_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::BinaryOp>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::BuiltinFn_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::BuiltinFn>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::BuiltinValue_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::BuiltinValue>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::InterpolationSampling_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::InterpolationSampling>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::InterpolationType_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::InterpolationType>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::PipelineStage_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::PipelineStage>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::SamplerKind_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::SamplerKind>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::TexelFormat_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::TexelFormat>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::TextureDimension_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::TextureDimension>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::TypeBasic_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::TypeBasic>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::TypeBuiltinStruct_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::TypeBuiltinStruct>;
template <>
internal::EnumTraitsT<::tint::core::ir::binary::pb::UnaryOp_internal_data_>
    internal::EnumTraitsImpl::value<::tint::core::ir::binary::pb::UnaryOp>;
}  // namespace protobuf
}  // namespace google

namespace tint {
namespace core {
namespace ir {
namespace binary {
namespace pb {
enum TypeBasic : int {
  void_ = 0,
  bool_ = 1,
  i32 = 2,
  u32 = 3,
  f32 = 4,
  f16 = 5,
  i8 = 6,
  u8 = 7,
  TypeBasic_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TypeBasic_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TypeBasic_internal_data_[];
inline constexpr TypeBasic TypeBasic_MIN =
    static_cast<TypeBasic>(0);
inline constexpr TypeBasic TypeBasic_MAX =
    static_cast<TypeBasic>(7);
inline bool TypeBasic_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int TypeBasic_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TypeBasic_descriptor();
template <typename T>
const ::std::string& TypeBasic_Name(T value) {
  static_assert(::std::is_same<T, TypeBasic>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TypeBasic_Name().");
  return TypeBasic_Name(static_cast<TypeBasic>(value));
}
template <>
inline const ::std::string& TypeBasic_Name(TypeBasic value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TypeBasic_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool TypeBasic_Parse(
    ::absl::string_view name, TypeBasic* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeBasic>(TypeBasic_descriptor(), name,
                                           value);
}
enum TypeBuiltinStruct : int {
  AtomicCompareExchangeResultI32 = 0,
  AtomicCompareExchangeResultU32 = 1,
  FrexpResultF16 = 2,
  FrexpResultF32 = 3,
  FrexpResultVec2F16 = 4,
  FrexpResultVec2F32 = 5,
  FrexpResultVec3F16 = 6,
  FrexpResultVec3F32 = 7,
  FrexpResultVec4F16 = 8,
  FrexpResultVec4F32 = 9,
  ModfResultF16 = 10,
  ModfResultF32 = 11,
  ModfResultVec2F16 = 12,
  ModfResultVec2F32 = 13,
  ModfResultVec3F16 = 14,
  ModfResultVec3F32 = 15,
  ModfResultVec4F16 = 16,
  ModfResultVec4F32 = 17,
  TypeBuiltinStruct_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TypeBuiltinStruct_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TypeBuiltinStruct_internal_data_[];
inline constexpr TypeBuiltinStruct TypeBuiltinStruct_MIN =
    static_cast<TypeBuiltinStruct>(0);
inline constexpr TypeBuiltinStruct TypeBuiltinStruct_MAX =
    static_cast<TypeBuiltinStruct>(17);
inline bool TypeBuiltinStruct_IsValid(int value) {
  return 0 <= value && value <= 17;
}
inline constexpr int TypeBuiltinStruct_ARRAYSIZE = 17 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TypeBuiltinStruct_descriptor();
template <typename T>
const ::std::string& TypeBuiltinStruct_Name(T value) {
  static_assert(::std::is_same<T, TypeBuiltinStruct>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TypeBuiltinStruct_Name().");
  return TypeBuiltinStruct_Name(static_cast<TypeBuiltinStruct>(value));
}
template <>
inline const ::std::string& TypeBuiltinStruct_Name(TypeBuiltinStruct value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TypeBuiltinStruct_descriptor, 0, 17>(
      static_cast<int>(value));
}
inline bool TypeBuiltinStruct_Parse(
    ::absl::string_view name, TypeBuiltinStruct* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeBuiltinStruct>(TypeBuiltinStruct_descriptor(), name,
                                           value);
}
enum PipelineStage : int {
  Compute = 0,
  Fragment = 1,
  Vertex = 2,
  PipelineStage_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  PipelineStage_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t PipelineStage_internal_data_[];
inline constexpr PipelineStage PipelineStage_MIN =
    static_cast<PipelineStage>(0);
inline constexpr PipelineStage PipelineStage_MAX =
    static_cast<PipelineStage>(2);
inline bool PipelineStage_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int PipelineStage_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PipelineStage_descriptor();
template <typename T>
const ::std::string& PipelineStage_Name(T value) {
  static_assert(::std::is_same<T, PipelineStage>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PipelineStage_Name().");
  return PipelineStage_Name(static_cast<PipelineStage>(value));
}
template <>
inline const ::std::string& PipelineStage_Name(PipelineStage value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PipelineStage_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool PipelineStage_Parse(
    ::absl::string_view name, PipelineStage* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<PipelineStage>(PipelineStage_descriptor(), name,
                                           value);
}
enum AddressSpace : int {
  function = 0,
  handle = 1,
  pixel_local = 2,
  private_ = 3,
  immediate = 4,
  storage = 5,
  uniform = 6,
  workgroup = 7,
  AddressSpace_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AddressSpace_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AddressSpace_internal_data_[];
inline constexpr AddressSpace AddressSpace_MIN =
    static_cast<AddressSpace>(0);
inline constexpr AddressSpace AddressSpace_MAX =
    static_cast<AddressSpace>(7);
inline bool AddressSpace_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int AddressSpace_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AddressSpace_descriptor();
template <typename T>
const ::std::string& AddressSpace_Name(T value) {
  static_assert(::std::is_same<T, AddressSpace>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AddressSpace_Name().");
  return AddressSpace_Name(static_cast<AddressSpace>(value));
}
template <>
inline const ::std::string& AddressSpace_Name(AddressSpace value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AddressSpace_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool AddressSpace_Parse(
    ::absl::string_view name, AddressSpace* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AddressSpace>(AddressSpace_descriptor(), name,
                                           value);
}
enum AccessControl : int {
  read = 0,
  write = 1,
  read_write = 2,
  AccessControl_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AccessControl_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AccessControl_internal_data_[];
inline constexpr AccessControl AccessControl_MIN =
    static_cast<AccessControl>(0);
inline constexpr AccessControl AccessControl_MAX =
    static_cast<AccessControl>(2);
inline bool AccessControl_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int AccessControl_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AccessControl_descriptor();
template <typename T>
const ::std::string& AccessControl_Name(T value) {
  static_assert(::std::is_same<T, AccessControl>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AccessControl_Name().");
  return AccessControl_Name(static_cast<AccessControl>(value));
}
template <>
inline const ::std::string& AccessControl_Name(AccessControl value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccessControl_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool AccessControl_Parse(
    ::absl::string_view name, AccessControl* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessControl>(AccessControl_descriptor(), name,
                                           value);
}
enum UnaryOp : int {
  complement = 0,
  negation = 1,
  address_of = 2,
  indirection = 3,
  not_ = 4,
  UnaryOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  UnaryOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t UnaryOp_internal_data_[];
inline constexpr UnaryOp UnaryOp_MIN =
    static_cast<UnaryOp>(0);
inline constexpr UnaryOp UnaryOp_MAX =
    static_cast<UnaryOp>(4);
inline bool UnaryOp_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int UnaryOp_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL UnaryOp_descriptor();
template <typename T>
const ::std::string& UnaryOp_Name(T value) {
  static_assert(::std::is_same<T, UnaryOp>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to UnaryOp_Name().");
  return UnaryOp_Name(static_cast<UnaryOp>(value));
}
template <>
inline const ::std::string& UnaryOp_Name(UnaryOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UnaryOp_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool UnaryOp_Parse(
    ::absl::string_view name, UnaryOp* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnaryOp>(UnaryOp_descriptor(), name,
                                           value);
}
enum BinaryOp : int {
  add_ = 0,
  subtract = 1,
  multiply = 2,
  divide = 3,
  modulo = 4,
  and_ = 5,
  or_ = 6,
  xor_ = 7,
  equal = 8,
  not_equal = 9,
  less_than = 10,
  greater_than = 11,
  less_than_equal = 12,
  greater_than_equal = 13,
  shift_left = 14,
  shift_right = 15,
  logical_and = 16,
  logical_or = 17,
  BinaryOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BinaryOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BinaryOp_internal_data_[];
inline constexpr BinaryOp BinaryOp_MIN =
    static_cast<BinaryOp>(0);
inline constexpr BinaryOp BinaryOp_MAX =
    static_cast<BinaryOp>(17);
inline bool BinaryOp_IsValid(int value) {
  return 0 <= value && value <= 17;
}
inline constexpr int BinaryOp_ARRAYSIZE = 17 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BinaryOp_descriptor();
template <typename T>
const ::std::string& BinaryOp_Name(T value) {
  static_assert(::std::is_same<T, BinaryOp>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BinaryOp_Name().");
  return BinaryOp_Name(static_cast<BinaryOp>(value));
}
template <>
inline const ::std::string& BinaryOp_Name(BinaryOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BinaryOp_descriptor, 0, 17>(
      static_cast<int>(value));
}
inline bool BinaryOp_Parse(
    ::absl::string_view name, BinaryOp* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryOp>(BinaryOp_descriptor(), name,
                                           value);
}
enum TextureDimension : int {
  _1d = 0,
  _2d = 1,
  _2d_array = 2,
  _3d = 3,
  cube = 4,
  cube_array = 5,
  TextureDimension_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TextureDimension_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TextureDimension_internal_data_[];
inline constexpr TextureDimension TextureDimension_MIN =
    static_cast<TextureDimension>(0);
inline constexpr TextureDimension TextureDimension_MAX =
    static_cast<TextureDimension>(5);
inline bool TextureDimension_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int TextureDimension_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TextureDimension_descriptor();
template <typename T>
const ::std::string& TextureDimension_Name(T value) {
  static_assert(::std::is_same<T, TextureDimension>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TextureDimension_Name().");
  return TextureDimension_Name(static_cast<TextureDimension>(value));
}
template <>
inline const ::std::string& TextureDimension_Name(TextureDimension value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TextureDimension_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool TextureDimension_Parse(
    ::absl::string_view name, TextureDimension* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextureDimension>(TextureDimension_descriptor(), name,
                                           value);
}
enum TexelFormat : int {
  bgra8_unorm = 0,
  r8_unorm = 1,
  r32_float = 2,
  r32_sint = 3,
  r32_uint = 4,
  rg32_float = 5,
  rg32_sint = 6,
  rg32_uint = 7,
  rgba16_float = 8,
  rgba16_sint = 9,
  rgba16_uint = 10,
  rgba32_float = 11,
  rgba32_sint = 12,
  rgba32_uint = 13,
  rgba8_sint = 14,
  rgba8_snorm = 15,
  rgba8_uint = 16,
  rgba8_unorm = 17,
  r8_snorm = 18,
  r8_uint = 19,
  r8_sint = 20,
  rg8_unorm = 21,
  rg8_snorm = 22,
  rg8_uint = 23,
  rg8_sint = 24,
  r16_uint = 25,
  r16_sint = 26,
  r16_float = 27,
  rg16_uint = 28,
  rg16_sint = 29,
  rg16_float = 30,
  rgb10a2_uint = 31,
  rgb10a2_unorm = 32,
  rg11b10_ufloat = 33,
  r16_unorm = 34,
  r16_snorm = 35,
  rg16_unorm = 36,
  rg16_snorm = 37,
  rgba16_unorm = 38,
  rgba16_snorm = 39,
  TexelFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  TexelFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t TexelFormat_internal_data_[];
inline constexpr TexelFormat TexelFormat_MIN =
    static_cast<TexelFormat>(0);
inline constexpr TexelFormat TexelFormat_MAX =
    static_cast<TexelFormat>(39);
inline bool TexelFormat_IsValid(int value) {
  return 0 <= value && value <= 39;
}
inline constexpr int TexelFormat_ARRAYSIZE = 39 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL TexelFormat_descriptor();
template <typename T>
const ::std::string& TexelFormat_Name(T value) {
  static_assert(::std::is_same<T, TexelFormat>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to TexelFormat_Name().");
  return TexelFormat_Name(static_cast<TexelFormat>(value));
}
template <>
inline const ::std::string& TexelFormat_Name(TexelFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TexelFormat_descriptor, 0, 39>(
      static_cast<int>(value));
}
inline bool TexelFormat_Parse(
    ::absl::string_view name, TexelFormat* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<TexelFormat>(TexelFormat_descriptor(), name,
                                           value);
}
enum SamplerKind : int {
  sampler = 0,
  comparison = 1,
  SamplerKind_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  SamplerKind_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t SamplerKind_internal_data_[];
inline constexpr SamplerKind SamplerKind_MIN =
    static_cast<SamplerKind>(0);
inline constexpr SamplerKind SamplerKind_MAX =
    static_cast<SamplerKind>(1);
inline bool SamplerKind_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int SamplerKind_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL SamplerKind_descriptor();
template <typename T>
const ::std::string& SamplerKind_Name(T value) {
  static_assert(::std::is_same<T, SamplerKind>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to SamplerKind_Name().");
  return SamplerKind_Name(static_cast<SamplerKind>(value));
}
template <>
inline const ::std::string& SamplerKind_Name(SamplerKind value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SamplerKind_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool SamplerKind_Parse(
    ::absl::string_view name, SamplerKind* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<SamplerKind>(SamplerKind_descriptor(), name,
                                           value);
}
enum InterpolationType : int {
  flat = 0,
  linear = 1,
  perspective = 2,
  InterpolationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  InterpolationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t InterpolationType_internal_data_[];
inline constexpr InterpolationType InterpolationType_MIN =
    static_cast<InterpolationType>(0);
inline constexpr InterpolationType InterpolationType_MAX =
    static_cast<InterpolationType>(2);
inline bool InterpolationType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int InterpolationType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL InterpolationType_descriptor();
template <typename T>
const ::std::string& InterpolationType_Name(T value) {
  static_assert(::std::is_same<T, InterpolationType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InterpolationType_Name().");
  return InterpolationType_Name(static_cast<InterpolationType>(value));
}
template <>
inline const ::std::string& InterpolationType_Name(InterpolationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InterpolationType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool InterpolationType_Parse(
    ::absl::string_view name, InterpolationType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterpolationType>(InterpolationType_descriptor(), name,
                                           value);
}
enum InterpolationSampling : int {
  center = 0,
  centroid = 1,
  sample = 2,
  first = 3,
  either = 4,
  InterpolationSampling_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  InterpolationSampling_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t InterpolationSampling_internal_data_[];
inline constexpr InterpolationSampling InterpolationSampling_MIN =
    static_cast<InterpolationSampling>(0);
inline constexpr InterpolationSampling InterpolationSampling_MAX =
    static_cast<InterpolationSampling>(4);
inline bool InterpolationSampling_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int InterpolationSampling_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL InterpolationSampling_descriptor();
template <typename T>
const ::std::string& InterpolationSampling_Name(T value) {
  static_assert(::std::is_same<T, InterpolationSampling>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to InterpolationSampling_Name().");
  return InterpolationSampling_Name(static_cast<InterpolationSampling>(value));
}
template <>
inline const ::std::string& InterpolationSampling_Name(InterpolationSampling value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InterpolationSampling_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool InterpolationSampling_Parse(
    ::absl::string_view name, InterpolationSampling* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<InterpolationSampling>(InterpolationSampling_descriptor(), name,
                                           value);
}
enum BuiltinValue : int {
  point_size = 0,
  frag_depth = 1,
  front_facing = 2,
  global_invocation_id = 3,
  instance_index = 4,
  local_invocation_id = 5,
  local_invocation_index = 6,
  num_workgroups = 7,
  position = 8,
  sample_index = 9,
  sample_mask = 10,
  subgroup_invocation_id = 11,
  subgroup_size = 12,
  vertex_index = 13,
  workgroup_id = 14,
  clip_distances = 15,
  cull_distance = 16,
  subgroup_id = 17,
  primitive_index = 18,
  barycentric_coord = 19,
  num_subgroups = 20,
  BuiltinValue_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BuiltinValue_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BuiltinValue_internal_data_[];
inline constexpr BuiltinValue BuiltinValue_MIN =
    static_cast<BuiltinValue>(0);
inline constexpr BuiltinValue BuiltinValue_MAX =
    static_cast<BuiltinValue>(20);
inline bool BuiltinValue_IsValid(int value) {
  return 0 <= value && value <= 20;
}
inline constexpr int BuiltinValue_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BuiltinValue_descriptor();
template <typename T>
const ::std::string& BuiltinValue_Name(T value) {
  static_assert(::std::is_same<T, BuiltinValue>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BuiltinValue_Name().");
  return BuiltinValue_Name(static_cast<BuiltinValue>(value));
}
template <>
inline const ::std::string& BuiltinValue_Name(BuiltinValue value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BuiltinValue_descriptor, 0, 20>(
      static_cast<int>(value));
}
inline bool BuiltinValue_Parse(
    ::absl::string_view name, BuiltinValue* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuiltinValue>(BuiltinValue_descriptor(), name,
                                           value);
}
enum BuiltinFn : int {
  abs = 0,
  acos = 1,
  acosh = 2,
  all = 3,
  any = 4,
  array_length = 5,
  asin = 6,
  asinh = 7,
  atan = 8,
  atan2 = 9,
  atanh = 10,
  ceil = 11,
  clamp = 12,
  cos = 13,
  cosh = 14,
  count_leading_zeros = 15,
  count_one_bits = 16,
  count_trailing_zeros = 17,
  cross = 18,
  degrees = 19,
  determinant = 20,
  distance = 21,
  dot = 22,
  dot4i8_packed = 23,
  dot4u8_packed = 24,
  dpdx = 25,
  dpdx_coarse = 26,
  dpdx_fine = 27,
  dpdy = 28,
  dpdy_coarse = 29,
  dpdy_fine = 30,
  exp = 31,
  exp2 = 32,
  extract_bits = 33,
  face_forward = 34,
  first_leading_bit = 35,
  first_trailing_bit = 36,
  floor = 37,
  fma = 38,
  fract = 39,
  frexp = 40,
  fwidth = 41,
  fwidth_coarse = 42,
  fwidth_fine = 43,
  insert_bits = 44,
  inverse_sqrt = 45,
  ldexp = 46,
  length = 47,
  log = 48,
  log2 = 49,
  max = 50,
  min = 51,
  mix = 52,
  modf = 53,
  normalize = 54,
  pack2x16_float = 55,
  pack2x16_snorm = 56,
  pack2x16_unorm = 57,
  pack4x8_snorm = 58,
  pack4x8_unorm = 59,
  pack4xi8 = 60,
  pack4xu8 = 61,
  pack4xi8_clamp = 62,
  pack4xu8_clamp = 63,
  pow = 64,
  quantize_to_f16 = 65,
  radians = 66,
  reflect = 67,
  refract = 68,
  reverse_bits = 69,
  round = 70,
  saturate = 71,
  select = 72,
  sign = 73,
  sin = 74,
  sinh = 75,
  smoothstep = 76,
  sqrt = 77,
  step = 78,
  storage_barrier = 79,
  tan = 80,
  tanh = 81,
  transpose = 82,
  trunc = 83,
  unpack2x16_float = 84,
  unpack2x16_snorm = 85,
  unpack2x16_unorm = 86,
  unpack4x8_snorm = 87,
  unpack4x8_unorm = 88,
  unpack4xi8 = 89,
  unpack4xu8 = 90,
  workgroup_barrier = 91,
  texture_barrier = 92,
  texture_dimensions = 93,
  texture_gather = 94,
  texture_gather_compare = 95,
  texture_num_layers = 96,
  texture_num_levels = 97,
  texture_num_samples = 98,
  texture_sample = 99,
  texture_sample_bias = 100,
  texture_sample_compare = 101,
  texture_sample_compare_level = 102,
  texture_sample_grad = 103,
  texture_sample_level = 104,
  texture_sample_base_clamp_to_edge = 105,
  texture_store = 106,
  texture_load = 107,
  atomic_load = 108,
  atomic_store = 109,
  atomic_add = 110,
  atomic_sub = 111,
  atomic_max = 112,
  atomic_min = 113,
  atomic_and = 114,
  atomic_or = 115,
  atomic_xor = 116,
  atomic_exchange = 117,
  atomic_compare_exchange_weak = 118,
  subgroup_ballot = 119,
  subgroup_broadcast = 120,
  input_attachment_load = 121,
  subgroup_add = 122,
  subgroup_exclusive_add = 123,
  subgroup_mul = 124,
  subgroup_exclusive_mul = 125,
  subgroup_and = 126,
  subgroup_or = 127,
  subgroup_xor = 128,
  subgroup_min = 129,
  subgroup_max = 130,
  subgroup_any = 131,
  subgroup_all = 132,
  subgroup_elect = 133,
  subgroup_broadcast_first = 134,
  subgroup_shuffle = 135,
  subgroup_shuffle_xor = 136,
  subgroup_shuffle_up = 137,
  subgroup_shuffle_down = 138,
  quad_broadcast = 139,
  quad_swap_x = 140,
  quad_swap_y = 141,
  quad_swap_diagonal = 142,
  subgroup_inclusive_add = 143,
  subgroup_inclusive_mul = 144,
  subgroup_matrix_load = 145,
  subgroup_matrix_store = 146,
  subgroup_matrix_multiply = 147,
  subgroup_matrix_multiply_accumulate = 148,
  print = 149,
  subgroup_matrix_scalar_add = 152,
  subgroup_matrix_scalar_multiply = 153,
  subgroup_matrix_scalar_subtract = 154,
  has_resource = 155,
  get_resource = 156,
  buffer_view = 157,
  buffer_length = 158,
  BuiltinFn_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  BuiltinFn_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t BuiltinFn_internal_data_[];
inline constexpr BuiltinFn BuiltinFn_MIN =
    static_cast<BuiltinFn>(0);
inline constexpr BuiltinFn BuiltinFn_MAX =
    static_cast<BuiltinFn>(158);
inline bool BuiltinFn_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, BuiltinFn_internal_data_);
}
inline constexpr int BuiltinFn_ARRAYSIZE = 158 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BuiltinFn_descriptor();
template <typename T>
const ::std::string& BuiltinFn_Name(T value) {
  static_assert(::std::is_same<T, BuiltinFn>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BuiltinFn_Name().");
  return BuiltinFn_Name(static_cast<BuiltinFn>(value));
}
template <>
inline const ::std::string& BuiltinFn_Name(BuiltinFn value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BuiltinFn_descriptor, 0, 158>(
      static_cast<int>(value));
}
inline bool BuiltinFn_Parse(
    ::absl::string_view name, BuiltinFn* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuiltinFn>(BuiltinFn_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorkgroupSize final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.WorkgroupSize) */ {
 public:
  inline WorkgroupSize() : WorkgroupSize(nullptr) {}
  ~WorkgroupSize() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorkgroupSize* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorkgroupSize));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkgroupSize(::google::protobuf::internal::ConstantInitialized);

  inline WorkgroupSize(const WorkgroupSize& from) : WorkgroupSize(nullptr, from) {}
  inline WorkgroupSize(WorkgroupSize&& from) noexcept
      : WorkgroupSize(nullptr, ::std::move(from)) {}
  inline WorkgroupSize& operator=(const WorkgroupSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkgroupSize& operator=(WorkgroupSize&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkgroupSize& default_instance() {
    return *reinterpret_cast<const WorkgroupSize*>(
        &_WorkgroupSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(WorkgroupSize& a, WorkgroupSize& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(WorkgroupSize* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkgroupSize* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkgroupSize* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorkgroupSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkgroupSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkgroupSize& from) { WorkgroupSize::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorkgroupSize* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.WorkgroupSize"; }

 protected:
  explicit WorkgroupSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  WorkgroupSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const WorkgroupSize& from);
  WorkgroupSize(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, WorkgroupSize&& from) noexcept
      : WorkgroupSize(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // uint32 x = 1;
  void clear_x() ;
  ::uint32_t x() const;
  void set_x(::uint32_t value);

  private:
  ::uint32_t _internal_x() const;
  void _internal_set_x(::uint32_t value);

  public:
  // uint32 y = 2;
  void clear_y() ;
  ::uint32_t y() const;
  void set_y(::uint32_t value);

  private:
  ::uint32_t _internal_y() const;
  void _internal_set_y(::uint32_t value);

  public:
  // uint32 z = 3;
  void clear_z() ;
  ::uint32_t z() const;
  void set_z(::uint32_t value);

  private:
  ::uint32_t _internal_z() const;
  void _internal_set_z(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.WorkgroupSize)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const WorkgroupSize& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t x_;
    ::uint32_t y_;
    ::uint32_t z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WorkgroupSize_class_data_;
// -------------------------------------------------------------------

class TypeVector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeVector) */ {
 public:
  inline TypeVector() : TypeVector(nullptr) {}
  ~TypeVector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeVector* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeVector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeVector(::google::protobuf::internal::ConstantInitialized);

  inline TypeVector(const TypeVector& from) : TypeVector(nullptr, from) {}
  inline TypeVector(TypeVector&& from) noexcept
      : TypeVector(nullptr, ::std::move(from)) {}
  inline TypeVector& operator=(const TypeVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeVector& operator=(TypeVector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeVector& default_instance() {
    return *reinterpret_cast<const TypeVector*>(
        &_TypeVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TypeVector& a, TypeVector& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeVector* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeVector* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeVector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeVector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeVector& from) { TypeVector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeVector* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeVector"; }

 protected:
  explicit TypeVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeVector(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeVector& from);
  TypeVector(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeVector&& from) noexcept
      : TypeVector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWidthFieldNumber = 1,
    kElementTypeFieldNumber = 2,
  };
  // uint32 width = 1;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 element_type = 2;
  void clear_element_type() ;
  ::uint32_t element_type() const;
  void set_element_type(::uint32_t value);

  private:
  ::uint32_t _internal_element_type() const;
  void _internal_set_element_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeVector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeVector& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t width_;
    ::uint32_t element_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeVector_class_data_;
// -------------------------------------------------------------------

class TypeTexelBuffer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeTexelBuffer) */ {
 public:
  inline TypeTexelBuffer() : TypeTexelBuffer(nullptr) {}
  ~TypeTexelBuffer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeTexelBuffer* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeTexelBuffer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeTexelBuffer(::google::protobuf::internal::ConstantInitialized);

  inline TypeTexelBuffer(const TypeTexelBuffer& from) : TypeTexelBuffer(nullptr, from) {}
  inline TypeTexelBuffer(TypeTexelBuffer&& from) noexcept
      : TypeTexelBuffer(nullptr, ::std::move(from)) {}
  inline TypeTexelBuffer& operator=(const TypeTexelBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeTexelBuffer& operator=(TypeTexelBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeTexelBuffer& default_instance() {
    return *reinterpret_cast<const TypeTexelBuffer*>(
        &_TypeTexelBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(TypeTexelBuffer& a, TypeTexelBuffer& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeTexelBuffer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeTexelBuffer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeTexelBuffer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeTexelBuffer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeTexelBuffer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeTexelBuffer& from) { TypeTexelBuffer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeTexelBuffer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeTexelBuffer"; }

 protected:
  explicit TypeTexelBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeTexelBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeTexelBuffer& from);
  TypeTexelBuffer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeTexelBuffer&& from) noexcept
      : TypeTexelBuffer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTexelFormatFieldNumber = 1,
    kAccessFieldNumber = 2,
  };
  // .tint.core.ir.binary.pb.TexelFormat texel_format = 1;
  void clear_texel_format() ;
  ::tint::core::ir::binary::pb::TexelFormat texel_format() const;
  void set_texel_format(::tint::core::ir::binary::pb::TexelFormat value);

  private:
  ::tint::core::ir::binary::pb::TexelFormat _internal_texel_format() const;
  void _internal_set_texel_format(::tint::core::ir::binary::pb::TexelFormat value);

  public:
  // .tint.core.ir.binary.pb.AccessControl access = 2;
  void clear_access() ;
  ::tint::core::ir::binary::pb::AccessControl access() const;
  void set_access(::tint::core::ir::binary::pb::AccessControl value);

  private:
  ::tint::core::ir::binary::pb::AccessControl _internal_access() const;
  void _internal_set_access(::tint::core::ir::binary::pb::AccessControl value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeTexelBuffer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeTexelBuffer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int texel_format_;
    int access_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeTexelBuffer_class_data_;
// -------------------------------------------------------------------

class TypeSubgroupMatrix final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeSubgroupMatrix) */ {
 public:
  inline TypeSubgroupMatrix() : TypeSubgroupMatrix(nullptr) {}
  ~TypeSubgroupMatrix() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeSubgroupMatrix* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeSubgroupMatrix));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeSubgroupMatrix(::google::protobuf::internal::ConstantInitialized);

  inline TypeSubgroupMatrix(const TypeSubgroupMatrix& from) : TypeSubgroupMatrix(nullptr, from) {}
  inline TypeSubgroupMatrix(TypeSubgroupMatrix&& from) noexcept
      : TypeSubgroupMatrix(nullptr, ::std::move(from)) {}
  inline TypeSubgroupMatrix& operator=(const TypeSubgroupMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeSubgroupMatrix& operator=(TypeSubgroupMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeSubgroupMatrix& default_instance() {
    return *reinterpret_cast<const TypeSubgroupMatrix*>(
        &_TypeSubgroupMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(TypeSubgroupMatrix& a, TypeSubgroupMatrix& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeSubgroupMatrix* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeSubgroupMatrix* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeSubgroupMatrix* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeSubgroupMatrix>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeSubgroupMatrix& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeSubgroupMatrix& from) { TypeSubgroupMatrix::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeSubgroupMatrix* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeSubgroupMatrix"; }

 protected:
  explicit TypeSubgroupMatrix(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeSubgroupMatrix(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeSubgroupMatrix& from);
  TypeSubgroupMatrix(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeSubgroupMatrix&& from) noexcept
      : TypeSubgroupMatrix(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubTypeFieldNumber = 1,
    kRowsFieldNumber = 2,
    kColumnsFieldNumber = 3,
  };
  // uint32 sub_type = 1;
  void clear_sub_type() ;
  ::uint32_t sub_type() const;
  void set_sub_type(::uint32_t value);

  private:
  ::uint32_t _internal_sub_type() const;
  void _internal_set_sub_type(::uint32_t value);

  public:
  // uint32 rows = 2;
  void clear_rows() ;
  ::uint32_t rows() const;
  void set_rows(::uint32_t value);

  private:
  ::uint32_t _internal_rows() const;
  void _internal_set_rows(::uint32_t value);

  public:
  // uint32 columns = 3;
  void clear_columns() ;
  ::uint32_t columns() const;
  void set_columns(::uint32_t value);

  private:
  ::uint32_t _internal_columns() const;
  void _internal_set_columns(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeSubgroupMatrix)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeSubgroupMatrix& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t sub_type_;
    ::uint32_t rows_;
    ::uint32_t columns_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeSubgroupMatrix_class_data_;
// -------------------------------------------------------------------

class TypeStorageTexture final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeStorageTexture) */ {
 public:
  inline TypeStorageTexture() : TypeStorageTexture(nullptr) {}
  ~TypeStorageTexture() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeStorageTexture* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeStorageTexture));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeStorageTexture(::google::protobuf::internal::ConstantInitialized);

  inline TypeStorageTexture(const TypeStorageTexture& from) : TypeStorageTexture(nullptr, from) {}
  inline TypeStorageTexture(TypeStorageTexture&& from) noexcept
      : TypeStorageTexture(nullptr, ::std::move(from)) {}
  inline TypeStorageTexture& operator=(const TypeStorageTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeStorageTexture& operator=(TypeStorageTexture&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeStorageTexture& default_instance() {
    return *reinterpret_cast<const TypeStorageTexture*>(
        &_TypeStorageTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TypeStorageTexture& a, TypeStorageTexture& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeStorageTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeStorageTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeStorageTexture* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeStorageTexture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeStorageTexture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeStorageTexture& from) { TypeStorageTexture::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeStorageTexture* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeStorageTexture"; }

 protected:
  explicit TypeStorageTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeStorageTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeStorageTexture& from);
  TypeStorageTexture(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeStorageTexture&& from) noexcept
      : TypeStorageTexture(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionFieldNumber = 1,
    kTexelFormatFieldNumber = 2,
    kAccessFieldNumber = 3,
  };
  // .tint.core.ir.binary.pb.TextureDimension dimension = 1;
  void clear_dimension() ;
  ::tint::core::ir::binary::pb::TextureDimension dimension() const;
  void set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  private:
  ::tint::core::ir::binary::pb::TextureDimension _internal_dimension() const;
  void _internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  public:
  // .tint.core.ir.binary.pb.TexelFormat texel_format = 2;
  void clear_texel_format() ;
  ::tint::core::ir::binary::pb::TexelFormat texel_format() const;
  void set_texel_format(::tint::core::ir::binary::pb::TexelFormat value);

  private:
  ::tint::core::ir::binary::pb::TexelFormat _internal_texel_format() const;
  void _internal_set_texel_format(::tint::core::ir::binary::pb::TexelFormat value);

  public:
  // .tint.core.ir.binary.pb.AccessControl access = 3;
  void clear_access() ;
  ::tint::core::ir::binary::pb::AccessControl access() const;
  void set_access(::tint::core::ir::binary::pb::AccessControl value);

  private:
  ::tint::core::ir::binary::pb::AccessControl _internal_access() const;
  void _internal_set_access(::tint::core::ir::binary::pb::AccessControl value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeStorageTexture)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeStorageTexture& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int dimension_;
    int texel_format_;
    int access_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeStorageTexture_class_data_;
// -------------------------------------------------------------------

class TypeSampler final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeSampler) */ {
 public:
  inline TypeSampler() : TypeSampler(nullptr) {}
  ~TypeSampler() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeSampler* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeSampler));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeSampler(::google::protobuf::internal::ConstantInitialized);

  inline TypeSampler(const TypeSampler& from) : TypeSampler(nullptr, from) {}
  inline TypeSampler(TypeSampler&& from) noexcept
      : TypeSampler(nullptr, ::std::move(from)) {}
  inline TypeSampler& operator=(const TypeSampler& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeSampler& operator=(TypeSampler&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeSampler& default_instance() {
    return *reinterpret_cast<const TypeSampler*>(
        &_TypeSampler_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(TypeSampler& a, TypeSampler& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeSampler* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeSampler* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeSampler* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeSampler>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeSampler& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeSampler& from) { TypeSampler::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeSampler* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeSampler"; }

 protected:
  explicit TypeSampler(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeSampler(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeSampler& from);
  TypeSampler(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeSampler&& from) noexcept
      : TypeSampler(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKindFieldNumber = 1,
  };
  // .tint.core.ir.binary.pb.SamplerKind kind = 1;
  void clear_kind() ;
  ::tint::core::ir::binary::pb::SamplerKind kind() const;
  void set_kind(::tint::core::ir::binary::pb::SamplerKind value);

  private:
  ::tint::core::ir::binary::pb::SamplerKind _internal_kind() const;
  void _internal_set_kind(::tint::core::ir::binary::pb::SamplerKind value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeSampler)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeSampler& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int kind_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeSampler_class_data_;
// -------------------------------------------------------------------

class TypeSampledTexture final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeSampledTexture) */ {
 public:
  inline TypeSampledTexture() : TypeSampledTexture(nullptr) {}
  ~TypeSampledTexture() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeSampledTexture* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeSampledTexture));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeSampledTexture(::google::protobuf::internal::ConstantInitialized);

  inline TypeSampledTexture(const TypeSampledTexture& from) : TypeSampledTexture(nullptr, from) {}
  inline TypeSampledTexture(TypeSampledTexture&& from) noexcept
      : TypeSampledTexture(nullptr, ::std::move(from)) {}
  inline TypeSampledTexture& operator=(const TypeSampledTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeSampledTexture& operator=(TypeSampledTexture&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeSampledTexture& default_instance() {
    return *reinterpret_cast<const TypeSampledTexture*>(
        &_TypeSampledTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TypeSampledTexture& a, TypeSampledTexture& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeSampledTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeSampledTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeSampledTexture* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeSampledTexture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeSampledTexture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeSampledTexture& from) { TypeSampledTexture::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeSampledTexture* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeSampledTexture"; }

 protected:
  explicit TypeSampledTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeSampledTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeSampledTexture& from);
  TypeSampledTexture(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeSampledTexture&& from) noexcept
      : TypeSampledTexture(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionFieldNumber = 1,
    kSubTypeFieldNumber = 2,
  };
  // .tint.core.ir.binary.pb.TextureDimension dimension = 1;
  void clear_dimension() ;
  ::tint::core::ir::binary::pb::TextureDimension dimension() const;
  void set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  private:
  ::tint::core::ir::binary::pb::TextureDimension _internal_dimension() const;
  void _internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  public:
  // uint32 sub_type = 2;
  void clear_sub_type() ;
  ::uint32_t sub_type() const;
  void set_sub_type(::uint32_t value);

  private:
  ::uint32_t _internal_sub_type() const;
  void _internal_set_sub_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeSampledTexture)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeSampledTexture& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int dimension_;
    ::uint32_t sub_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeSampledTexture_class_data_;
// -------------------------------------------------------------------

class TypeResourceBinding final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeResourceBinding) */ {
 public:
  inline TypeResourceBinding() : TypeResourceBinding(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeResourceBinding* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeResourceBinding));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeResourceBinding(::google::protobuf::internal::ConstantInitialized);

  inline TypeResourceBinding(const TypeResourceBinding& from) : TypeResourceBinding(nullptr, from) {}
  inline TypeResourceBinding(TypeResourceBinding&& from) noexcept
      : TypeResourceBinding(nullptr, ::std::move(from)) {}
  inline TypeResourceBinding& operator=(const TypeResourceBinding& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeResourceBinding& operator=(TypeResourceBinding&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeResourceBinding& default_instance() {
    return *reinterpret_cast<const TypeResourceBinding*>(
        &_TypeResourceBinding_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(TypeResourceBinding& a, TypeResourceBinding& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeResourceBinding* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeResourceBinding* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeResourceBinding* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<TypeResourceBinding>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TypeResourceBinding& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TypeResourceBinding& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeResourceBinding"; }

 protected:
  explicit TypeResourceBinding(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeResourceBinding(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeResourceBinding& from);
  TypeResourceBinding(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeResourceBinding&& from) noexcept
      : TypeResourceBinding(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeResourceBinding)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeResourceBinding_class_data_;
// -------------------------------------------------------------------

class TypePointer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypePointer) */ {
 public:
  inline TypePointer() : TypePointer(nullptr) {}
  ~TypePointer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypePointer* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypePointer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypePointer(::google::protobuf::internal::ConstantInitialized);

  inline TypePointer(const TypePointer& from) : TypePointer(nullptr, from) {}
  inline TypePointer(TypePointer&& from) noexcept
      : TypePointer(nullptr, ::std::move(from)) {}
  inline TypePointer& operator=(const TypePointer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypePointer& operator=(TypePointer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypePointer& default_instance() {
    return *reinterpret_cast<const TypePointer*>(
        &_TypePointer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(TypePointer& a, TypePointer& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypePointer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypePointer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypePointer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypePointer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypePointer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypePointer& from) { TypePointer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypePointer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypePointer"; }

 protected:
  explicit TypePointer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypePointer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypePointer& from);
  TypePointer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypePointer&& from) noexcept
      : TypePointer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressSpaceFieldNumber = 1,
    kStoreTypeFieldNumber = 2,
    kAccessFieldNumber = 3,
  };
  // .tint.core.ir.binary.pb.AddressSpace address_space = 1;
  void clear_address_space() ;
  ::tint::core::ir::binary::pb::AddressSpace address_space() const;
  void set_address_space(::tint::core::ir::binary::pb::AddressSpace value);

  private:
  ::tint::core::ir::binary::pb::AddressSpace _internal_address_space() const;
  void _internal_set_address_space(::tint::core::ir::binary::pb::AddressSpace value);

  public:
  // uint32 store_type = 2;
  void clear_store_type() ;
  ::uint32_t store_type() const;
  void set_store_type(::uint32_t value);

  private:
  ::uint32_t _internal_store_type() const;
  void _internal_set_store_type(::uint32_t value);

  public:
  // .tint.core.ir.binary.pb.AccessControl access = 3;
  void clear_access() ;
  ::tint::core::ir::binary::pb::AccessControl access() const;
  void set_access(::tint::core::ir::binary::pb::AccessControl value);

  private:
  ::tint::core::ir::binary::pb::AccessControl _internal_access() const;
  void _internal_set_access(::tint::core::ir::binary::pb::AccessControl value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypePointer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypePointer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int address_space_;
    ::uint32_t store_type_;
    int access_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypePointer_class_data_;
// -------------------------------------------------------------------

class TypeMultisampledTexture final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeMultisampledTexture) */ {
 public:
  inline TypeMultisampledTexture() : TypeMultisampledTexture(nullptr) {}
  ~TypeMultisampledTexture() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeMultisampledTexture* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeMultisampledTexture));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeMultisampledTexture(::google::protobuf::internal::ConstantInitialized);

  inline TypeMultisampledTexture(const TypeMultisampledTexture& from) : TypeMultisampledTexture(nullptr, from) {}
  inline TypeMultisampledTexture(TypeMultisampledTexture&& from) noexcept
      : TypeMultisampledTexture(nullptr, ::std::move(from)) {}
  inline TypeMultisampledTexture& operator=(const TypeMultisampledTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeMultisampledTexture& operator=(TypeMultisampledTexture&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeMultisampledTexture& default_instance() {
    return *reinterpret_cast<const TypeMultisampledTexture*>(
        &_TypeMultisampledTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(TypeMultisampledTexture& a, TypeMultisampledTexture& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeMultisampledTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeMultisampledTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeMultisampledTexture* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeMultisampledTexture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeMultisampledTexture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeMultisampledTexture& from) { TypeMultisampledTexture::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeMultisampledTexture* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeMultisampledTexture"; }

 protected:
  explicit TypeMultisampledTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeMultisampledTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeMultisampledTexture& from);
  TypeMultisampledTexture(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeMultisampledTexture&& from) noexcept
      : TypeMultisampledTexture(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionFieldNumber = 1,
    kSubTypeFieldNumber = 2,
  };
  // .tint.core.ir.binary.pb.TextureDimension dimension = 1;
  void clear_dimension() ;
  ::tint::core::ir::binary::pb::TextureDimension dimension() const;
  void set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  private:
  ::tint::core::ir::binary::pb::TextureDimension _internal_dimension() const;
  void _internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  public:
  // uint32 sub_type = 2;
  void clear_sub_type() ;
  ::uint32_t sub_type() const;
  void set_sub_type(::uint32_t value);

  private:
  ::uint32_t _internal_sub_type() const;
  void _internal_set_sub_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeMultisampledTexture)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeMultisampledTexture& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int dimension_;
    ::uint32_t sub_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeMultisampledTexture_class_data_;
// -------------------------------------------------------------------

class TypeMatrix final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeMatrix) */ {
 public:
  inline TypeMatrix() : TypeMatrix(nullptr) {}
  ~TypeMatrix() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeMatrix* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeMatrix));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeMatrix(::google::protobuf::internal::ConstantInitialized);

  inline TypeMatrix(const TypeMatrix& from) : TypeMatrix(nullptr, from) {}
  inline TypeMatrix(TypeMatrix&& from) noexcept
      : TypeMatrix(nullptr, ::std::move(from)) {}
  inline TypeMatrix& operator=(const TypeMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeMatrix& operator=(TypeMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeMatrix& default_instance() {
    return *reinterpret_cast<const TypeMatrix*>(
        &_TypeMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TypeMatrix& a, TypeMatrix& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeMatrix* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeMatrix* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeMatrix* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeMatrix>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeMatrix& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeMatrix& from) { TypeMatrix::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeMatrix* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeMatrix"; }

 protected:
  explicit TypeMatrix(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeMatrix(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeMatrix& from);
  TypeMatrix(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeMatrix&& from) noexcept
      : TypeMatrix(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumColumnsFieldNumber = 1,
    kNumRowsFieldNumber = 2,
    kElementTypeFieldNumber = 3,
  };
  // uint32 num_columns = 1;
  void clear_num_columns() ;
  ::uint32_t num_columns() const;
  void set_num_columns(::uint32_t value);

  private:
  ::uint32_t _internal_num_columns() const;
  void _internal_set_num_columns(::uint32_t value);

  public:
  // uint32 num_rows = 2;
  void clear_num_rows() ;
  ::uint32_t num_rows() const;
  void set_num_rows(::uint32_t value);

  private:
  ::uint32_t _internal_num_rows() const;
  void _internal_set_num_rows(::uint32_t value);

  public:
  // uint32 element_type = 3;
  void clear_element_type() ;
  ::uint32_t element_type() const;
  void set_element_type(::uint32_t value);

  private:
  ::uint32_t _internal_element_type() const;
  void _internal_set_element_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeMatrix)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeMatrix& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t num_columns_;
    ::uint32_t num_rows_;
    ::uint32_t element_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeMatrix_class_data_;
// -------------------------------------------------------------------

class TypeInputAttachment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeInputAttachment) */ {
 public:
  inline TypeInputAttachment() : TypeInputAttachment(nullptr) {}
  ~TypeInputAttachment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeInputAttachment* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeInputAttachment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeInputAttachment(::google::protobuf::internal::ConstantInitialized);

  inline TypeInputAttachment(const TypeInputAttachment& from) : TypeInputAttachment(nullptr, from) {}
  inline TypeInputAttachment(TypeInputAttachment&& from) noexcept
      : TypeInputAttachment(nullptr, ::std::move(from)) {}
  inline TypeInputAttachment& operator=(const TypeInputAttachment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeInputAttachment& operator=(TypeInputAttachment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeInputAttachment& default_instance() {
    return *reinterpret_cast<const TypeInputAttachment*>(
        &_TypeInputAttachment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(TypeInputAttachment& a, TypeInputAttachment& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeInputAttachment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeInputAttachment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeInputAttachment* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeInputAttachment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeInputAttachment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeInputAttachment& from) { TypeInputAttachment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeInputAttachment* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeInputAttachment"; }

 protected:
  explicit TypeInputAttachment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeInputAttachment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeInputAttachment& from);
  TypeInputAttachment(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeInputAttachment&& from) noexcept
      : TypeInputAttachment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubTypeFieldNumber = 1,
  };
  // uint32 sub_type = 1;
  void clear_sub_type() ;
  ::uint32_t sub_type() const;
  void set_sub_type(::uint32_t value);

  private:
  ::uint32_t _internal_sub_type() const;
  void _internal_set_sub_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeInputAttachment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeInputAttachment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t sub_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeInputAttachment_class_data_;
// -------------------------------------------------------------------

class TypeExternalTexture final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeExternalTexture) */ {
 public:
  inline TypeExternalTexture() : TypeExternalTexture(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeExternalTexture* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeExternalTexture));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeExternalTexture(::google::protobuf::internal::ConstantInitialized);

  inline TypeExternalTexture(const TypeExternalTexture& from) : TypeExternalTexture(nullptr, from) {}
  inline TypeExternalTexture(TypeExternalTexture&& from) noexcept
      : TypeExternalTexture(nullptr, ::std::move(from)) {}
  inline TypeExternalTexture& operator=(const TypeExternalTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeExternalTexture& operator=(TypeExternalTexture&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeExternalTexture& default_instance() {
    return *reinterpret_cast<const TypeExternalTexture*>(
        &_TypeExternalTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(TypeExternalTexture& a, TypeExternalTexture& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeExternalTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeExternalTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeExternalTexture* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<TypeExternalTexture>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TypeExternalTexture& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TypeExternalTexture& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeExternalTexture"; }

 protected:
  explicit TypeExternalTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeExternalTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeExternalTexture& from);
  TypeExternalTexture(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeExternalTexture&& from) noexcept
      : TypeExternalTexture(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeExternalTexture)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeExternalTexture_class_data_;
// -------------------------------------------------------------------

class TypeDepthTexture final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeDepthTexture) */ {
 public:
  inline TypeDepthTexture() : TypeDepthTexture(nullptr) {}
  ~TypeDepthTexture() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeDepthTexture* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeDepthTexture));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeDepthTexture(::google::protobuf::internal::ConstantInitialized);

  inline TypeDepthTexture(const TypeDepthTexture& from) : TypeDepthTexture(nullptr, from) {}
  inline TypeDepthTexture(TypeDepthTexture&& from) noexcept
      : TypeDepthTexture(nullptr, ::std::move(from)) {}
  inline TypeDepthTexture& operator=(const TypeDepthTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeDepthTexture& operator=(TypeDepthTexture&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeDepthTexture& default_instance() {
    return *reinterpret_cast<const TypeDepthTexture*>(
        &_TypeDepthTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(TypeDepthTexture& a, TypeDepthTexture& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeDepthTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeDepthTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeDepthTexture* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeDepthTexture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeDepthTexture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeDepthTexture& from) { TypeDepthTexture::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeDepthTexture* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeDepthTexture"; }

 protected:
  explicit TypeDepthTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeDepthTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeDepthTexture& from);
  TypeDepthTexture(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeDepthTexture&& from) noexcept
      : TypeDepthTexture(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionFieldNumber = 1,
  };
  // .tint.core.ir.binary.pb.TextureDimension dimension = 1;
  void clear_dimension() ;
  ::tint::core::ir::binary::pb::TextureDimension dimension() const;
  void set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  private:
  ::tint::core::ir::binary::pb::TextureDimension _internal_dimension() const;
  void _internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeDepthTexture)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeDepthTexture& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int dimension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeDepthTexture_class_data_;
// -------------------------------------------------------------------

class TypeDepthMultisampledTexture final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeDepthMultisampledTexture) */ {
 public:
  inline TypeDepthMultisampledTexture() : TypeDepthMultisampledTexture(nullptr) {}
  ~TypeDepthMultisampledTexture() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeDepthMultisampledTexture* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeDepthMultisampledTexture));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeDepthMultisampledTexture(::google::protobuf::internal::ConstantInitialized);

  inline TypeDepthMultisampledTexture(const TypeDepthMultisampledTexture& from) : TypeDepthMultisampledTexture(nullptr, from) {}
  inline TypeDepthMultisampledTexture(TypeDepthMultisampledTexture&& from) noexcept
      : TypeDepthMultisampledTexture(nullptr, ::std::move(from)) {}
  inline TypeDepthMultisampledTexture& operator=(const TypeDepthMultisampledTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeDepthMultisampledTexture& operator=(TypeDepthMultisampledTexture&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeDepthMultisampledTexture& default_instance() {
    return *reinterpret_cast<const TypeDepthMultisampledTexture*>(
        &_TypeDepthMultisampledTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TypeDepthMultisampledTexture& a, TypeDepthMultisampledTexture& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeDepthMultisampledTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeDepthMultisampledTexture* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeDepthMultisampledTexture* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeDepthMultisampledTexture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeDepthMultisampledTexture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeDepthMultisampledTexture& from) { TypeDepthMultisampledTexture::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeDepthMultisampledTexture* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeDepthMultisampledTexture"; }

 protected:
  explicit TypeDepthMultisampledTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeDepthMultisampledTexture(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeDepthMultisampledTexture& from);
  TypeDepthMultisampledTexture(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeDepthMultisampledTexture&& from) noexcept
      : TypeDepthMultisampledTexture(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDimensionFieldNumber = 1,
  };
  // .tint.core.ir.binary.pb.TextureDimension dimension = 1;
  void clear_dimension() ;
  ::tint::core::ir::binary::pb::TextureDimension dimension() const;
  void set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  private:
  ::tint::core::ir::binary::pb::TextureDimension _internal_dimension() const;
  void _internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeDepthMultisampledTexture)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeDepthMultisampledTexture& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int dimension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeDepthMultisampledTexture_class_data_;
// -------------------------------------------------------------------

class TypeBuffer final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeBuffer) */ {
 public:
  inline TypeBuffer() : TypeBuffer(nullptr) {}
  ~TypeBuffer() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeBuffer* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeBuffer));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeBuffer(::google::protobuf::internal::ConstantInitialized);

  inline TypeBuffer(const TypeBuffer& from) : TypeBuffer(nullptr, from) {}
  inline TypeBuffer(TypeBuffer&& from) noexcept
      : TypeBuffer(nullptr, ::std::move(from)) {}
  inline TypeBuffer& operator=(const TypeBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeBuffer& operator=(TypeBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeBuffer& default_instance() {
    return *reinterpret_cast<const TypeBuffer*>(
        &_TypeBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(TypeBuffer& a, TypeBuffer& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeBuffer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeBuffer* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeBuffer* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeBuffer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeBuffer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeBuffer& from) { TypeBuffer::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeBuffer* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeBuffer"; }

 protected:
  explicit TypeBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeBuffer(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeBuffer& from);
  TypeBuffer(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeBuffer&& from) noexcept
      : TypeBuffer(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCountFieldNumber = 1,
  };
  // uint32 count = 1;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeBuffer)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeBuffer& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeBuffer_class_data_;
// -------------------------------------------------------------------

class TypeBindingArray final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeBindingArray) */ {
 public:
  inline TypeBindingArray() : TypeBindingArray(nullptr) {}
  ~TypeBindingArray() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeBindingArray* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeBindingArray));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeBindingArray(::google::protobuf::internal::ConstantInitialized);

  inline TypeBindingArray(const TypeBindingArray& from) : TypeBindingArray(nullptr, from) {}
  inline TypeBindingArray(TypeBindingArray&& from) noexcept
      : TypeBindingArray(nullptr, ::std::move(from)) {}
  inline TypeBindingArray& operator=(const TypeBindingArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeBindingArray& operator=(TypeBindingArray&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeBindingArray& default_instance() {
    return *reinterpret_cast<const TypeBindingArray*>(
        &_TypeBindingArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(TypeBindingArray& a, TypeBindingArray& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeBindingArray* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeBindingArray* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeBindingArray* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeBindingArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeBindingArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeBindingArray& from) { TypeBindingArray::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeBindingArray* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeBindingArray"; }

 protected:
  explicit TypeBindingArray(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeBindingArray(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeBindingArray& from);
  TypeBindingArray(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeBindingArray&& from) noexcept
      : TypeBindingArray(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElementFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // uint32 element = 1;
  void clear_element() ;
  ::uint32_t element() const;
  void set_element(::uint32_t value);

  private:
  ::uint32_t _internal_element() const;
  void _internal_set_element(::uint32_t value);

  public:
  // uint32 count = 2;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeBindingArray)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeBindingArray& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t element_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeBindingArray_class_data_;
// -------------------------------------------------------------------

class TypeAtomic final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeAtomic) */ {
 public:
  inline TypeAtomic() : TypeAtomic(nullptr) {}
  ~TypeAtomic() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeAtomic* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeAtomic));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeAtomic(::google::protobuf::internal::ConstantInitialized);

  inline TypeAtomic(const TypeAtomic& from) : TypeAtomic(nullptr, from) {}
  inline TypeAtomic(TypeAtomic&& from) noexcept
      : TypeAtomic(nullptr, ::std::move(from)) {}
  inline TypeAtomic& operator=(const TypeAtomic& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeAtomic& operator=(TypeAtomic&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeAtomic& default_instance() {
    return *reinterpret_cast<const TypeAtomic*>(
        &_TypeAtomic_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(TypeAtomic& a, TypeAtomic& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeAtomic* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeAtomic* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeAtomic* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeAtomic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeAtomic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeAtomic& from) { TypeAtomic::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeAtomic* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeAtomic"; }

 protected:
  explicit TypeAtomic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeAtomic(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeAtomic& from);
  TypeAtomic(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeAtomic&& from) noexcept
      : TypeAtomic(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
  };
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeAtomic)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeAtomic& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeAtomic_class_data_;
// -------------------------------------------------------------------

class TypeArray final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeArray) */ {
 public:
  inline TypeArray() : TypeArray(nullptr) {}
  ~TypeArray() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeArray* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeArray));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeArray(::google::protobuf::internal::ConstantInitialized);

  inline TypeArray(const TypeArray& from) : TypeArray(nullptr, from) {}
  inline TypeArray(TypeArray&& from) noexcept
      : TypeArray(nullptr, ::std::move(from)) {}
  inline TypeArray& operator=(const TypeArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeArray& operator=(TypeArray&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeArray& default_instance() {
    return *reinterpret_cast<const TypeArray*>(
        &_TypeArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TypeArray& a, TypeArray& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeArray* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeArray* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeArray* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeArray& from) { TypeArray::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeArray* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeArray"; }

 protected:
  explicit TypeArray(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeArray(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeArray& from);
  TypeArray(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeArray&& from) noexcept
      : TypeArray(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElementFieldNumber = 1,
    kCountFieldNumber = 3,
  };
  // uint32 element = 1;
  void clear_element() ;
  ::uint32_t element() const;
  void set_element(::uint32_t value);

  private:
  ::uint32_t _internal_element() const;
  void _internal_set_element(::uint32_t value);

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeArray)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeArray& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t element_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeArray_class_data_;
// -------------------------------------------------------------------

class SwitchCase final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.SwitchCase) */ {
 public:
  inline SwitchCase() : SwitchCase(nullptr) {}
  ~SwitchCase() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SwitchCase* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SwitchCase));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SwitchCase(::google::protobuf::internal::ConstantInitialized);

  inline SwitchCase(const SwitchCase& from) : SwitchCase(nullptr, from) {}
  inline SwitchCase(SwitchCase&& from) noexcept
      : SwitchCase(nullptr, ::std::move(from)) {}
  inline SwitchCase& operator=(const SwitchCase& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchCase& operator=(SwitchCase&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwitchCase& default_instance() {
    return *reinterpret_cast<const SwitchCase*>(
        &_SwitchCase_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(SwitchCase& a, SwitchCase& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(SwitchCase* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwitchCase* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwitchCase* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SwitchCase>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SwitchCase& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SwitchCase& from) { SwitchCase::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SwitchCase* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.SwitchCase"; }

 protected:
  explicit SwitchCase(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SwitchCase(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SwitchCase& from);
  SwitchCase(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SwitchCase&& from) noexcept
      : SwitchCase(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSelectorsFieldNumber = 2,
    kBlockFieldNumber = 1,
    kIsDefaultFieldNumber = 3,
  };
  // repeated uint32 selectors = 2;
  int selectors_size() const;
  private:
  int _internal_selectors_size() const;

  public:
  void clear_selectors() ;
  ::uint32_t selectors(int index) const;
  void set_selectors(int index, ::uint32_t value);
  void add_selectors(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& selectors() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_selectors();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_selectors() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_selectors();

  public:
  // uint32 block = 1;
  void clear_block() ;
  ::uint32_t block() const;
  void set_block(::uint32_t value);

  private:
  ::uint32_t _internal_block() const;
  void _internal_set_block(::uint32_t value);

  public:
  // bool is_default = 3;
  void clear_is_default() ;
  bool is_default() const;
  void set_is_default(bool value);

  private:
  bool _internal_is_default() const;
  void _internal_set_is_default(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.SwitchCase)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SwitchCase& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> selectors_;
    ::google::protobuf::internal::CachedSize _selectors_cached_byte_size_;
    ::uint32_t block_;
    bool is_default_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SwitchCase_class_data_;
// -------------------------------------------------------------------

class Interpolation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Interpolation) */ {
 public:
  inline Interpolation() : Interpolation(nullptr) {}
  ~Interpolation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Interpolation* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Interpolation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Interpolation(::google::protobuf::internal::ConstantInitialized);

  inline Interpolation(const Interpolation& from) : Interpolation(nullptr, from) {}
  inline Interpolation(Interpolation&& from) noexcept
      : Interpolation(nullptr, ::std::move(from)) {}
  inline Interpolation& operator=(const Interpolation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interpolation& operator=(Interpolation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Interpolation& default_instance() {
    return *reinterpret_cast<const Interpolation*>(
        &_Interpolation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(Interpolation& a, Interpolation& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Interpolation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interpolation* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Interpolation* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Interpolation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Interpolation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Interpolation& from) { Interpolation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Interpolation* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Interpolation"; }

 protected:
  explicit Interpolation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Interpolation(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Interpolation& from);
  Interpolation(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Interpolation&& from) noexcept
      : Interpolation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kSamplingFieldNumber = 2,
  };
  // .tint.core.ir.binary.pb.InterpolationType type = 1;
  void clear_type() ;
  ::tint::core::ir::binary::pb::InterpolationType type() const;
  void set_type(::tint::core::ir::binary::pb::InterpolationType value);

  private:
  ::tint::core::ir::binary::pb::InterpolationType _internal_type() const;
  void _internal_set_type(::tint::core::ir::binary::pb::InterpolationType value);

  public:
  // optional .tint.core.ir.binary.pb.InterpolationSampling sampling = 2;
  bool has_sampling() const;
  void clear_sampling() ;
  ::tint::core::ir::binary::pb::InterpolationSampling sampling() const;
  void set_sampling(::tint::core::ir::binary::pb::InterpolationSampling value);

  private:
  ::tint::core::ir::binary::pb::InterpolationSampling _internal_sampling() const;
  void _internal_set_sampling(::tint::core::ir::binary::pb::InterpolationSampling value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Interpolation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Interpolation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    int sampling_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Interpolation_class_data_;
// -------------------------------------------------------------------

class InstructionUserCall final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionUserCall) */ {
 public:
  inline InstructionUserCall() : InstructionUserCall(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionUserCall* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionUserCall));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionUserCall(::google::protobuf::internal::ConstantInitialized);

  inline InstructionUserCall(const InstructionUserCall& from) : InstructionUserCall(nullptr, from) {}
  inline InstructionUserCall(InstructionUserCall&& from) noexcept
      : InstructionUserCall(nullptr, ::std::move(from)) {}
  inline InstructionUserCall& operator=(const InstructionUserCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionUserCall& operator=(InstructionUserCall&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionUserCall& default_instance() {
    return *reinterpret_cast<const InstructionUserCall*>(
        &_InstructionUserCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(InstructionUserCall& a, InstructionUserCall& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionUserCall* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionUserCall* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionUserCall* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionUserCall>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionUserCall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionUserCall& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionUserCall"; }

 protected:
  explicit InstructionUserCall(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionUserCall(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionUserCall& from);
  InstructionUserCall(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionUserCall&& from) noexcept
      : InstructionUserCall(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionUserCall)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionUserCall_class_data_;
// -------------------------------------------------------------------

class InstructionUnreachable final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionUnreachable) */ {
 public:
  inline InstructionUnreachable() : InstructionUnreachable(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionUnreachable* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionUnreachable));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionUnreachable(::google::protobuf::internal::ConstantInitialized);

  inline InstructionUnreachable(const InstructionUnreachable& from) : InstructionUnreachable(nullptr, from) {}
  inline InstructionUnreachable(InstructionUnreachable&& from) noexcept
      : InstructionUnreachable(nullptr, ::std::move(from)) {}
  inline InstructionUnreachable& operator=(const InstructionUnreachable& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionUnreachable& operator=(InstructionUnreachable&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionUnreachable& default_instance() {
    return *reinterpret_cast<const InstructionUnreachable*>(
        &_InstructionUnreachable_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(InstructionUnreachable& a, InstructionUnreachable& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionUnreachable* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionUnreachable* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionUnreachable* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionUnreachable>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionUnreachable& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionUnreachable& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionUnreachable"; }

 protected:
  explicit InstructionUnreachable(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionUnreachable(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionUnreachable& from);
  InstructionUnreachable(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionUnreachable&& from) noexcept
      : InstructionUnreachable(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionUnreachable)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionUnreachable_class_data_;
// -------------------------------------------------------------------

class InstructionUnary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionUnary) */ {
 public:
  inline InstructionUnary() : InstructionUnary(nullptr) {}
  ~InstructionUnary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionUnary* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionUnary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionUnary(::google::protobuf::internal::ConstantInitialized);

  inline InstructionUnary(const InstructionUnary& from) : InstructionUnary(nullptr, from) {}
  inline InstructionUnary(InstructionUnary&& from) noexcept
      : InstructionUnary(nullptr, ::std::move(from)) {}
  inline InstructionUnary& operator=(const InstructionUnary& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionUnary& operator=(InstructionUnary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionUnary& default_instance() {
    return *reinterpret_cast<const InstructionUnary*>(
        &_InstructionUnary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(InstructionUnary& a, InstructionUnary& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionUnary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionUnary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionUnary* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionUnary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionUnary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionUnary& from) { InstructionUnary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionUnary* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionUnary"; }

 protected:
  explicit InstructionUnary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionUnary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionUnary& from);
  InstructionUnary(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionUnary&& from) noexcept
      : InstructionUnary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpFieldNumber = 1,
  };
  // .tint.core.ir.binary.pb.UnaryOp op = 1;
  void clear_op() ;
  ::tint::core::ir::binary::pb::UnaryOp op() const;
  void set_op(::tint::core::ir::binary::pb::UnaryOp value);

  private:
  ::tint::core::ir::binary::pb::UnaryOp _internal_op() const;
  void _internal_set_op(::tint::core::ir::binary::pb::UnaryOp value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionUnary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionUnary& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionUnary_class_data_;
// -------------------------------------------------------------------

class InstructionSwizzle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionSwizzle) */ {
 public:
  inline InstructionSwizzle() : InstructionSwizzle(nullptr) {}
  ~InstructionSwizzle() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionSwizzle* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionSwizzle));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionSwizzle(::google::protobuf::internal::ConstantInitialized);

  inline InstructionSwizzle(const InstructionSwizzle& from) : InstructionSwizzle(nullptr, from) {}
  inline InstructionSwizzle(InstructionSwizzle&& from) noexcept
      : InstructionSwizzle(nullptr, ::std::move(from)) {}
  inline InstructionSwizzle& operator=(const InstructionSwizzle& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionSwizzle& operator=(InstructionSwizzle&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionSwizzle& default_instance() {
    return *reinterpret_cast<const InstructionSwizzle*>(
        &_InstructionSwizzle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(InstructionSwizzle& a, InstructionSwizzle& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionSwizzle* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionSwizzle* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionSwizzle* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionSwizzle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionSwizzle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionSwizzle& from) { InstructionSwizzle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionSwizzle* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionSwizzle"; }

 protected:
  explicit InstructionSwizzle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionSwizzle(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionSwizzle& from);
  InstructionSwizzle(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionSwizzle&& from) noexcept
      : InstructionSwizzle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndicesFieldNumber = 1,
  };
  // repeated uint32 indices = 1;
  int indices_size() const;
  private:
  int _internal_indices_size() const;

  public:
  void clear_indices() ;
  ::uint32_t indices(int index) const;
  void set_indices(int index, ::uint32_t value);
  void add_indices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_indices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_indices();

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionSwizzle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionSwizzle& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> indices_;
    ::google::protobuf::internal::CachedSize _indices_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionSwizzle_class_data_;
// -------------------------------------------------------------------

class InstructionStoreVectorElement final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionStoreVectorElement) */ {
 public:
  inline InstructionStoreVectorElement() : InstructionStoreVectorElement(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionStoreVectorElement* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionStoreVectorElement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionStoreVectorElement(::google::protobuf::internal::ConstantInitialized);

  inline InstructionStoreVectorElement(const InstructionStoreVectorElement& from) : InstructionStoreVectorElement(nullptr, from) {}
  inline InstructionStoreVectorElement(InstructionStoreVectorElement&& from) noexcept
      : InstructionStoreVectorElement(nullptr, ::std::move(from)) {}
  inline InstructionStoreVectorElement& operator=(const InstructionStoreVectorElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionStoreVectorElement& operator=(InstructionStoreVectorElement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionStoreVectorElement& default_instance() {
    return *reinterpret_cast<const InstructionStoreVectorElement*>(
        &_InstructionStoreVectorElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(InstructionStoreVectorElement& a, InstructionStoreVectorElement& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionStoreVectorElement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionStoreVectorElement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionStoreVectorElement* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionStoreVectorElement>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionStoreVectorElement& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionStoreVectorElement& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionStoreVectorElement"; }

 protected:
  explicit InstructionStoreVectorElement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionStoreVectorElement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionStoreVectorElement& from);
  InstructionStoreVectorElement(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionStoreVectorElement&& from) noexcept
      : InstructionStoreVectorElement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionStoreVectorElement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionStoreVectorElement_class_data_;
// -------------------------------------------------------------------

class InstructionStore final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionStore) */ {
 public:
  inline InstructionStore() : InstructionStore(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionStore* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionStore));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionStore(::google::protobuf::internal::ConstantInitialized);

  inline InstructionStore(const InstructionStore& from) : InstructionStore(nullptr, from) {}
  inline InstructionStore(InstructionStore&& from) noexcept
      : InstructionStore(nullptr, ::std::move(from)) {}
  inline InstructionStore& operator=(const InstructionStore& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionStore& operator=(InstructionStore&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionStore& default_instance() {
    return *reinterpret_cast<const InstructionStore*>(
        &_InstructionStore_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(InstructionStore& a, InstructionStore& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionStore* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionStore* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionStore* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionStore>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionStore& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionStore& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionStore"; }

 protected:
  explicit InstructionStore(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionStore(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionStore& from);
  InstructionStore(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionStore&& from) noexcept
      : InstructionStore(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionStore)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionStore_class_data_;
// -------------------------------------------------------------------

class InstructionReturn final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionReturn) */ {
 public:
  inline InstructionReturn() : InstructionReturn(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionReturn* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionReturn));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionReturn(::google::protobuf::internal::ConstantInitialized);

  inline InstructionReturn(const InstructionReturn& from) : InstructionReturn(nullptr, from) {}
  inline InstructionReturn(InstructionReturn&& from) noexcept
      : InstructionReturn(nullptr, ::std::move(from)) {}
  inline InstructionReturn& operator=(const InstructionReturn& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionReturn& operator=(InstructionReturn&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionReturn& default_instance() {
    return *reinterpret_cast<const InstructionReturn*>(
        &_InstructionReturn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(InstructionReturn& a, InstructionReturn& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionReturn* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionReturn* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionReturn* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionReturn>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionReturn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionReturn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionReturn"; }

 protected:
  explicit InstructionReturn(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionReturn(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionReturn& from);
  InstructionReturn(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionReturn&& from) noexcept
      : InstructionReturn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionReturn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionReturn_class_data_;
// -------------------------------------------------------------------

class InstructionResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionResult) */ {
 public:
  inline InstructionResult() : InstructionResult(nullptr) {}
  ~InstructionResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionResult* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionResult(::google::protobuf::internal::ConstantInitialized);

  inline InstructionResult(const InstructionResult& from) : InstructionResult(nullptr, from) {}
  inline InstructionResult(InstructionResult&& from) noexcept
      : InstructionResult(nullptr, ::std::move(from)) {}
  inline InstructionResult& operator=(const InstructionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionResult& operator=(InstructionResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionResult& default_instance() {
    return *reinterpret_cast<const InstructionResult*>(
        &_InstructionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(InstructionResult& a, InstructionResult& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionResult* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionResult* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionResult& from) { InstructionResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionResult* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionResult"; }

 protected:
  explicit InstructionResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionResult(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionResult& from);
  InstructionResult(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionResult&& from) noexcept
      : InstructionResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionResult_class_data_;
// -------------------------------------------------------------------

class InstructionNextIteration final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionNextIteration) */ {
 public:
  inline InstructionNextIteration() : InstructionNextIteration(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionNextIteration* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionNextIteration));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionNextIteration(::google::protobuf::internal::ConstantInitialized);

  inline InstructionNextIteration(const InstructionNextIteration& from) : InstructionNextIteration(nullptr, from) {}
  inline InstructionNextIteration(InstructionNextIteration&& from) noexcept
      : InstructionNextIteration(nullptr, ::std::move(from)) {}
  inline InstructionNextIteration& operator=(const InstructionNextIteration& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionNextIteration& operator=(InstructionNextIteration&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionNextIteration& default_instance() {
    return *reinterpret_cast<const InstructionNextIteration*>(
        &_InstructionNextIteration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(InstructionNextIteration& a, InstructionNextIteration& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionNextIteration* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionNextIteration* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionNextIteration* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionNextIteration>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionNextIteration& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionNextIteration& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionNextIteration"; }

 protected:
  explicit InstructionNextIteration(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionNextIteration(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionNextIteration& from);
  InstructionNextIteration(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionNextIteration&& from) noexcept
      : InstructionNextIteration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionNextIteration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionNextIteration_class_data_;
// -------------------------------------------------------------------

class InstructionLoop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionLoop) */ {
 public:
  inline InstructionLoop() : InstructionLoop(nullptr) {}
  ~InstructionLoop() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionLoop* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionLoop));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionLoop(::google::protobuf::internal::ConstantInitialized);

  inline InstructionLoop(const InstructionLoop& from) : InstructionLoop(nullptr, from) {}
  inline InstructionLoop(InstructionLoop&& from) noexcept
      : InstructionLoop(nullptr, ::std::move(from)) {}
  inline InstructionLoop& operator=(const InstructionLoop& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionLoop& operator=(InstructionLoop&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionLoop& default_instance() {
    return *reinterpret_cast<const InstructionLoop*>(
        &_InstructionLoop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(InstructionLoop& a, InstructionLoop& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionLoop* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionLoop* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionLoop* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionLoop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionLoop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionLoop& from) { InstructionLoop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionLoop* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionLoop"; }

 protected:
  explicit InstructionLoop(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionLoop(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionLoop& from);
  InstructionLoop(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionLoop&& from) noexcept
      : InstructionLoop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitializerFieldNumber = 1,
    kBodyFieldNumber = 2,
    kContinuingFieldNumber = 3,
  };
  // optional uint32 initializer = 1;
  bool has_initializer() const;
  void clear_initializer() ;
  ::uint32_t initializer() const;
  void set_initializer(::uint32_t value);

  private:
  ::uint32_t _internal_initializer() const;
  void _internal_set_initializer(::uint32_t value);

  public:
  // optional uint32 body = 2;
  bool has_body() const;
  void clear_body() ;
  ::uint32_t body() const;
  void set_body(::uint32_t value);

  private:
  ::uint32_t _internal_body() const;
  void _internal_set_body(::uint32_t value);

  public:
  // optional uint32 continuing = 3;
  bool has_continuing() const;
  void clear_continuing() ;
  ::uint32_t continuing() const;
  void set_continuing(::uint32_t value);

  private:
  ::uint32_t _internal_continuing() const;
  void _internal_set_continuing(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionLoop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionLoop& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t initializer_;
    ::uint32_t body_;
    ::uint32_t continuing_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionLoop_class_data_;
// -------------------------------------------------------------------

class InstructionLoadVectorElement final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionLoadVectorElement) */ {
 public:
  inline InstructionLoadVectorElement() : InstructionLoadVectorElement(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionLoadVectorElement* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionLoadVectorElement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionLoadVectorElement(::google::protobuf::internal::ConstantInitialized);

  inline InstructionLoadVectorElement(const InstructionLoadVectorElement& from) : InstructionLoadVectorElement(nullptr, from) {}
  inline InstructionLoadVectorElement(InstructionLoadVectorElement&& from) noexcept
      : InstructionLoadVectorElement(nullptr, ::std::move(from)) {}
  inline InstructionLoadVectorElement& operator=(const InstructionLoadVectorElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionLoadVectorElement& operator=(InstructionLoadVectorElement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionLoadVectorElement& default_instance() {
    return *reinterpret_cast<const InstructionLoadVectorElement*>(
        &_InstructionLoadVectorElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(InstructionLoadVectorElement& a, InstructionLoadVectorElement& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionLoadVectorElement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionLoadVectorElement* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionLoadVectorElement* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionLoadVectorElement>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionLoadVectorElement& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionLoadVectorElement& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionLoadVectorElement"; }

 protected:
  explicit InstructionLoadVectorElement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionLoadVectorElement(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionLoadVectorElement& from);
  InstructionLoadVectorElement(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionLoadVectorElement&& from) noexcept
      : InstructionLoadVectorElement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionLoadVectorElement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionLoadVectorElement_class_data_;
// -------------------------------------------------------------------

class InstructionLoad final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionLoad) */ {
 public:
  inline InstructionLoad() : InstructionLoad(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionLoad* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionLoad));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionLoad(::google::protobuf::internal::ConstantInitialized);

  inline InstructionLoad(const InstructionLoad& from) : InstructionLoad(nullptr, from) {}
  inline InstructionLoad(InstructionLoad&& from) noexcept
      : InstructionLoad(nullptr, ::std::move(from)) {}
  inline InstructionLoad& operator=(const InstructionLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionLoad& operator=(InstructionLoad&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionLoad& default_instance() {
    return *reinterpret_cast<const InstructionLoad*>(
        &_InstructionLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(InstructionLoad& a, InstructionLoad& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionLoad* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionLoad* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionLoad* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionLoad>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionLoad& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionLoad& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionLoad"; }

 protected:
  explicit InstructionLoad(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionLoad(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionLoad& from);
  InstructionLoad(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionLoad&& from) noexcept
      : InstructionLoad(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionLoad)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionLoad_class_data_;
// -------------------------------------------------------------------

class InstructionLet final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionLet) */ {
 public:
  inline InstructionLet() : InstructionLet(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionLet* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionLet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionLet(::google::protobuf::internal::ConstantInitialized);

  inline InstructionLet(const InstructionLet& from) : InstructionLet(nullptr, from) {}
  inline InstructionLet(InstructionLet&& from) noexcept
      : InstructionLet(nullptr, ::std::move(from)) {}
  inline InstructionLet& operator=(const InstructionLet& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionLet& operator=(InstructionLet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionLet& default_instance() {
    return *reinterpret_cast<const InstructionLet*>(
        &_InstructionLet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(InstructionLet& a, InstructionLet& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionLet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionLet* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionLet* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionLet>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionLet& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionLet& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionLet"; }

 protected:
  explicit InstructionLet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionLet(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionLet& from);
  InstructionLet(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionLet&& from) noexcept
      : InstructionLet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionLet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionLet_class_data_;
// -------------------------------------------------------------------

class InstructionIf final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionIf) */ {
 public:
  inline InstructionIf() : InstructionIf(nullptr) {}
  ~InstructionIf() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionIf* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionIf));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionIf(::google::protobuf::internal::ConstantInitialized);

  inline InstructionIf(const InstructionIf& from) : InstructionIf(nullptr, from) {}
  inline InstructionIf(InstructionIf&& from) noexcept
      : InstructionIf(nullptr, ::std::move(from)) {}
  inline InstructionIf& operator=(const InstructionIf& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionIf& operator=(InstructionIf&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionIf& default_instance() {
    return *reinterpret_cast<const InstructionIf*>(
        &_InstructionIf_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(InstructionIf& a, InstructionIf& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionIf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionIf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionIf* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionIf>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionIf& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionIf& from) { InstructionIf::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionIf* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionIf"; }

 protected:
  explicit InstructionIf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionIf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionIf& from);
  InstructionIf(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionIf&& from) noexcept
      : InstructionIf(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTrueFieldNumber = 1,
    kFalseFieldNumber = 2,
  };
  // optional uint32 true = 1;
  bool has_true_() const;
  void clear_true_() ;
  ::uint32_t true_() const;
  void set_true_(::uint32_t value);

  private:
  ::uint32_t _internal_true_() const;
  void _internal_set_true_(::uint32_t value);

  public:
  // optional uint32 false = 2;
  bool has_false_() const;
  void clear_false_() ;
  ::uint32_t false_() const;
  void set_false_(::uint32_t value);

  private:
  ::uint32_t _internal_false_() const;
  void _internal_set_false_(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionIf)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionIf& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t true__;
    ::uint32_t false__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionIf_class_data_;
// -------------------------------------------------------------------

class InstructionExitSwitch final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionExitSwitch) */ {
 public:
  inline InstructionExitSwitch() : InstructionExitSwitch(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionExitSwitch* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionExitSwitch));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionExitSwitch(::google::protobuf::internal::ConstantInitialized);

  inline InstructionExitSwitch(const InstructionExitSwitch& from) : InstructionExitSwitch(nullptr, from) {}
  inline InstructionExitSwitch(InstructionExitSwitch&& from) noexcept
      : InstructionExitSwitch(nullptr, ::std::move(from)) {}
  inline InstructionExitSwitch& operator=(const InstructionExitSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionExitSwitch& operator=(InstructionExitSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionExitSwitch& default_instance() {
    return *reinterpret_cast<const InstructionExitSwitch*>(
        &_InstructionExitSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(InstructionExitSwitch& a, InstructionExitSwitch& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionExitSwitch* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionExitSwitch* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionExitSwitch* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionExitSwitch>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionExitSwitch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionExitSwitch& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionExitSwitch"; }

 protected:
  explicit InstructionExitSwitch(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionExitSwitch(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionExitSwitch& from);
  InstructionExitSwitch(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionExitSwitch&& from) noexcept
      : InstructionExitSwitch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionExitSwitch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionExitSwitch_class_data_;
// -------------------------------------------------------------------

class InstructionExitLoop final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionExitLoop) */ {
 public:
  inline InstructionExitLoop() : InstructionExitLoop(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionExitLoop* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionExitLoop));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionExitLoop(::google::protobuf::internal::ConstantInitialized);

  inline InstructionExitLoop(const InstructionExitLoop& from) : InstructionExitLoop(nullptr, from) {}
  inline InstructionExitLoop(InstructionExitLoop&& from) noexcept
      : InstructionExitLoop(nullptr, ::std::move(from)) {}
  inline InstructionExitLoop& operator=(const InstructionExitLoop& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionExitLoop& operator=(InstructionExitLoop&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionExitLoop& default_instance() {
    return *reinterpret_cast<const InstructionExitLoop*>(
        &_InstructionExitLoop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(InstructionExitLoop& a, InstructionExitLoop& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionExitLoop* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionExitLoop* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionExitLoop* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionExitLoop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionExitLoop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionExitLoop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionExitLoop"; }

 protected:
  explicit InstructionExitLoop(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionExitLoop(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionExitLoop& from);
  InstructionExitLoop(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionExitLoop&& from) noexcept
      : InstructionExitLoop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionExitLoop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionExitLoop_class_data_;
// -------------------------------------------------------------------

class InstructionExitIf final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionExitIf) */ {
 public:
  inline InstructionExitIf() : InstructionExitIf(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionExitIf* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionExitIf));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionExitIf(::google::protobuf::internal::ConstantInitialized);

  inline InstructionExitIf(const InstructionExitIf& from) : InstructionExitIf(nullptr, from) {}
  inline InstructionExitIf(InstructionExitIf&& from) noexcept
      : InstructionExitIf(nullptr, ::std::move(from)) {}
  inline InstructionExitIf& operator=(const InstructionExitIf& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionExitIf& operator=(InstructionExitIf&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionExitIf& default_instance() {
    return *reinterpret_cast<const InstructionExitIf*>(
        &_InstructionExitIf_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(InstructionExitIf& a, InstructionExitIf& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionExitIf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionExitIf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionExitIf* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionExitIf>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionExitIf& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionExitIf& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionExitIf"; }

 protected:
  explicit InstructionExitIf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionExitIf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionExitIf& from);
  InstructionExitIf(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionExitIf&& from) noexcept
      : InstructionExitIf(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionExitIf)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionExitIf_class_data_;
// -------------------------------------------------------------------

class InstructionDiscard final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionDiscard) */ {
 public:
  inline InstructionDiscard() : InstructionDiscard(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionDiscard* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionDiscard));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionDiscard(::google::protobuf::internal::ConstantInitialized);

  inline InstructionDiscard(const InstructionDiscard& from) : InstructionDiscard(nullptr, from) {}
  inline InstructionDiscard(InstructionDiscard&& from) noexcept
      : InstructionDiscard(nullptr, ::std::move(from)) {}
  inline InstructionDiscard& operator=(const InstructionDiscard& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionDiscard& operator=(InstructionDiscard&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionDiscard& default_instance() {
    return *reinterpret_cast<const InstructionDiscard*>(
        &_InstructionDiscard_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(InstructionDiscard& a, InstructionDiscard& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionDiscard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionDiscard* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionDiscard* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionDiscard>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionDiscard& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionDiscard& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionDiscard"; }

 protected:
  explicit InstructionDiscard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionDiscard(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionDiscard& from);
  InstructionDiscard(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionDiscard&& from) noexcept
      : InstructionDiscard(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionDiscard)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionDiscard_class_data_;
// -------------------------------------------------------------------

class InstructionConvert final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionConvert) */ {
 public:
  inline InstructionConvert() : InstructionConvert(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionConvert* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionConvert));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionConvert(::google::protobuf::internal::ConstantInitialized);

  inline InstructionConvert(const InstructionConvert& from) : InstructionConvert(nullptr, from) {}
  inline InstructionConvert(InstructionConvert&& from) noexcept
      : InstructionConvert(nullptr, ::std::move(from)) {}
  inline InstructionConvert& operator=(const InstructionConvert& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionConvert& operator=(InstructionConvert&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionConvert& default_instance() {
    return *reinterpret_cast<const InstructionConvert*>(
        &_InstructionConvert_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(InstructionConvert& a, InstructionConvert& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionConvert* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionConvert* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionConvert* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionConvert>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionConvert& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionConvert& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionConvert"; }

 protected:
  explicit InstructionConvert(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionConvert(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionConvert& from);
  InstructionConvert(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionConvert&& from) noexcept
      : InstructionConvert(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionConvert)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionConvert_class_data_;
// -------------------------------------------------------------------

class InstructionContinue final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionContinue) */ {
 public:
  inline InstructionContinue() : InstructionContinue(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionContinue* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionContinue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionContinue(::google::protobuf::internal::ConstantInitialized);

  inline InstructionContinue(const InstructionContinue& from) : InstructionContinue(nullptr, from) {}
  inline InstructionContinue(InstructionContinue&& from) noexcept
      : InstructionContinue(nullptr, ::std::move(from)) {}
  inline InstructionContinue& operator=(const InstructionContinue& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionContinue& operator=(InstructionContinue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionContinue& default_instance() {
    return *reinterpret_cast<const InstructionContinue*>(
        &_InstructionContinue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(InstructionContinue& a, InstructionContinue& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionContinue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionContinue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionContinue* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionContinue>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionContinue& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionContinue& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionContinue"; }

 protected:
  explicit InstructionContinue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionContinue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionContinue& from);
  InstructionContinue(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionContinue&& from) noexcept
      : InstructionContinue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionContinue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionContinue_class_data_;
// -------------------------------------------------------------------

class InstructionConstruct final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionConstruct) */ {
 public:
  inline InstructionConstruct() : InstructionConstruct(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionConstruct* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionConstruct));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionConstruct(::google::protobuf::internal::ConstantInitialized);

  inline InstructionConstruct(const InstructionConstruct& from) : InstructionConstruct(nullptr, from) {}
  inline InstructionConstruct(InstructionConstruct&& from) noexcept
      : InstructionConstruct(nullptr, ::std::move(from)) {}
  inline InstructionConstruct& operator=(const InstructionConstruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionConstruct& operator=(InstructionConstruct&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionConstruct& default_instance() {
    return *reinterpret_cast<const InstructionConstruct*>(
        &_InstructionConstruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(InstructionConstruct& a, InstructionConstruct& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionConstruct* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionConstruct* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionConstruct* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionConstruct>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionConstruct& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionConstruct& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionConstruct"; }

 protected:
  explicit InstructionConstruct(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionConstruct(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionConstruct& from);
  InstructionConstruct(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionConstruct&& from) noexcept
      : InstructionConstruct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionConstruct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionConstruct_class_data_;
// -------------------------------------------------------------------

class InstructionBuiltinCall final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionBuiltinCall) */ {
 public:
  inline InstructionBuiltinCall() : InstructionBuiltinCall(nullptr) {}
  ~InstructionBuiltinCall() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionBuiltinCall* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionBuiltinCall));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionBuiltinCall(::google::protobuf::internal::ConstantInitialized);

  inline InstructionBuiltinCall(const InstructionBuiltinCall& from) : InstructionBuiltinCall(nullptr, from) {}
  inline InstructionBuiltinCall(InstructionBuiltinCall&& from) noexcept
      : InstructionBuiltinCall(nullptr, ::std::move(from)) {}
  inline InstructionBuiltinCall& operator=(const InstructionBuiltinCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionBuiltinCall& operator=(InstructionBuiltinCall&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionBuiltinCall& default_instance() {
    return *reinterpret_cast<const InstructionBuiltinCall*>(
        &_InstructionBuiltinCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(InstructionBuiltinCall& a, InstructionBuiltinCall& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionBuiltinCall* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionBuiltinCall* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionBuiltinCall* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionBuiltinCall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionBuiltinCall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionBuiltinCall& from) { InstructionBuiltinCall::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionBuiltinCall* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionBuiltinCall"; }

 protected:
  explicit InstructionBuiltinCall(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionBuiltinCall(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionBuiltinCall& from);
  InstructionBuiltinCall(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionBuiltinCall&& from) noexcept
      : InstructionBuiltinCall(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExplicitTemplateParamsFieldNumber = 2,
    kBuiltinFieldNumber = 1,
  };
  // repeated uint32 explicit_template_params = 2;
  int explicit_template_params_size() const;
  private:
  int _internal_explicit_template_params_size() const;

  public:
  void clear_explicit_template_params() ;
  ::uint32_t explicit_template_params(int index) const;
  void set_explicit_template_params(int index, ::uint32_t value);
  void add_explicit_template_params(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& explicit_template_params() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_explicit_template_params();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_explicit_template_params() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_explicit_template_params();

  public:
  // .tint.core.ir.binary.pb.BuiltinFn builtin = 1;
  void clear_builtin() ;
  ::tint::core::ir::binary::pb::BuiltinFn builtin() const;
  void set_builtin(::tint::core::ir::binary::pb::BuiltinFn value);

  private:
  ::tint::core::ir::binary::pb::BuiltinFn _internal_builtin() const;
  void _internal_set_builtin(::tint::core::ir::binary::pb::BuiltinFn value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionBuiltinCall)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionBuiltinCall& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> explicit_template_params_;
    ::google::protobuf::internal::CachedSize _explicit_template_params_cached_byte_size_;
    int builtin_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionBuiltinCall_class_data_;
// -------------------------------------------------------------------

class InstructionBreakIf final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionBreakIf) */ {
 public:
  inline InstructionBreakIf() : InstructionBreakIf(nullptr) {}
  ~InstructionBreakIf() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionBreakIf* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionBreakIf));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionBreakIf(::google::protobuf::internal::ConstantInitialized);

  inline InstructionBreakIf(const InstructionBreakIf& from) : InstructionBreakIf(nullptr, from) {}
  inline InstructionBreakIf(InstructionBreakIf&& from) noexcept
      : InstructionBreakIf(nullptr, ::std::move(from)) {}
  inline InstructionBreakIf& operator=(const InstructionBreakIf& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionBreakIf& operator=(InstructionBreakIf&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionBreakIf& default_instance() {
    return *reinterpret_cast<const InstructionBreakIf*>(
        &_InstructionBreakIf_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(InstructionBreakIf& a, InstructionBreakIf& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionBreakIf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionBreakIf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionBreakIf* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionBreakIf>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionBreakIf& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionBreakIf& from) { InstructionBreakIf::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionBreakIf* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionBreakIf"; }

 protected:
  explicit InstructionBreakIf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionBreakIf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionBreakIf& from);
  InstructionBreakIf(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionBreakIf&& from) noexcept
      : InstructionBreakIf(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumNextIterValuesFieldNumber = 1,
  };
  // uint32 num_next_iter_values = 1;
  void clear_num_next_iter_values() ;
  ::uint32_t num_next_iter_values() const;
  void set_num_next_iter_values(::uint32_t value);

  private:
  ::uint32_t _internal_num_next_iter_values() const;
  void _internal_set_num_next_iter_values(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionBreakIf)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionBreakIf& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t num_next_iter_values_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionBreakIf_class_data_;
// -------------------------------------------------------------------

class InstructionBitcast final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionBitcast) */ {
 public:
  inline InstructionBitcast() : InstructionBitcast(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionBitcast* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionBitcast));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionBitcast(::google::protobuf::internal::ConstantInitialized);

  inline InstructionBitcast(const InstructionBitcast& from) : InstructionBitcast(nullptr, from) {}
  inline InstructionBitcast(InstructionBitcast&& from) noexcept
      : InstructionBitcast(nullptr, ::std::move(from)) {}
  inline InstructionBitcast& operator=(const InstructionBitcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionBitcast& operator=(InstructionBitcast&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionBitcast& default_instance() {
    return *reinterpret_cast<const InstructionBitcast*>(
        &_InstructionBitcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(InstructionBitcast& a, InstructionBitcast& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionBitcast* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionBitcast* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionBitcast* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionBitcast>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionBitcast& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionBitcast& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionBitcast"; }

 protected:
  explicit InstructionBitcast(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionBitcast(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionBitcast& from);
  InstructionBitcast(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionBitcast&& from) noexcept
      : InstructionBitcast(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionBitcast)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionBitcast_class_data_;
// -------------------------------------------------------------------

class InstructionBinary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionBinary) */ {
 public:
  inline InstructionBinary() : InstructionBinary(nullptr) {}
  ~InstructionBinary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionBinary* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionBinary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionBinary(::google::protobuf::internal::ConstantInitialized);

  inline InstructionBinary(const InstructionBinary& from) : InstructionBinary(nullptr, from) {}
  inline InstructionBinary(InstructionBinary&& from) noexcept
      : InstructionBinary(nullptr, ::std::move(from)) {}
  inline InstructionBinary& operator=(const InstructionBinary& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionBinary& operator=(InstructionBinary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionBinary& default_instance() {
    return *reinterpret_cast<const InstructionBinary*>(
        &_InstructionBinary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(InstructionBinary& a, InstructionBinary& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionBinary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionBinary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionBinary* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionBinary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionBinary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionBinary& from) { InstructionBinary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionBinary* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionBinary"; }

 protected:
  explicit InstructionBinary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionBinary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionBinary& from);
  InstructionBinary(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionBinary&& from) noexcept
      : InstructionBinary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpFieldNumber = 1,
  };
  // .tint.core.ir.binary.pb.BinaryOp op = 1;
  void clear_op() ;
  ::tint::core::ir::binary::pb::BinaryOp op() const;
  void set_op(::tint::core::ir::binary::pb::BinaryOp value);

  private:
  ::tint::core::ir::binary::pb::BinaryOp _internal_op() const;
  void _internal_set_op(::tint::core::ir::binary::pb::BinaryOp value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionBinary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionBinary& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionBinary_class_data_;
// -------------------------------------------------------------------

class InstructionAccess final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionAccess) */ {
 public:
  inline InstructionAccess() : InstructionAccess(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionAccess* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionAccess));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionAccess(::google::protobuf::internal::ConstantInitialized);

  inline InstructionAccess(const InstructionAccess& from) : InstructionAccess(nullptr, from) {}
  inline InstructionAccess(InstructionAccess&& from) noexcept
      : InstructionAccess(nullptr, ::std::move(from)) {}
  inline InstructionAccess& operator=(const InstructionAccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionAccess& operator=(InstructionAccess&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionAccess& default_instance() {
    return *reinterpret_cast<const InstructionAccess*>(
        &_InstructionAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(InstructionAccess& a, InstructionAccess& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionAccess* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionAccess* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionAccess* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<InstructionAccess>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InstructionAccess& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InstructionAccess& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionAccess"; }

 protected:
  explicit InstructionAccess(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionAccess(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionAccess& from);
  InstructionAccess(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionAccess&& from) noexcept
      : InstructionAccess(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionAccess)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionAccess_class_data_;
// -------------------------------------------------------------------

class ConstantValueSplat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.ConstantValueSplat) */ {
 public:
  inline ConstantValueSplat() : ConstantValueSplat(nullptr) {}
  ~ConstantValueSplat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstantValueSplat* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstantValueSplat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstantValueSplat(::google::protobuf::internal::ConstantInitialized);

  inline ConstantValueSplat(const ConstantValueSplat& from) : ConstantValueSplat(nullptr, from) {}
  inline ConstantValueSplat(ConstantValueSplat&& from) noexcept
      : ConstantValueSplat(nullptr, ::std::move(from)) {}
  inline ConstantValueSplat& operator=(const ConstantValueSplat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantValueSplat& operator=(ConstantValueSplat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantValueSplat& default_instance() {
    return *reinterpret_cast<const ConstantValueSplat*>(
        &_ConstantValueSplat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(ConstantValueSplat& a, ConstantValueSplat& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(ConstantValueSplat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantValueSplat* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantValueSplat* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstantValueSplat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstantValueSplat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstantValueSplat& from) { ConstantValueSplat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstantValueSplat* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.ConstantValueSplat"; }

 protected:
  explicit ConstantValueSplat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConstantValueSplat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConstantValueSplat& from);
  ConstantValueSplat(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConstantValueSplat&& from) noexcept
      : ConstantValueSplat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kElementsFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // uint32 elements = 2;
  void clear_elements() ;
  ::uint32_t elements() const;
  void set_elements(::uint32_t value);

  private:
  ::uint32_t _internal_elements() const;
  void _internal_set_elements(::uint32_t value);

  public:
  // uint32 count = 3;
  void clear_count() ;
  ::uint32_t count() const;
  void set_count(::uint32_t value);

  private:
  ::uint32_t _internal_count() const;
  void _internal_set_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.ConstantValueSplat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConstantValueSplat& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t type_;
    ::uint32_t elements_;
    ::uint32_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConstantValueSplat_class_data_;
// -------------------------------------------------------------------

class ConstantValueScalar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.ConstantValueScalar) */ {
 public:
  inline ConstantValueScalar() : ConstantValueScalar(nullptr) {}
  ~ConstantValueScalar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstantValueScalar* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstantValueScalar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstantValueScalar(::google::protobuf::internal::ConstantInitialized);

  inline ConstantValueScalar(const ConstantValueScalar& from) : ConstantValueScalar(nullptr, from) {}
  inline ConstantValueScalar(ConstantValueScalar&& from) noexcept
      : ConstantValueScalar(nullptr, ::std::move(from)) {}
  inline ConstantValueScalar& operator=(const ConstantValueScalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantValueScalar& operator=(ConstantValueScalar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantValueScalar& default_instance() {
    return *reinterpret_cast<const ConstantValueScalar*>(
        &_ConstantValueScalar_default_instance_);
  }
  enum KindCase {
    kBool = 1,
    kI32 = 2,
    kU32 = 3,
    kF32 = 4,
    kF16 = 5,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(ConstantValueScalar& a, ConstantValueScalar& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(ConstantValueScalar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantValueScalar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantValueScalar* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstantValueScalar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstantValueScalar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstantValueScalar& from) { ConstantValueScalar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstantValueScalar* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.ConstantValueScalar"; }

 protected:
  explicit ConstantValueScalar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConstantValueScalar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConstantValueScalar& from);
  ConstantValueScalar(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConstantValueScalar&& from) noexcept
      : ConstantValueScalar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBoolFieldNumber = 1,
    kI32FieldNumber = 2,
    kU32FieldNumber = 3,
    kF32FieldNumber = 4,
    kF16FieldNumber = 5,
  };
  // bool bool = 1;
  bool has_bool_() const;
  void clear_bool_() ;
  bool bool_() const;
  void set_bool_(bool value);

  private:
  bool _internal_bool_() const;
  void _internal_set_bool_(bool value);

  public:
  // int32 i32 = 2;
  bool has_i32() const;
  void clear_i32() ;
  ::int32_t i32() const;
  void set_i32(::int32_t value);

  private:
  ::int32_t _internal_i32() const;
  void _internal_set_i32(::int32_t value);

  public:
  // uint32 u32 = 3;
  bool has_u32() const;
  void clear_u32() ;
  ::uint32_t u32() const;
  void set_u32(::uint32_t value);

  private:
  ::uint32_t _internal_u32() const;
  void _internal_set_u32(::uint32_t value);

  public:
  // float f32 = 4;
  bool has_f32() const;
  void clear_f32() ;
  float f32() const;
  void set_f32(float value);

  private:
  float _internal_f32() const;
  void _internal_set_f32(float value);

  public:
  // float f16 = 5;
  bool has_f16() const;
  void clear_f16() ;
  float f16() const;
  void set_f16(float value);

  private:
  float _internal_f16() const;
  void _internal_set_f16(float value);

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.ConstantValueScalar)
 private:
  class _Internal;
  void set_has_bool_();
  void set_has_i32();
  void set_has_u32();
  void set_has_f32();
  void set_has_f16();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConstantValueScalar& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool bool__;
      ::int32_t i32_;
      ::uint32_t u32_;
      float f32_;
      float f16_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConstantValueScalar_class_data_;
// -------------------------------------------------------------------

class ConstantValueComposite final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.ConstantValueComposite) */ {
 public:
  inline ConstantValueComposite() : ConstantValueComposite(nullptr) {}
  ~ConstantValueComposite() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstantValueComposite* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstantValueComposite));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstantValueComposite(::google::protobuf::internal::ConstantInitialized);

  inline ConstantValueComposite(const ConstantValueComposite& from) : ConstantValueComposite(nullptr, from) {}
  inline ConstantValueComposite(ConstantValueComposite&& from) noexcept
      : ConstantValueComposite(nullptr, ::std::move(from)) {}
  inline ConstantValueComposite& operator=(const ConstantValueComposite& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantValueComposite& operator=(ConstantValueComposite&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantValueComposite& default_instance() {
    return *reinterpret_cast<const ConstantValueComposite*>(
        &_ConstantValueComposite_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ConstantValueComposite& a, ConstantValueComposite& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(ConstantValueComposite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantValueComposite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantValueComposite* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstantValueComposite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstantValueComposite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstantValueComposite& from) { ConstantValueComposite::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstantValueComposite* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.ConstantValueComposite"; }

 protected:
  explicit ConstantValueComposite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConstantValueComposite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConstantValueComposite& from);
  ConstantValueComposite(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConstantValueComposite&& from) noexcept
      : ConstantValueComposite(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kElementsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated uint32 elements = 2;
  int elements_size() const;
  private:
  int _internal_elements_size() const;

  public:
  void clear_elements() ;
  ::uint32_t elements(int index) const;
  void set_elements(int index, ::uint32_t value);
  void add_elements(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& elements() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_elements();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_elements() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_elements();

  public:
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.ConstantValueComposite)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConstantValueComposite& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> elements_;
    ::google::protobuf::internal::CachedSize _elements_cached_byte_size_;
    ::uint32_t type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConstantValueComposite_class_data_;
// -------------------------------------------------------------------

class BlockParameter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.BlockParameter) */ {
 public:
  inline BlockParameter() : BlockParameter(nullptr) {}
  ~BlockParameter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockParameter* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockParameter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockParameter(::google::protobuf::internal::ConstantInitialized);

  inline BlockParameter(const BlockParameter& from) : BlockParameter(nullptr, from) {}
  inline BlockParameter(BlockParameter&& from) noexcept
      : BlockParameter(nullptr, ::std::move(from)) {}
  inline BlockParameter& operator=(const BlockParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockParameter& operator=(BlockParameter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockParameter& default_instance() {
    return *reinterpret_cast<const BlockParameter*>(
        &_BlockParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(BlockParameter& a, BlockParameter& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(BlockParameter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockParameter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockParameter* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockParameter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockParameter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockParameter& from) { BlockParameter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockParameter* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.BlockParameter"; }

 protected:
  explicit BlockParameter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BlockParameter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BlockParameter& from);
  BlockParameter(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BlockParameter&& from) noexcept
      : BlockParameter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.BlockParameter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 50,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BlockParameter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BlockParameter_class_data_;
// -------------------------------------------------------------------

class BindingPoint final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.BindingPoint) */ {
 public:
  inline BindingPoint() : BindingPoint(nullptr) {}
  ~BindingPoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BindingPoint* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BindingPoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BindingPoint(::google::protobuf::internal::ConstantInitialized);

  inline BindingPoint(const BindingPoint& from) : BindingPoint(nullptr, from) {}
  inline BindingPoint(BindingPoint&& from) noexcept
      : BindingPoint(nullptr, ::std::move(from)) {}
  inline BindingPoint& operator=(const BindingPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingPoint& operator=(BindingPoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindingPoint& default_instance() {
    return *reinterpret_cast<const BindingPoint*>(
        &_BindingPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(BindingPoint& a, BindingPoint& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(BindingPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingPoint* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindingPoint* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BindingPoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BindingPoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BindingPoint& from) { BindingPoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BindingPoint* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.BindingPoint"; }

 protected:
  explicit BindingPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BindingPoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BindingPoint& from);
  BindingPoint(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BindingPoint&& from) noexcept
      : BindingPoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupFieldNumber = 1,
    kBindingFieldNumber = 2,
  };
  // uint32 group = 1;
  void clear_group() ;
  ::uint32_t group() const;
  void set_group(::uint32_t value);

  private:
  ::uint32_t _internal_group() const;
  void _internal_set_group(::uint32_t value);

  public:
  // uint32 binding = 2;
  void clear_binding() ;
  ::uint32_t binding() const;
  void set_binding(::uint32_t value);

  private:
  ::uint32_t _internal_binding() const;
  void _internal_set_binding(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.BindingPoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BindingPoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t group_;
    ::uint32_t binding_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BindingPoint_class_data_;
// -------------------------------------------------------------------

class InstructionVar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionVar) */ {
 public:
  inline InstructionVar() : InstructionVar(nullptr) {}
  ~InstructionVar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionVar* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionVar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionVar(::google::protobuf::internal::ConstantInitialized);

  inline InstructionVar(const InstructionVar& from) : InstructionVar(nullptr, from) {}
  inline InstructionVar(InstructionVar&& from) noexcept
      : InstructionVar(nullptr, ::std::move(from)) {}
  inline InstructionVar& operator=(const InstructionVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionVar& operator=(InstructionVar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionVar& default_instance() {
    return *reinterpret_cast<const InstructionVar*>(
        &_InstructionVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(InstructionVar& a, InstructionVar& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionVar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionVar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionVar* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionVar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionVar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionVar& from) { InstructionVar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionVar* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionVar"; }

 protected:
  explicit InstructionVar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionVar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionVar& from);
  InstructionVar(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionVar&& from) noexcept
      : InstructionVar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBindingPointFieldNumber = 1,
    kInputAttachmentIndexFieldNumber = 2,
  };
  // optional .tint.core.ir.binary.pb.BindingPoint binding_point = 1;
  bool has_binding_point() const;
  void clear_binding_point() ;
  const ::tint::core::ir::binary::pb::BindingPoint& binding_point() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE release_binding_point();
  ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL mutable_binding_point();
  void set_allocated_binding_point(::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_binding_point(::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE unsafe_arena_release_binding_point();

  private:
  const ::tint::core::ir::binary::pb::BindingPoint& _internal_binding_point() const;
  ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL _internal_mutable_binding_point();

  public:
  // optional uint32 input_attachment_index = 2;
  bool has_input_attachment_index() const;
  void clear_input_attachment_index() ;
  ::uint32_t input_attachment_index() const;
  void set_input_attachment_index(::uint32_t value);

  private:
  ::uint32_t _internal_input_attachment_index() const;
  void _internal_set_input_attachment_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionVar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionVar& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE binding_point_;
    ::uint32_t input_attachment_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionVar_class_data_;
// -------------------------------------------------------------------

class InstructionSwitch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.InstructionSwitch) */ {
 public:
  inline InstructionSwitch() : InstructionSwitch(nullptr) {}
  ~InstructionSwitch() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstructionSwitch* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstructionSwitch));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstructionSwitch(::google::protobuf::internal::ConstantInitialized);

  inline InstructionSwitch(const InstructionSwitch& from) : InstructionSwitch(nullptr, from) {}
  inline InstructionSwitch(InstructionSwitch&& from) noexcept
      : InstructionSwitch(nullptr, ::std::move(from)) {}
  inline InstructionSwitch& operator=(const InstructionSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstructionSwitch& operator=(InstructionSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstructionSwitch& default_instance() {
    return *reinterpret_cast<const InstructionSwitch*>(
        &_InstructionSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(InstructionSwitch& a, InstructionSwitch& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(InstructionSwitch* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstructionSwitch* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstructionSwitch* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstructionSwitch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstructionSwitch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstructionSwitch& from) { InstructionSwitch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstructionSwitch* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.InstructionSwitch"; }

 protected:
  explicit InstructionSwitch(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InstructionSwitch(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InstructionSwitch& from);
  InstructionSwitch(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InstructionSwitch&& from) noexcept
      : InstructionSwitch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCasesFieldNumber = 1,
  };
  // repeated .tint.core.ir.binary.pb.SwitchCase cases = 1;
  int cases_size() const;
  private:
  int _internal_cases_size() const;

  public:
  void clear_cases() ;
  ::tint::core::ir::binary::pb::SwitchCase* PROTOBUF_NONNULL mutable_cases(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>* PROTOBUF_NONNULL mutable_cases();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>& _internal_cases() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>* PROTOBUF_NONNULL _internal_mutable_cases();
  public:
  const ::tint::core::ir::binary::pb::SwitchCase& cases(int index) const;
  ::tint::core::ir::binary::pb::SwitchCase* PROTOBUF_NONNULL add_cases();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>& cases() const;
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.InstructionSwitch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InstructionSwitch& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::SwitchCase > cases_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InstructionSwitch_class_data_;
// -------------------------------------------------------------------

class Function final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Function) */ {
 public:
  inline Function() : Function(nullptr) {}
  ~Function() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Function* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Function));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Function(::google::protobuf::internal::ConstantInitialized);

  inline Function(const Function& from) : Function(nullptr, from) {}
  inline Function(Function&& from) noexcept
      : Function(nullptr, ::std::move(from)) {}
  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  inline Function& operator=(Function&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Function& default_instance() {
    return *reinterpret_cast<const Function*>(
        &_Function_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(Function& a, Function& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Function* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Function* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Function* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Function>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Function& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Function& from) { Function::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Function* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Function"; }

 protected:
  explicit Function(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Function(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Function& from);
  Function(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Function&& from) noexcept
      : Function(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParametersFieldNumber = 6,
    kNameFieldNumber = 3,
    kWorkgroupSizeFieldNumber = 5,
    kReturnInterpolationFieldNumber = 8,
    kReturnTypeFieldNumber = 1,
    kBlockFieldNumber = 2,
    kPipelineStageFieldNumber = 4,
    kReturnLocationFieldNumber = 7,
    kReturnBuiltinFieldNumber = 9,
    kReturnInvariantFieldNumber = 10,
    kSubgroupSizeFieldNumber = 11,
  };
  // repeated uint32 parameters = 6;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  ::uint32_t parameters(int index) const;
  void set_parameters(int index, ::uint32_t value);
  void add_parameters(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& parameters() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_parameters();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_parameters() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_parameters();

  public:
  // optional string name = 3;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional .tint.core.ir.binary.pb.WorkgroupSize workgroup_size = 5;
  bool has_workgroup_size() const;
  void clear_workgroup_size() ;
  const ::tint::core::ir::binary::pb::WorkgroupSize& workgroup_size() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE release_workgroup_size();
  ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NONNULL mutable_workgroup_size();
  void set_allocated_workgroup_size(::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_workgroup_size(::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE unsafe_arena_release_workgroup_size();

  private:
  const ::tint::core::ir::binary::pb::WorkgroupSize& _internal_workgroup_size() const;
  ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NONNULL _internal_mutable_workgroup_size();

  public:
  // optional .tint.core.ir.binary.pb.Interpolation return_interpolation = 8;
  bool has_return_interpolation() const;
  void clear_return_interpolation() ;
  const ::tint::core::ir::binary::pb::Interpolation& return_interpolation() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE release_return_interpolation();
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL mutable_return_interpolation();
  void set_allocated_return_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_return_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE unsafe_arena_release_return_interpolation();

  private:
  const ::tint::core::ir::binary::pb::Interpolation& _internal_return_interpolation() const;
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL _internal_mutable_return_interpolation();

  public:
  // uint32 return_type = 1;
  void clear_return_type() ;
  ::uint32_t return_type() const;
  void set_return_type(::uint32_t value);

  private:
  ::uint32_t _internal_return_type() const;
  void _internal_set_return_type(::uint32_t value);

  public:
  // uint32 block = 2;
  void clear_block() ;
  ::uint32_t block() const;
  void set_block(::uint32_t value);

  private:
  ::uint32_t _internal_block() const;
  void _internal_set_block(::uint32_t value);

  public:
  // optional .tint.core.ir.binary.pb.PipelineStage pipeline_stage = 4;
  bool has_pipeline_stage() const;
  void clear_pipeline_stage() ;
  ::tint::core::ir::binary::pb::PipelineStage pipeline_stage() const;
  void set_pipeline_stage(::tint::core::ir::binary::pb::PipelineStage value);

  private:
  ::tint::core::ir::binary::pb::PipelineStage _internal_pipeline_stage() const;
  void _internal_set_pipeline_stage(::tint::core::ir::binary::pb::PipelineStage value);

  public:
  // optional uint32 return_location = 7;
  bool has_return_location() const;
  void clear_return_location() ;
  ::uint32_t return_location() const;
  void set_return_location(::uint32_t value);

  private:
  ::uint32_t _internal_return_location() const;
  void _internal_set_return_location(::uint32_t value);

  public:
  // optional .tint.core.ir.binary.pb.BuiltinValue return_builtin = 9;
  bool has_return_builtin() const;
  void clear_return_builtin() ;
  ::tint::core::ir::binary::pb::BuiltinValue return_builtin() const;
  void set_return_builtin(::tint::core::ir::binary::pb::BuiltinValue value);

  private:
  ::tint::core::ir::binary::pb::BuiltinValue _internal_return_builtin() const;
  void _internal_set_return_builtin(::tint::core::ir::binary::pb::BuiltinValue value);

  public:
  // bool return_invariant = 10;
  void clear_return_invariant() ;
  bool return_invariant() const;
  void set_return_invariant(bool value);

  private:
  bool _internal_return_invariant() const;
  void _internal_set_return_invariant(bool value);

  public:
  // optional uint32 subgroup_size = 11;
  bool has_subgroup_size() const;
  void clear_subgroup_size() ;
  ::uint32_t subgroup_size() const;
  void set_subgroup_size(::uint32_t value);

  private:
  ::uint32_t _internal_subgroup_size() const;
  void _internal_set_subgroup_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Function)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   2, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Function& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> parameters_;
    ::google::protobuf::internal::CachedSize _parameters_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE workgroup_size_;
    ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE return_interpolation_;
    ::uint32_t return_type_;
    ::uint32_t block_;
    int pipeline_stage_;
    ::uint32_t return_location_;
    int return_builtin_;
    bool return_invariant_;
    ::uint32_t subgroup_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Function_class_data_;
// -------------------------------------------------------------------

class ConstantValue final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.ConstantValue) */ {
 public:
  inline ConstantValue() : ConstantValue(nullptr) {}
  ~ConstantValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstantValue* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstantValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstantValue(::google::protobuf::internal::ConstantInitialized);

  inline ConstantValue(const ConstantValue& from) : ConstantValue(nullptr, from) {}
  inline ConstantValue(ConstantValue&& from) noexcept
      : ConstantValue(nullptr, ::std::move(from)) {}
  inline ConstantValue& operator=(const ConstantValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantValue& operator=(ConstantValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantValue& default_instance() {
    return *reinterpret_cast<const ConstantValue*>(
        &_ConstantValue_default_instance_);
  }
  enum KindCase {
    kScalar = 1,
    kComposite = 2,
    kSplat = 3,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(ConstantValue& a, ConstantValue& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(ConstantValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantValue* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantValue* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstantValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstantValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstantValue& from) { ConstantValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstantValue* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.ConstantValue"; }

 protected:
  explicit ConstantValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConstantValue(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConstantValue& from);
  ConstantValue(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConstantValue&& from) noexcept
      : ConstantValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScalarFieldNumber = 1,
    kCompositeFieldNumber = 2,
    kSplatFieldNumber = 3,
  };
  // .tint.core.ir.binary.pb.ConstantValueScalar scalar = 1;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;

  public:
  void clear_scalar() ;
  const ::tint::core::ir::binary::pb::ConstantValueScalar& scalar() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE release_scalar();
  ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NONNULL mutable_scalar();
  void set_allocated_scalar(::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_scalar(::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE unsafe_arena_release_scalar();

  private:
  const ::tint::core::ir::binary::pb::ConstantValueScalar& _internal_scalar() const;
  ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NONNULL _internal_mutable_scalar();

  public:
  // .tint.core.ir.binary.pb.ConstantValueComposite composite = 2;
  bool has_composite() const;
  private:
  bool _internal_has_composite() const;

  public:
  void clear_composite() ;
  const ::tint::core::ir::binary::pb::ConstantValueComposite& composite() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE release_composite();
  ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NONNULL mutable_composite();
  void set_allocated_composite(::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_composite(::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE unsafe_arena_release_composite();

  private:
  const ::tint::core::ir::binary::pb::ConstantValueComposite& _internal_composite() const;
  ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NONNULL _internal_mutable_composite();

  public:
  // .tint.core.ir.binary.pb.ConstantValueSplat splat = 3;
  bool has_splat() const;
  private:
  bool _internal_has_splat() const;

  public:
  void clear_splat() ;
  const ::tint::core::ir::binary::pb::ConstantValueSplat& splat() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE release_splat();
  ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NONNULL mutable_splat();
  void set_allocated_splat(::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_splat(::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE unsafe_arena_release_splat();

  private:
  const ::tint::core::ir::binary::pb::ConstantValueSplat& _internal_splat() const;
  ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NONNULL _internal_mutable_splat();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.ConstantValue)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_composite();
  void set_has_splat();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConstantValue& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE scalar_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE composite_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE splat_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConstantValue_class_data_;
// -------------------------------------------------------------------

class AttributesStructMember final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.AttributesStructMember) */ {
 public:
  inline AttributesStructMember() : AttributesStructMember(nullptr) {}
  ~AttributesStructMember() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttributesStructMember* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttributesStructMember));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttributesStructMember(::google::protobuf::internal::ConstantInitialized);

  inline AttributesStructMember(const AttributesStructMember& from) : AttributesStructMember(nullptr, from) {}
  inline AttributesStructMember(AttributesStructMember&& from) noexcept
      : AttributesStructMember(nullptr, ::std::move(from)) {}
  inline AttributesStructMember& operator=(const AttributesStructMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributesStructMember& operator=(AttributesStructMember&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributesStructMember& default_instance() {
    return *reinterpret_cast<const AttributesStructMember*>(
        &_AttributesStructMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 63;
  friend void swap(AttributesStructMember& a, AttributesStructMember& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(AttributesStructMember* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributesStructMember* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributesStructMember* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttributesStructMember>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttributesStructMember& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttributesStructMember& from) { AttributesStructMember::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttributesStructMember* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.AttributesStructMember"; }

 protected:
  explicit AttributesStructMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttributesStructMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttributesStructMember& from);
  AttributesStructMember(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttributesStructMember&& from) noexcept
      : AttributesStructMember(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInterpolationFieldNumber = 5,
    kLocationFieldNumber = 1,
    kBlendSrcFieldNumber = 2,
    kColorFieldNumber = 3,
    kBuiltinFieldNumber = 4,
    kInvariantFieldNumber = 6,
  };
  // optional .tint.core.ir.binary.pb.Interpolation interpolation = 5;
  bool has_interpolation() const;
  void clear_interpolation() ;
  const ::tint::core::ir::binary::pb::Interpolation& interpolation() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE release_interpolation();
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL mutable_interpolation();
  void set_allocated_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE unsafe_arena_release_interpolation();

  private:
  const ::tint::core::ir::binary::pb::Interpolation& _internal_interpolation() const;
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL _internal_mutable_interpolation();

  public:
  // optional uint32 location = 1;
  bool has_location() const;
  void clear_location() ;
  ::uint32_t location() const;
  void set_location(::uint32_t value);

  private:
  ::uint32_t _internal_location() const;
  void _internal_set_location(::uint32_t value);

  public:
  // optional uint32 blend_src = 2;
  bool has_blend_src() const;
  void clear_blend_src() ;
  ::uint32_t blend_src() const;
  void set_blend_src(::uint32_t value);

  private:
  ::uint32_t _internal_blend_src() const;
  void _internal_set_blend_src(::uint32_t value);

  public:
  // optional uint32 color = 3;
  bool has_color() const;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // optional .tint.core.ir.binary.pb.BuiltinValue builtin = 4;
  bool has_builtin() const;
  void clear_builtin() ;
  ::tint::core::ir::binary::pb::BuiltinValue builtin() const;
  void set_builtin(::tint::core::ir::binary::pb::BuiltinValue value);

  private:
  ::tint::core::ir::binary::pb::BuiltinValue _internal_builtin() const;
  void _internal_set_builtin(::tint::core::ir::binary::pb::BuiltinValue value);

  public:
  // bool invariant = 6;
  void clear_invariant() ;
  bool invariant() const;
  void set_invariant(bool value);

  private:
  bool _internal_invariant() const;
  void _internal_set_invariant(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.AttributesStructMember)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttributesStructMember& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE interpolation_;
    ::uint32_t location_;
    ::uint32_t blend_src_;
    ::uint32_t color_;
    int builtin_;
    bool invariant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttributesStructMember_class_data_;
// -------------------------------------------------------------------

class AttributesFunctionParameter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.AttributesFunctionParameter) */ {
 public:
  inline AttributesFunctionParameter() : AttributesFunctionParameter(nullptr) {}
  ~AttributesFunctionParameter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttributesFunctionParameter* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttributesFunctionParameter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttributesFunctionParameter(::google::protobuf::internal::ConstantInitialized);

  inline AttributesFunctionParameter(const AttributesFunctionParameter& from) : AttributesFunctionParameter(nullptr, from) {}
  inline AttributesFunctionParameter(AttributesFunctionParameter&& from) noexcept
      : AttributesFunctionParameter(nullptr, ::std::move(from)) {}
  inline AttributesFunctionParameter& operator=(const AttributesFunctionParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributesFunctionParameter& operator=(AttributesFunctionParameter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributesFunctionParameter& default_instance() {
    return *reinterpret_cast<const AttributesFunctionParameter*>(
        &_AttributesFunctionParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(AttributesFunctionParameter& a, AttributesFunctionParameter& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(AttributesFunctionParameter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributesFunctionParameter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributesFunctionParameter* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AttributesFunctionParameter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttributesFunctionParameter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AttributesFunctionParameter& from) { AttributesFunctionParameter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttributesFunctionParameter* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.AttributesFunctionParameter"; }

 protected:
  explicit AttributesFunctionParameter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AttributesFunctionParameter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AttributesFunctionParameter& from);
  AttributesFunctionParameter(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AttributesFunctionParameter&& from) noexcept
      : AttributesFunctionParameter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInterpolationFieldNumber = 4,
    kBindingPointFieldNumber = 5,
    kBuiltinFieldNumber = 1,
    kLocationFieldNumber = 2,
    kColorFieldNumber = 3,
    kInvariantFieldNumber = 6,
  };
  // optional .tint.core.ir.binary.pb.Interpolation interpolation = 4;
  bool has_interpolation() const;
  void clear_interpolation() ;
  const ::tint::core::ir::binary::pb::Interpolation& interpolation() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE release_interpolation();
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL mutable_interpolation();
  void set_allocated_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE unsafe_arena_release_interpolation();

  private:
  const ::tint::core::ir::binary::pb::Interpolation& _internal_interpolation() const;
  ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL _internal_mutable_interpolation();

  public:
  // optional .tint.core.ir.binary.pb.BindingPoint binding_point = 5;
  bool has_binding_point() const;
  void clear_binding_point() ;
  const ::tint::core::ir::binary::pb::BindingPoint& binding_point() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE release_binding_point();
  ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL mutable_binding_point();
  void set_allocated_binding_point(::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_binding_point(::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE unsafe_arena_release_binding_point();

  private:
  const ::tint::core::ir::binary::pb::BindingPoint& _internal_binding_point() const;
  ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL _internal_mutable_binding_point();

  public:
  // optional .tint.core.ir.binary.pb.BuiltinValue builtin = 1;
  bool has_builtin() const;
  void clear_builtin() ;
  ::tint::core::ir::binary::pb::BuiltinValue builtin() const;
  void set_builtin(::tint::core::ir::binary::pb::BuiltinValue value);

  private:
  ::tint::core::ir::binary::pb::BuiltinValue _internal_builtin() const;
  void _internal_set_builtin(::tint::core::ir::binary::pb::BuiltinValue value);

  public:
  // optional uint32 location = 2;
  bool has_location() const;
  void clear_location() ;
  ::uint32_t location() const;
  void set_location(::uint32_t value);

  private:
  ::uint32_t _internal_location() const;
  void _internal_set_location(::uint32_t value);

  public:
  // optional uint32 color = 3;
  bool has_color() const;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // bool invariant = 6;
  void clear_invariant() ;
  bool invariant() const;
  void set_invariant(bool value);

  private:
  bool _internal_invariant() const;
  void _internal_set_invariant(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.AttributesFunctionParameter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AttributesFunctionParameter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE interpolation_;
    ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE binding_point_;
    int builtin_;
    ::uint32_t location_;
    ::uint32_t color_;
    bool invariant_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AttributesFunctionParameter_class_data_;
// -------------------------------------------------------------------

class TypeStructMember final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeStructMember) */ {
 public:
  inline TypeStructMember() : TypeStructMember(nullptr) {}
  ~TypeStructMember() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeStructMember* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeStructMember));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeStructMember(::google::protobuf::internal::ConstantInitialized);

  inline TypeStructMember(const TypeStructMember& from) : TypeStructMember(nullptr, from) {}
  inline TypeStructMember(TypeStructMember&& from) noexcept
      : TypeStructMember(nullptr, ::std::move(from)) {}
  inline TypeStructMember& operator=(const TypeStructMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeStructMember& operator=(TypeStructMember&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeStructMember& default_instance() {
    return *reinterpret_cast<const TypeStructMember*>(
        &_TypeStructMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(TypeStructMember& a, TypeStructMember& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeStructMember* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeStructMember* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeStructMember* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeStructMember>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeStructMember& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeStructMember& from) { TypeStructMember::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeStructMember* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeStructMember"; }

 protected:
  explicit TypeStructMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeStructMember(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeStructMember& from);
  TypeStructMember(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeStructMember&& from) noexcept
      : TypeStructMember(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kAttributesFieldNumber = 5,
    kTypeFieldNumber = 2,
    kSizeFieldNumber = 3,
    kAlignFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional .tint.core.ir.binary.pb.AttributesStructMember attributes = 5;
  bool has_attributes() const;
  void clear_attributes() ;
  const ::tint::core::ir::binary::pb::AttributesStructMember& attributes() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE release_attributes();
  ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NONNULL mutable_attributes();
  void set_allocated_attributes(::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_attributes(::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE unsafe_arena_release_attributes();

  private:
  const ::tint::core::ir::binary::pb::AttributesStructMember& _internal_attributes() const;
  ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NONNULL _internal_mutable_attributes();

  public:
  // uint32 type = 2;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // uint32 size = 3;
  void clear_size() ;
  ::uint32_t size() const;
  void set_size(::uint32_t value);

  private:
  ::uint32_t _internal_size() const;
  void _internal_set_size(::uint32_t value);

  public:
  // uint32 align = 4;
  void clear_align() ;
  ::uint32_t align() const;
  void set_align(::uint32_t value);

  private:
  ::uint32_t _internal_align() const;
  void _internal_set_align(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeStructMember)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   1, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeStructMember& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE attributes_;
    ::uint32_t type_;
    ::uint32_t size_;
    ::uint32_t align_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeStructMember_class_data_;
// -------------------------------------------------------------------

class Instruction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Instruction) */ {
 public:
  inline Instruction() : Instruction(nullptr) {}
  ~Instruction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Instruction* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Instruction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Instruction(::google::protobuf::internal::ConstantInitialized);

  inline Instruction(const Instruction& from) : Instruction(nullptr, from) {}
  inline Instruction(Instruction&& from) noexcept
      : Instruction(nullptr, ::std::move(from)) {}
  inline Instruction& operator=(const Instruction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instruction& operator=(Instruction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instruction& default_instance() {
    return *reinterpret_cast<const Instruction*>(
        &_Instruction_default_instance_);
  }
  enum KindCase {
    kReturn = 3,
    kUnary = 4,
    kBinary = 5,
    kDiscard = 6,
    kLet = 7,
    kVar = 8,
    kBitcast = 9,
    kConstruct = 10,
    kConvert = 11,
    kAccess = 12,
    kUserCall = 13,
    kBuiltinCall = 14,
    kLoad = 15,
    kStore = 16,
    kLoadVectorElement = 17,
    kStoreVectorElement = 18,
    kSwizzle = 19,
    kIf = 20,
    kSwitch = 21,
    kLoop = 22,
    kExitIf = 23,
    kExitSwitch = 24,
    kExitLoop = 25,
    kNextIteration = 26,
    kContinue = 27,
    kBreakIf = 28,
    kUnreachable = 29,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(Instruction& a, Instruction& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Instruction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instruction* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instruction* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Instruction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Instruction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Instruction& from) { Instruction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Instruction* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Instruction"; }

 protected:
  explicit Instruction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Instruction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Instruction& from);
  Instruction(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Instruction&& from) noexcept
      : Instruction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOperandsFieldNumber = 1,
    kResultsFieldNumber = 2,
    kReturnFieldNumber = 3,
    kUnaryFieldNumber = 4,
    kBinaryFieldNumber = 5,
    kDiscardFieldNumber = 6,
    kLetFieldNumber = 7,
    kVarFieldNumber = 8,
    kBitcastFieldNumber = 9,
    kConstructFieldNumber = 10,
    kConvertFieldNumber = 11,
    kAccessFieldNumber = 12,
    kUserCallFieldNumber = 13,
    kBuiltinCallFieldNumber = 14,
    kLoadFieldNumber = 15,
    kStoreFieldNumber = 16,
    kLoadVectorElementFieldNumber = 17,
    kStoreVectorElementFieldNumber = 18,
    kSwizzleFieldNumber = 19,
    kIfFieldNumber = 20,
    kSwitchFieldNumber = 21,
    kLoopFieldNumber = 22,
    kExitIfFieldNumber = 23,
    kExitSwitchFieldNumber = 24,
    kExitLoopFieldNumber = 25,
    kNextIterationFieldNumber = 26,
    kContinueFieldNumber = 27,
    kBreakIfFieldNumber = 28,
    kUnreachableFieldNumber = 29,
  };
  // repeated uint32 operands = 1;
  int operands_size() const;
  private:
  int _internal_operands_size() const;

  public:
  void clear_operands() ;
  ::uint32_t operands(int index) const;
  void set_operands(int index, ::uint32_t value);
  void add_operands(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& operands() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_operands();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_operands() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_operands();

  public:
  // repeated uint32 results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  ::uint32_t results(int index) const;
  void set_results(int index, ::uint32_t value);
  void add_results(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& results() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_results();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_results() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_results();

  public:
  // .tint.core.ir.binary.pb.InstructionReturn return = 3;
  bool has_return_() const;
  private:
  bool _internal_has_return_() const;

  public:
  void clear_return_() ;
  const ::tint::core::ir::binary::pb::InstructionReturn& return_() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE release_return_();
  ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NONNULL mutable_return_();
  void set_allocated_return_(::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_return_(::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE unsafe_arena_release_return_();

  private:
  const ::tint::core::ir::binary::pb::InstructionReturn& _internal_return_() const;
  ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NONNULL _internal_mutable_return_();

  public:
  // .tint.core.ir.binary.pb.InstructionUnary unary = 4;
  bool has_unary() const;
  private:
  bool _internal_has_unary() const;

  public:
  void clear_unary() ;
  const ::tint::core::ir::binary::pb::InstructionUnary& unary() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE release_unary();
  ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NONNULL mutable_unary();
  void set_allocated_unary(::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_unary(::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE unsafe_arena_release_unary();

  private:
  const ::tint::core::ir::binary::pb::InstructionUnary& _internal_unary() const;
  ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NONNULL _internal_mutable_unary();

  public:
  // .tint.core.ir.binary.pb.InstructionBinary binary = 5;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::tint::core::ir::binary::pb::InstructionBinary& binary() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE release_binary();
  ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NONNULL mutable_binary();
  void set_allocated_binary(::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_binary(::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE unsafe_arena_release_binary();

  private:
  const ::tint::core::ir::binary::pb::InstructionBinary& _internal_binary() const;
  ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NONNULL _internal_mutable_binary();

  public:
  // .tint.core.ir.binary.pb.InstructionDiscard discard = 6;
  bool has_discard() const;
  private:
  bool _internal_has_discard() const;

  public:
  void clear_discard() ;
  const ::tint::core::ir::binary::pb::InstructionDiscard& discard() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE release_discard();
  ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NONNULL mutable_discard();
  void set_allocated_discard(::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_discard(::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE unsafe_arena_release_discard();

  private:
  const ::tint::core::ir::binary::pb::InstructionDiscard& _internal_discard() const;
  ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NONNULL _internal_mutable_discard();

  public:
  // .tint.core.ir.binary.pb.InstructionLet let = 7;
  bool has_let() const;
  private:
  bool _internal_has_let() const;

  public:
  void clear_let() ;
  const ::tint::core::ir::binary::pb::InstructionLet& let() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE release_let();
  ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NONNULL mutable_let();
  void set_allocated_let(::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_let(::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE unsafe_arena_release_let();

  private:
  const ::tint::core::ir::binary::pb::InstructionLet& _internal_let() const;
  ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NONNULL _internal_mutable_let();

  public:
  // .tint.core.ir.binary.pb.InstructionVar var = 8;
  bool has_var() const;
  private:
  bool _internal_has_var() const;

  public:
  void clear_var() ;
  const ::tint::core::ir::binary::pb::InstructionVar& var() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE release_var();
  ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NONNULL mutable_var();
  void set_allocated_var(::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_var(::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE unsafe_arena_release_var();

  private:
  const ::tint::core::ir::binary::pb::InstructionVar& _internal_var() const;
  ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NONNULL _internal_mutable_var();

  public:
  // .tint.core.ir.binary.pb.InstructionBitcast bitcast = 9;
  bool has_bitcast() const;
  private:
  bool _internal_has_bitcast() const;

  public:
  void clear_bitcast() ;
  const ::tint::core::ir::binary::pb::InstructionBitcast& bitcast() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE release_bitcast();
  ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NONNULL mutable_bitcast();
  void set_allocated_bitcast(::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bitcast(::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE unsafe_arena_release_bitcast();

  private:
  const ::tint::core::ir::binary::pb::InstructionBitcast& _internal_bitcast() const;
  ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NONNULL _internal_mutable_bitcast();

  public:
  // .tint.core.ir.binary.pb.InstructionConstruct construct = 10;
  bool has_construct() const;
  private:
  bool _internal_has_construct() const;

  public:
  void clear_construct() ;
  const ::tint::core::ir::binary::pb::InstructionConstruct& construct() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE release_construct();
  ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NONNULL mutable_construct();
  void set_allocated_construct(::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_construct(::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE unsafe_arena_release_construct();

  private:
  const ::tint::core::ir::binary::pb::InstructionConstruct& _internal_construct() const;
  ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NONNULL _internal_mutable_construct();

  public:
  // .tint.core.ir.binary.pb.InstructionConvert convert = 11;
  bool has_convert() const;
  private:
  bool _internal_has_convert() const;

  public:
  void clear_convert() ;
  const ::tint::core::ir::binary::pb::InstructionConvert& convert() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE release_convert();
  ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NONNULL mutable_convert();
  void set_allocated_convert(::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_convert(::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE unsafe_arena_release_convert();

  private:
  const ::tint::core::ir::binary::pb::InstructionConvert& _internal_convert() const;
  ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NONNULL _internal_mutable_convert();

  public:
  // .tint.core.ir.binary.pb.InstructionAccess access = 12;
  bool has_access() const;
  private:
  bool _internal_has_access() const;

  public:
  void clear_access() ;
  const ::tint::core::ir::binary::pb::InstructionAccess& access() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE release_access();
  ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NONNULL mutable_access();
  void set_allocated_access(::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_access(::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE unsafe_arena_release_access();

  private:
  const ::tint::core::ir::binary::pb::InstructionAccess& _internal_access() const;
  ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NONNULL _internal_mutable_access();

  public:
  // .tint.core.ir.binary.pb.InstructionUserCall user_call = 13;
  bool has_user_call() const;
  private:
  bool _internal_has_user_call() const;

  public:
  void clear_user_call() ;
  const ::tint::core::ir::binary::pb::InstructionUserCall& user_call() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE release_user_call();
  ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NONNULL mutable_user_call();
  void set_allocated_user_call(::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_user_call(::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE unsafe_arena_release_user_call();

  private:
  const ::tint::core::ir::binary::pb::InstructionUserCall& _internal_user_call() const;
  ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NONNULL _internal_mutable_user_call();

  public:
  // .tint.core.ir.binary.pb.InstructionBuiltinCall builtin_call = 14;
  bool has_builtin_call() const;
  private:
  bool _internal_has_builtin_call() const;

  public:
  void clear_builtin_call() ;
  const ::tint::core::ir::binary::pb::InstructionBuiltinCall& builtin_call() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE release_builtin_call();
  ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NONNULL mutable_builtin_call();
  void set_allocated_builtin_call(::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_builtin_call(::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE unsafe_arena_release_builtin_call();

  private:
  const ::tint::core::ir::binary::pb::InstructionBuiltinCall& _internal_builtin_call() const;
  ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NONNULL _internal_mutable_builtin_call();

  public:
  // .tint.core.ir.binary.pb.InstructionLoad load = 15;
  bool has_load() const;
  private:
  bool _internal_has_load() const;

  public:
  void clear_load() ;
  const ::tint::core::ir::binary::pb::InstructionLoad& load() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE release_load();
  ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NONNULL mutable_load();
  void set_allocated_load(::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_load(::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE unsafe_arena_release_load();

  private:
  const ::tint::core::ir::binary::pb::InstructionLoad& _internal_load() const;
  ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NONNULL _internal_mutable_load();

  public:
  // .tint.core.ir.binary.pb.InstructionStore store = 16;
  bool has_store() const;
  private:
  bool _internal_has_store() const;

  public:
  void clear_store() ;
  const ::tint::core::ir::binary::pb::InstructionStore& store() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE release_store();
  ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NONNULL mutable_store();
  void set_allocated_store(::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_store(::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE unsafe_arena_release_store();

  private:
  const ::tint::core::ir::binary::pb::InstructionStore& _internal_store() const;
  ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NONNULL _internal_mutable_store();

  public:
  // .tint.core.ir.binary.pb.InstructionLoadVectorElement load_vector_element = 17;
  bool has_load_vector_element() const;
  private:
  bool _internal_has_load_vector_element() const;

  public:
  void clear_load_vector_element() ;
  const ::tint::core::ir::binary::pb::InstructionLoadVectorElement& load_vector_element() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE release_load_vector_element();
  ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NONNULL mutable_load_vector_element();
  void set_allocated_load_vector_element(::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_load_vector_element(::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE unsafe_arena_release_load_vector_element();

  private:
  const ::tint::core::ir::binary::pb::InstructionLoadVectorElement& _internal_load_vector_element() const;
  ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NONNULL _internal_mutable_load_vector_element();

  public:
  // .tint.core.ir.binary.pb.InstructionStoreVectorElement store_vector_element = 18;
  bool has_store_vector_element() const;
  private:
  bool _internal_has_store_vector_element() const;

  public:
  void clear_store_vector_element() ;
  const ::tint::core::ir::binary::pb::InstructionStoreVectorElement& store_vector_element() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE release_store_vector_element();
  ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NONNULL mutable_store_vector_element();
  void set_allocated_store_vector_element(::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_store_vector_element(::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE unsafe_arena_release_store_vector_element();

  private:
  const ::tint::core::ir::binary::pb::InstructionStoreVectorElement& _internal_store_vector_element() const;
  ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NONNULL _internal_mutable_store_vector_element();

  public:
  // .tint.core.ir.binary.pb.InstructionSwizzle swizzle = 19;
  bool has_swizzle() const;
  private:
  bool _internal_has_swizzle() const;

  public:
  void clear_swizzle() ;
  const ::tint::core::ir::binary::pb::InstructionSwizzle& swizzle() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE release_swizzle();
  ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NONNULL mutable_swizzle();
  void set_allocated_swizzle(::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_swizzle(::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE unsafe_arena_release_swizzle();

  private:
  const ::tint::core::ir::binary::pb::InstructionSwizzle& _internal_swizzle() const;
  ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NONNULL _internal_mutable_swizzle();

  public:
  // .tint.core.ir.binary.pb.InstructionIf if = 20;
  bool has_if_() const;
  private:
  bool _internal_has_if_() const;

  public:
  void clear_if_() ;
  const ::tint::core::ir::binary::pb::InstructionIf& if_() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE release_if_();
  ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NONNULL mutable_if_();
  void set_allocated_if_(::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_if_(::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE unsafe_arena_release_if_();

  private:
  const ::tint::core::ir::binary::pb::InstructionIf& _internal_if_() const;
  ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NONNULL _internal_mutable_if_();

  public:
  // .tint.core.ir.binary.pb.InstructionSwitch switch = 21;
  bool has_switch_() const;
  private:
  bool _internal_has_switch_() const;

  public:
  void clear_switch_() ;
  const ::tint::core::ir::binary::pb::InstructionSwitch& switch_() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE release_switch_();
  ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NONNULL mutable_switch_();
  void set_allocated_switch_(::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_switch_(::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE unsafe_arena_release_switch_();

  private:
  const ::tint::core::ir::binary::pb::InstructionSwitch& _internal_switch_() const;
  ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NONNULL _internal_mutable_switch_();

  public:
  // .tint.core.ir.binary.pb.InstructionLoop loop = 22;
  bool has_loop() const;
  private:
  bool _internal_has_loop() const;

  public:
  void clear_loop() ;
  const ::tint::core::ir::binary::pb::InstructionLoop& loop() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE release_loop();
  ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NONNULL mutable_loop();
  void set_allocated_loop(::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_loop(::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE unsafe_arena_release_loop();

  private:
  const ::tint::core::ir::binary::pb::InstructionLoop& _internal_loop() const;
  ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NONNULL _internal_mutable_loop();

  public:
  // .tint.core.ir.binary.pb.InstructionExitIf exit_if = 23;
  bool has_exit_if() const;
  private:
  bool _internal_has_exit_if() const;

  public:
  void clear_exit_if() ;
  const ::tint::core::ir::binary::pb::InstructionExitIf& exit_if() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE release_exit_if();
  ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NONNULL mutable_exit_if();
  void set_allocated_exit_if(::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exit_if(::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE unsafe_arena_release_exit_if();

  private:
  const ::tint::core::ir::binary::pb::InstructionExitIf& _internal_exit_if() const;
  ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NONNULL _internal_mutable_exit_if();

  public:
  // .tint.core.ir.binary.pb.InstructionExitSwitch exit_switch = 24;
  bool has_exit_switch() const;
  private:
  bool _internal_has_exit_switch() const;

  public:
  void clear_exit_switch() ;
  const ::tint::core::ir::binary::pb::InstructionExitSwitch& exit_switch() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE release_exit_switch();
  ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NONNULL mutable_exit_switch();
  void set_allocated_exit_switch(::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exit_switch(::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE unsafe_arena_release_exit_switch();

  private:
  const ::tint::core::ir::binary::pb::InstructionExitSwitch& _internal_exit_switch() const;
  ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NONNULL _internal_mutable_exit_switch();

  public:
  // .tint.core.ir.binary.pb.InstructionExitLoop exit_loop = 25;
  bool has_exit_loop() const;
  private:
  bool _internal_has_exit_loop() const;

  public:
  void clear_exit_loop() ;
  const ::tint::core::ir::binary::pb::InstructionExitLoop& exit_loop() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE release_exit_loop();
  ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NONNULL mutable_exit_loop();
  void set_allocated_exit_loop(::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exit_loop(::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE unsafe_arena_release_exit_loop();

  private:
  const ::tint::core::ir::binary::pb::InstructionExitLoop& _internal_exit_loop() const;
  ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NONNULL _internal_mutable_exit_loop();

  public:
  // .tint.core.ir.binary.pb.InstructionNextIteration next_iteration = 26;
  bool has_next_iteration() const;
  private:
  bool _internal_has_next_iteration() const;

  public:
  void clear_next_iteration() ;
  const ::tint::core::ir::binary::pb::InstructionNextIteration& next_iteration() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE release_next_iteration();
  ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NONNULL mutable_next_iteration();
  void set_allocated_next_iteration(::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_next_iteration(::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE unsafe_arena_release_next_iteration();

  private:
  const ::tint::core::ir::binary::pb::InstructionNextIteration& _internal_next_iteration() const;
  ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NONNULL _internal_mutable_next_iteration();

  public:
  // .tint.core.ir.binary.pb.InstructionContinue continue = 27;
  bool has_continue_() const;
  private:
  bool _internal_has_continue_() const;

  public:
  void clear_continue_() ;
  const ::tint::core::ir::binary::pb::InstructionContinue& continue_() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE release_continue_();
  ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NONNULL mutable_continue_();
  void set_allocated_continue_(::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_continue_(::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE unsafe_arena_release_continue_();

  private:
  const ::tint::core::ir::binary::pb::InstructionContinue& _internal_continue_() const;
  ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NONNULL _internal_mutable_continue_();

  public:
  // .tint.core.ir.binary.pb.InstructionBreakIf break_if = 28;
  bool has_break_if() const;
  private:
  bool _internal_has_break_if() const;

  public:
  void clear_break_if() ;
  const ::tint::core::ir::binary::pb::InstructionBreakIf& break_if() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE release_break_if();
  ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NONNULL mutable_break_if();
  void set_allocated_break_if(::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_break_if(::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE unsafe_arena_release_break_if();

  private:
  const ::tint::core::ir::binary::pb::InstructionBreakIf& _internal_break_if() const;
  ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NONNULL _internal_mutable_break_if();

  public:
  // .tint.core.ir.binary.pb.InstructionUnreachable unreachable = 29;
  bool has_unreachable() const;
  private:
  bool _internal_has_unreachable() const;

  public:
  void clear_unreachable() ;
  const ::tint::core::ir::binary::pb::InstructionUnreachable& unreachable() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE release_unreachable();
  ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NONNULL mutable_unreachable();
  void set_allocated_unreachable(::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_unreachable(::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE unsafe_arena_release_unreachable();

  private:
  const ::tint::core::ir::binary::pb::InstructionUnreachable& _internal_unreachable() const;
  ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NONNULL _internal_mutable_unreachable();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Instruction)
 private:
  class _Internal;
  void set_has_return_();
  void set_has_unary();
  void set_has_binary();
  void set_has_discard();
  void set_has_let();
  void set_has_var();
  void set_has_bitcast();
  void set_has_construct();
  void set_has_convert();
  void set_has_access();
  void set_has_user_call();
  void set_has_builtin_call();
  void set_has_load();
  void set_has_store();
  void set_has_load_vector_element();
  void set_has_store_vector_element();
  void set_has_swizzle();
  void set_has_if_();
  void set_has_switch_();
  void set_has_loop();
  void set_has_exit_if();
  void set_has_exit_switch();
  void set_has_exit_loop();
  void set_has_next_iteration();
  void set_has_continue_();
  void set_has_break_if();
  void set_has_unreachable();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 29,
                                   27, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Instruction& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> operands_;
    ::google::protobuf::internal::CachedSize _operands_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> results_;
    ::google::protobuf::internal::CachedSize _results_cached_byte_size_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE return__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE unary_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE binary_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE discard_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE let_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE var_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bitcast_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE construct_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE convert_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE access_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE user_call_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE builtin_call_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE load_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE store_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE load_vector_element_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE store_vector_element_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE swizzle_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE if__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE switch__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE loop_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE exit_if_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE exit_switch_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE exit_loop_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE next_iteration_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE continue__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE break_if_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE unreachable_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Instruction_class_data_;
// -------------------------------------------------------------------

class FunctionParameter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.FunctionParameter) */ {
 public:
  inline FunctionParameter() : FunctionParameter(nullptr) {}
  ~FunctionParameter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FunctionParameter* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FunctionParameter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FunctionParameter(::google::protobuf::internal::ConstantInitialized);

  inline FunctionParameter(const FunctionParameter& from) : FunctionParameter(nullptr, from) {}
  inline FunctionParameter(FunctionParameter&& from) noexcept
      : FunctionParameter(nullptr, ::std::move(from)) {}
  inline FunctionParameter& operator=(const FunctionParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionParameter& operator=(FunctionParameter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionParameter& default_instance() {
    return *reinterpret_cast<const FunctionParameter*>(
        &_FunctionParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(FunctionParameter& a, FunctionParameter& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(FunctionParameter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionParameter* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionParameter* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FunctionParameter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FunctionParameter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FunctionParameter& from) { FunctionParameter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FunctionParameter* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.FunctionParameter"; }

 protected:
  explicit FunctionParameter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FunctionParameter(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FunctionParameter& from);
  FunctionParameter(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FunctionParameter&& from) noexcept
      : FunctionParameter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kAttributesFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional .tint.core.ir.binary.pb.AttributesFunctionParameter attributes = 3;
  bool has_attributes() const;
  void clear_attributes() ;
  const ::tint::core::ir::binary::pb::AttributesFunctionParameter& attributes() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE release_attributes();
  ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NONNULL mutable_attributes();
  void set_allocated_attributes(::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_attributes(::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE unsafe_arena_release_attributes();

  private:
  const ::tint::core::ir::binary::pb::AttributesFunctionParameter& _internal_attributes() const;
  ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NONNULL _internal_mutable_attributes();

  public:
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.FunctionParameter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 53,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FunctionParameter& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE attributes_;
    ::uint32_t type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FunctionParameter_class_data_;
// -------------------------------------------------------------------

class Value final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Value* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Value));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Value(::google::protobuf::internal::ConstantInitialized);

  inline Value(const Value& from) : Value(nullptr, from) {}
  inline Value(Value&& from) noexcept
      : Value(nullptr, ::std::move(from)) {}
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *reinterpret_cast<const Value*>(
        &_Value_default_instance_);
  }
  enum KindCase {
    kFunction = 1,
    kInstructionResult = 2,
    kFunctionParameter = 3,
    kBlockParameter = 4,
    kConstant = 5,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(Value& a, Value& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Value* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Value>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Value& from) { Value::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Value* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Value"; }

 protected:
  explicit Value(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Value(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Value& from);
  Value(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Value&& from) noexcept
      : Value(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFunctionFieldNumber = 1,
    kInstructionResultFieldNumber = 2,
    kFunctionParameterFieldNumber = 3,
    kBlockParameterFieldNumber = 4,
    kConstantFieldNumber = 5,
  };
  // uint32 function = 1;
  bool has_function() const;
  void clear_function() ;
  ::uint32_t function() const;
  void set_function(::uint32_t value);

  private:
  ::uint32_t _internal_function() const;
  void _internal_set_function(::uint32_t value);

  public:
  // .tint.core.ir.binary.pb.InstructionResult instruction_result = 2;
  bool has_instruction_result() const;
  private:
  bool _internal_has_instruction_result() const;

  public:
  void clear_instruction_result() ;
  const ::tint::core::ir::binary::pb::InstructionResult& instruction_result() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE release_instruction_result();
  ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NONNULL mutable_instruction_result();
  void set_allocated_instruction_result(::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_instruction_result(::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE unsafe_arena_release_instruction_result();

  private:
  const ::tint::core::ir::binary::pb::InstructionResult& _internal_instruction_result() const;
  ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NONNULL _internal_mutable_instruction_result();

  public:
  // .tint.core.ir.binary.pb.FunctionParameter function_parameter = 3;
  bool has_function_parameter() const;
  private:
  bool _internal_has_function_parameter() const;

  public:
  void clear_function_parameter() ;
  const ::tint::core::ir::binary::pb::FunctionParameter& function_parameter() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE release_function_parameter();
  ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NONNULL mutable_function_parameter();
  void set_allocated_function_parameter(::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_function_parameter(::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE unsafe_arena_release_function_parameter();

  private:
  const ::tint::core::ir::binary::pb::FunctionParameter& _internal_function_parameter() const;
  ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NONNULL _internal_mutable_function_parameter();

  public:
  // .tint.core.ir.binary.pb.BlockParameter block_parameter = 4;
  bool has_block_parameter() const;
  private:
  bool _internal_has_block_parameter() const;

  public:
  void clear_block_parameter() ;
  const ::tint::core::ir::binary::pb::BlockParameter& block_parameter() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE release_block_parameter();
  ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NONNULL mutable_block_parameter();
  void set_allocated_block_parameter(::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_block_parameter(::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE unsafe_arena_release_block_parameter();

  private:
  const ::tint::core::ir::binary::pb::BlockParameter& _internal_block_parameter() const;
  ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NONNULL _internal_mutable_block_parameter();

  public:
  // uint32 constant = 5;
  bool has_constant() const;
  void clear_constant() ;
  ::uint32_t constant() const;
  void set_constant(::uint32_t value);

  private:
  ::uint32_t _internal_constant() const;
  void _internal_set_constant(::uint32_t value);

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Value)
 private:
  class _Internal;
  void set_has_function();
  void set_has_instruction_result();
  void set_has_function_parameter();
  void set_has_block_parameter();
  void set_has_constant();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 5,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Value& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t function_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE instruction_result_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE function_parameter_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE block_parameter_;
      ::uint32_t constant_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Value_class_data_;
// -------------------------------------------------------------------

class TypeStruct final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.TypeStruct) */ {
 public:
  inline TypeStruct() : TypeStruct(nullptr) {}
  ~TypeStruct() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TypeStruct* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TypeStruct));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TypeStruct(::google::protobuf::internal::ConstantInitialized);

  inline TypeStruct(const TypeStruct& from) : TypeStruct(nullptr, from) {}
  inline TypeStruct(TypeStruct&& from) noexcept
      : TypeStruct(nullptr, ::std::move(from)) {}
  inline TypeStruct& operator=(const TypeStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeStruct& operator=(TypeStruct&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeStruct& default_instance() {
    return *reinterpret_cast<const TypeStruct*>(
        &_TypeStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(TypeStruct& a, TypeStruct& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(TypeStruct* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeStruct* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeStruct* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TypeStruct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeStruct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TypeStruct& from) { TypeStruct::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TypeStruct* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.TypeStruct"; }

 protected:
  explicit TypeStruct(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TypeStruct(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TypeStruct& from);
  TypeStruct(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TypeStruct&& from) noexcept
      : TypeStruct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMemberFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .tint.core.ir.binary.pb.TypeStructMember member = 2;
  int member_size() const;
  private:
  int _internal_member_size() const;

  public:
  void clear_member() ;
  ::tint::core::ir::binary::pb::TypeStructMember* PROTOBUF_NONNULL mutable_member(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>* PROTOBUF_NONNULL mutable_member();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>& _internal_member() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>* PROTOBUF_NONNULL _internal_mutable_member();
  public:
  const ::tint::core::ir::binary::pb::TypeStructMember& member(int index) const;
  ::tint::core::ir::binary::pb::TypeStructMember* PROTOBUF_NONNULL add_member();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>& member() const;
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.TypeStruct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TypeStruct& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::TypeStructMember > member_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TypeStruct_class_data_;
// -------------------------------------------------------------------

class Block final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Block* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Block));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Block(::google::protobuf::internal::ConstantInitialized);

  inline Block(const Block& from) : Block(nullptr, from) {}
  inline Block(Block&& from) noexcept
      : Block(nullptr, ::std::move(from)) {}
  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *reinterpret_cast<const Block*>(
        &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(Block& a, Block& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Block* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Block>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Block& from) { Block::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Block* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Block"; }

 protected:
  explicit Block(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Block(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Block& from);
  Block(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Block&& from) noexcept
      : Block(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParametersFieldNumber = 1,
    kInstructionsFieldNumber = 2,
    kIsMultiInFieldNumber = 3,
  };
  // repeated uint32 parameters = 1;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  ::uint32_t parameters(int index) const;
  void set_parameters(int index, ::uint32_t value);
  void add_parameters(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& parameters() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_parameters();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_parameters() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_parameters();

  public:
  // repeated .tint.core.ir.binary.pb.Instruction instructions = 2;
  int instructions_size() const;
  private:
  int _internal_instructions_size() const;

  public:
  void clear_instructions() ;
  ::tint::core::ir::binary::pb::Instruction* PROTOBUF_NONNULL mutable_instructions(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>* PROTOBUF_NONNULL mutable_instructions();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>& _internal_instructions() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>* PROTOBUF_NONNULL _internal_mutable_instructions();
  public:
  const ::tint::core::ir::binary::pb::Instruction& instructions(int index) const;
  ::tint::core::ir::binary::pb::Instruction* PROTOBUF_NONNULL add_instructions();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>& instructions() const;
  // bool is_multi_in = 3;
  void clear_is_multi_in() ;
  bool is_multi_in() const;
  void set_is_multi_in(bool value);

  private:
  bool _internal_is_multi_in() const;
  void _internal_set_is_multi_in(bool value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Block)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Block& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> parameters_;
    ::google::protobuf::internal::CachedSize _parameters_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::Instruction > instructions_;
    bool is_multi_in_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Block_class_data_;
// -------------------------------------------------------------------

class Type final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Type* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Type));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Type(::google::protobuf::internal::ConstantInitialized);

  inline Type(const Type& from) : Type(nullptr, from) {}
  inline Type(Type&& from) noexcept
      : Type(nullptr, ::std::move(from)) {}
  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *reinterpret_cast<const Type*>(
        &_Type_default_instance_);
  }
  enum KindCase {
    kBasic = 1,
    kVector = 2,
    kMatrix = 3,
    kArray = 4,
    kPointer = 5,
    kStruct = 6,
    kAtomic = 7,
    kDepthTexture = 8,
    kSampledTexture = 9,
    kMultisampledTexture = 10,
    kDepthMultisampledTexture = 11,
    kStorageTexture = 12,
    kExternalTexture = 13,
    kSampler = 14,
    kInputAttachment = 15,
    kSubgroupMatrixLeft = 16,
    kSubgroupMatrixRight = 17,
    kSubgroupMatrixResult = 18,
    kBuiltinStruct = 19,
    kBindingArray = 20,
    kTexelBuffer = 21,
    kBuffer = 23,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Type& a, Type& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Type* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Type>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Type& from) { Type::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Type* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Type"; }

 protected:
  explicit Type(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Type(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Type& from);
  Type(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Type&& from) noexcept
      : Type(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBasicFieldNumber = 1,
    kVectorFieldNumber = 2,
    kMatrixFieldNumber = 3,
    kArrayFieldNumber = 4,
    kPointerFieldNumber = 5,
    kStructFieldNumber = 6,
    kAtomicFieldNumber = 7,
    kDepthTextureFieldNumber = 8,
    kSampledTextureFieldNumber = 9,
    kMultisampledTextureFieldNumber = 10,
    kDepthMultisampledTextureFieldNumber = 11,
    kStorageTextureFieldNumber = 12,
    kExternalTextureFieldNumber = 13,
    kSamplerFieldNumber = 14,
    kInputAttachmentFieldNumber = 15,
    kSubgroupMatrixLeftFieldNumber = 16,
    kSubgroupMatrixRightFieldNumber = 17,
    kSubgroupMatrixResultFieldNumber = 18,
    kBuiltinStructFieldNumber = 19,
    kBindingArrayFieldNumber = 20,
    kTexelBufferFieldNumber = 21,
    kBufferFieldNumber = 23,
  };
  // .tint.core.ir.binary.pb.TypeBasic basic = 1;
  bool has_basic() const;
  void clear_basic() ;
  ::tint::core::ir::binary::pb::TypeBasic basic() const;
  void set_basic(::tint::core::ir::binary::pb::TypeBasic value);

  private:
  ::tint::core::ir::binary::pb::TypeBasic _internal_basic() const;
  void _internal_set_basic(::tint::core::ir::binary::pb::TypeBasic value);

  public:
  // .tint.core.ir.binary.pb.TypeVector vector = 2;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;

  public:
  void clear_vector() ;
  const ::tint::core::ir::binary::pb::TypeVector& vector() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE release_vector();
  ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NONNULL mutable_vector();
  void set_allocated_vector(::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_vector(::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE unsafe_arena_release_vector();

  private:
  const ::tint::core::ir::binary::pb::TypeVector& _internal_vector() const;
  ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NONNULL _internal_mutable_vector();

  public:
  // .tint.core.ir.binary.pb.TypeMatrix matrix = 3;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;

  public:
  void clear_matrix() ;
  const ::tint::core::ir::binary::pb::TypeMatrix& matrix() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE release_matrix();
  ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NONNULL mutable_matrix();
  void set_allocated_matrix(::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_matrix(::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE unsafe_arena_release_matrix();

  private:
  const ::tint::core::ir::binary::pb::TypeMatrix& _internal_matrix() const;
  ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NONNULL _internal_mutable_matrix();

  public:
  // .tint.core.ir.binary.pb.TypeArray array = 4;
  bool has_array() const;
  private:
  bool _internal_has_array() const;

  public:
  void clear_array() ;
  const ::tint::core::ir::binary::pb::TypeArray& array() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE release_array();
  ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NONNULL mutable_array();
  void set_allocated_array(::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_array(::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE unsafe_arena_release_array();

  private:
  const ::tint::core::ir::binary::pb::TypeArray& _internal_array() const;
  ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NONNULL _internal_mutable_array();

  public:
  // .tint.core.ir.binary.pb.TypePointer pointer = 5;
  bool has_pointer() const;
  private:
  bool _internal_has_pointer() const;

  public:
  void clear_pointer() ;
  const ::tint::core::ir::binary::pb::TypePointer& pointer() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE release_pointer();
  ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NONNULL mutable_pointer();
  void set_allocated_pointer(::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pointer(::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE unsafe_arena_release_pointer();

  private:
  const ::tint::core::ir::binary::pb::TypePointer& _internal_pointer() const;
  ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NONNULL _internal_mutable_pointer();

  public:
  // .tint.core.ir.binary.pb.TypeStruct struct = 6;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;

  public:
  void clear_struct_() ;
  const ::tint::core::ir::binary::pb::TypeStruct& struct_() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE release_struct_();
  ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NONNULL mutable_struct_();
  void set_allocated_struct_(::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_struct_(::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE unsafe_arena_release_struct_();

  private:
  const ::tint::core::ir::binary::pb::TypeStruct& _internal_struct_() const;
  ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NONNULL _internal_mutable_struct_();

  public:
  // .tint.core.ir.binary.pb.TypeAtomic atomic = 7;
  bool has_atomic() const;
  private:
  bool _internal_has_atomic() const;

  public:
  void clear_atomic() ;
  const ::tint::core::ir::binary::pb::TypeAtomic& atomic() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE release_atomic();
  ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NONNULL mutable_atomic();
  void set_allocated_atomic(::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_atomic(::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE unsafe_arena_release_atomic();

  private:
  const ::tint::core::ir::binary::pb::TypeAtomic& _internal_atomic() const;
  ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NONNULL _internal_mutable_atomic();

  public:
  // .tint.core.ir.binary.pb.TypeDepthTexture depth_texture = 8;
  bool has_depth_texture() const;
  private:
  bool _internal_has_depth_texture() const;

  public:
  void clear_depth_texture() ;
  const ::tint::core::ir::binary::pb::TypeDepthTexture& depth_texture() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE release_depth_texture();
  ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NONNULL mutable_depth_texture();
  void set_allocated_depth_texture(::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_depth_texture(::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE unsafe_arena_release_depth_texture();

  private:
  const ::tint::core::ir::binary::pb::TypeDepthTexture& _internal_depth_texture() const;
  ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NONNULL _internal_mutable_depth_texture();

  public:
  // .tint.core.ir.binary.pb.TypeSampledTexture sampled_texture = 9;
  bool has_sampled_texture() const;
  private:
  bool _internal_has_sampled_texture() const;

  public:
  void clear_sampled_texture() ;
  const ::tint::core::ir::binary::pb::TypeSampledTexture& sampled_texture() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE release_sampled_texture();
  ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NONNULL mutable_sampled_texture();
  void set_allocated_sampled_texture(::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sampled_texture(::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE unsafe_arena_release_sampled_texture();

  private:
  const ::tint::core::ir::binary::pb::TypeSampledTexture& _internal_sampled_texture() const;
  ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NONNULL _internal_mutable_sampled_texture();

  public:
  // .tint.core.ir.binary.pb.TypeMultisampledTexture multisampled_texture = 10;
  bool has_multisampled_texture() const;
  private:
  bool _internal_has_multisampled_texture() const;

  public:
  void clear_multisampled_texture() ;
  const ::tint::core::ir::binary::pb::TypeMultisampledTexture& multisampled_texture() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE release_multisampled_texture();
  ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NONNULL mutable_multisampled_texture();
  void set_allocated_multisampled_texture(::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_multisampled_texture(::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE unsafe_arena_release_multisampled_texture();

  private:
  const ::tint::core::ir::binary::pb::TypeMultisampledTexture& _internal_multisampled_texture() const;
  ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NONNULL _internal_mutable_multisampled_texture();

  public:
  // .tint.core.ir.binary.pb.TypeDepthMultisampledTexture depth_multisampled_texture = 11;
  bool has_depth_multisampled_texture() const;
  private:
  bool _internal_has_depth_multisampled_texture() const;

  public:
  void clear_depth_multisampled_texture() ;
  const ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture& depth_multisampled_texture() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE release_depth_multisampled_texture();
  ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NONNULL mutable_depth_multisampled_texture();
  void set_allocated_depth_multisampled_texture(::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_depth_multisampled_texture(::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE unsafe_arena_release_depth_multisampled_texture();

  private:
  const ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture& _internal_depth_multisampled_texture() const;
  ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NONNULL _internal_mutable_depth_multisampled_texture();

  public:
  // .tint.core.ir.binary.pb.TypeStorageTexture storage_texture = 12;
  bool has_storage_texture() const;
  private:
  bool _internal_has_storage_texture() const;

  public:
  void clear_storage_texture() ;
  const ::tint::core::ir::binary::pb::TypeStorageTexture& storage_texture() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE release_storage_texture();
  ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NONNULL mutable_storage_texture();
  void set_allocated_storage_texture(::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_storage_texture(::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE unsafe_arena_release_storage_texture();

  private:
  const ::tint::core::ir::binary::pb::TypeStorageTexture& _internal_storage_texture() const;
  ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NONNULL _internal_mutable_storage_texture();

  public:
  // .tint.core.ir.binary.pb.TypeExternalTexture external_texture = 13;
  bool has_external_texture() const;
  private:
  bool _internal_has_external_texture() const;

  public:
  void clear_external_texture() ;
  const ::tint::core::ir::binary::pb::TypeExternalTexture& external_texture() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE release_external_texture();
  ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NONNULL mutable_external_texture();
  void set_allocated_external_texture(::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_external_texture(::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE unsafe_arena_release_external_texture();

  private:
  const ::tint::core::ir::binary::pb::TypeExternalTexture& _internal_external_texture() const;
  ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NONNULL _internal_mutable_external_texture();

  public:
  // .tint.core.ir.binary.pb.TypeSampler sampler = 14;
  bool has_sampler() const;
  private:
  bool _internal_has_sampler() const;

  public:
  void clear_sampler() ;
  const ::tint::core::ir::binary::pb::TypeSampler& sampler() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE release_sampler();
  ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NONNULL mutable_sampler();
  void set_allocated_sampler(::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sampler(::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE unsafe_arena_release_sampler();

  private:
  const ::tint::core::ir::binary::pb::TypeSampler& _internal_sampler() const;
  ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NONNULL _internal_mutable_sampler();

  public:
  // .tint.core.ir.binary.pb.TypeInputAttachment input_attachment = 15;
  bool has_input_attachment() const;
  private:
  bool _internal_has_input_attachment() const;

  public:
  void clear_input_attachment() ;
  const ::tint::core::ir::binary::pb::TypeInputAttachment& input_attachment() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE release_input_attachment();
  ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NONNULL mutable_input_attachment();
  void set_allocated_input_attachment(::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_input_attachment(::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE unsafe_arena_release_input_attachment();

  private:
  const ::tint::core::ir::binary::pb::TypeInputAttachment& _internal_input_attachment() const;
  ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NONNULL _internal_mutable_input_attachment();

  public:
  // .tint.core.ir.binary.pb.TypeSubgroupMatrix subgroup_matrix_left = 16;
  bool has_subgroup_matrix_left() const;
  private:
  bool _internal_has_subgroup_matrix_left() const;

  public:
  void clear_subgroup_matrix_left() ;
  const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& subgroup_matrix_left() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE release_subgroup_matrix_left();
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL mutable_subgroup_matrix_left();
  void set_allocated_subgroup_matrix_left(::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subgroup_matrix_left(::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE unsafe_arena_release_subgroup_matrix_left();

  private:
  const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& _internal_subgroup_matrix_left() const;
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL _internal_mutable_subgroup_matrix_left();

  public:
  // .tint.core.ir.binary.pb.TypeSubgroupMatrix subgroup_matrix_right = 17;
  bool has_subgroup_matrix_right() const;
  private:
  bool _internal_has_subgroup_matrix_right() const;

  public:
  void clear_subgroup_matrix_right() ;
  const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& subgroup_matrix_right() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE release_subgroup_matrix_right();
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL mutable_subgroup_matrix_right();
  void set_allocated_subgroup_matrix_right(::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subgroup_matrix_right(::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE unsafe_arena_release_subgroup_matrix_right();

  private:
  const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& _internal_subgroup_matrix_right() const;
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL _internal_mutable_subgroup_matrix_right();

  public:
  // .tint.core.ir.binary.pb.TypeSubgroupMatrix subgroup_matrix_result = 18;
  bool has_subgroup_matrix_result() const;
  private:
  bool _internal_has_subgroup_matrix_result() const;

  public:
  void clear_subgroup_matrix_result() ;
  const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& subgroup_matrix_result() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE release_subgroup_matrix_result();
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL mutable_subgroup_matrix_result();
  void set_allocated_subgroup_matrix_result(::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_subgroup_matrix_result(::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE unsafe_arena_release_subgroup_matrix_result();

  private:
  const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& _internal_subgroup_matrix_result() const;
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL _internal_mutable_subgroup_matrix_result();

  public:
  // .tint.core.ir.binary.pb.TypeBuiltinStruct builtin_struct = 19;
  bool has_builtin_struct() const;
  void clear_builtin_struct() ;
  ::tint::core::ir::binary::pb::TypeBuiltinStruct builtin_struct() const;
  void set_builtin_struct(::tint::core::ir::binary::pb::TypeBuiltinStruct value);

  private:
  ::tint::core::ir::binary::pb::TypeBuiltinStruct _internal_builtin_struct() const;
  void _internal_set_builtin_struct(::tint::core::ir::binary::pb::TypeBuiltinStruct value);

  public:
  // .tint.core.ir.binary.pb.TypeBindingArray binding_array = 20;
  bool has_binding_array() const;
  private:
  bool _internal_has_binding_array() const;

  public:
  void clear_binding_array() ;
  const ::tint::core::ir::binary::pb::TypeBindingArray& binding_array() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE release_binding_array();
  ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NONNULL mutable_binding_array();
  void set_allocated_binding_array(::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_binding_array(::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE unsafe_arena_release_binding_array();

  private:
  const ::tint::core::ir::binary::pb::TypeBindingArray& _internal_binding_array() const;
  ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NONNULL _internal_mutable_binding_array();

  public:
  // .tint.core.ir.binary.pb.TypeTexelBuffer texel_buffer = 21;
  bool has_texel_buffer() const;
  private:
  bool _internal_has_texel_buffer() const;

  public:
  void clear_texel_buffer() ;
  const ::tint::core::ir::binary::pb::TypeTexelBuffer& texel_buffer() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE release_texel_buffer();
  ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NONNULL mutable_texel_buffer();
  void set_allocated_texel_buffer(::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_texel_buffer(::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE unsafe_arena_release_texel_buffer();

  private:
  const ::tint::core::ir::binary::pb::TypeTexelBuffer& _internal_texel_buffer() const;
  ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NONNULL _internal_mutable_texel_buffer();

  public:
  // .tint.core.ir.binary.pb.TypeBuffer buffer = 23;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;

  public:
  void clear_buffer() ;
  const ::tint::core::ir::binary::pb::TypeBuffer& buffer() const;
  [[nodiscard]] ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE release_buffer();
  ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NONNULL mutable_buffer();
  void set_allocated_buffer(::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_buffer(::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE value);
  ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE unsafe_arena_release_buffer();

  private:
  const ::tint::core::ir::binary::pb::TypeBuffer& _internal_buffer() const;
  ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NONNULL _internal_mutable_buffer();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Type)
 private:
  class _Internal;
  void set_has_basic();
  void set_has_vector();
  void set_has_matrix();
  void set_has_array();
  void set_has_pointer();
  void set_has_struct_();
  void set_has_atomic();
  void set_has_depth_texture();
  void set_has_sampled_texture();
  void set_has_multisampled_texture();
  void set_has_depth_multisampled_texture();
  void set_has_storage_texture();
  void set_has_external_texture();
  void set_has_sampler();
  void set_has_input_attachment();
  void set_has_subgroup_matrix_left();
  void set_has_subgroup_matrix_right();
  void set_has_subgroup_matrix_result();
  void set_has_builtin_struct();
  void set_has_binding_array();
  void set_has_texel_buffer();
  void set_has_buffer();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 22,
                                   20, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Type& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int basic_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE vector_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE matrix_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE array_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pointer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE struct__;
      ::google::protobuf::Message* PROTOBUF_NULLABLE atomic_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE depth_texture_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sampled_texture_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE multisampled_texture_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE depth_multisampled_texture_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE storage_texture_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE external_texture_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sampler_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE input_attachment_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subgroup_matrix_left_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subgroup_matrix_right_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE subgroup_matrix_result_;
      int builtin_struct_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE binding_array_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE texel_buffer_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE buffer_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Type_class_data_;
// -------------------------------------------------------------------

class Module final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tint.core.ir.binary.pb.Module) */ {
 public:
  inline Module() : Module(nullptr) {}
  ~Module() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Module* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Module));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Module(::google::protobuf::internal::ConstantInitialized);

  inline Module(const Module& from) : Module(nullptr, from) {}
  inline Module(Module&& from) noexcept
      : Module(nullptr, ::std::move(from)) {}
  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  inline Module& operator=(Module&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Module& default_instance() {
    return *reinterpret_cast<const Module*>(
        &_Module_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Module& a, Module& b) { a.Swap(&b); }
  PROTOBUF_NOINLINE void Swap(Module* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Module* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Module* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Module>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Module& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Module& from) { Module::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Module* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tint.core.ir.binary.pb.Module"; }

 protected:
  explicit Module(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Module(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Module& from);
  Module(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Module&& from) noexcept
      : Module(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypesFieldNumber = 1,
    kValuesFieldNumber = 2,
    kConstantValuesFieldNumber = 3,
    kFunctionsFieldNumber = 4,
    kBlocksFieldNumber = 5,
    kRootBlockFieldNumber = 6,
  };
  // repeated .tint.core.ir.binary.pb.Type types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;

  public:
  void clear_types() ;
  ::tint::core::ir::binary::pb::Type* PROTOBUF_NONNULL mutable_types(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>* PROTOBUF_NONNULL mutable_types();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>& _internal_types() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>* PROTOBUF_NONNULL _internal_mutable_types();
  public:
  const ::tint::core::ir::binary::pb::Type& types(int index) const;
  ::tint::core::ir::binary::pb::Type* PROTOBUF_NONNULL add_types();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>& types() const;
  // repeated .tint.core.ir.binary.pb.Value values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::tint::core::ir::binary::pb::Value* PROTOBUF_NONNULL mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>* PROTOBUF_NONNULL _internal_mutable_values();
  public:
  const ::tint::core::ir::binary::pb::Value& values(int index) const;
  ::tint::core::ir::binary::pb::Value* PROTOBUF_NONNULL add_values();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>& values() const;
  // repeated .tint.core.ir.binary.pb.ConstantValue constant_values = 3;
  int constant_values_size() const;
  private:
  int _internal_constant_values_size() const;

  public:
  void clear_constant_values() ;
  ::tint::core::ir::binary::pb::ConstantValue* PROTOBUF_NONNULL mutable_constant_values(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>* PROTOBUF_NONNULL mutable_constant_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>& _internal_constant_values() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>* PROTOBUF_NONNULL _internal_mutable_constant_values();
  public:
  const ::tint::core::ir::binary::pb::ConstantValue& constant_values(int index) const;
  ::tint::core::ir::binary::pb::ConstantValue* PROTOBUF_NONNULL add_constant_values();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>& constant_values() const;
  // repeated .tint.core.ir.binary.pb.Function functions = 4;
  int functions_size() const;
  private:
  int _internal_functions_size() const;

  public:
  void clear_functions() ;
  ::tint::core::ir::binary::pb::Function* PROTOBUF_NONNULL mutable_functions(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>* PROTOBUF_NONNULL mutable_functions();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>& _internal_functions() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>* PROTOBUF_NONNULL _internal_mutable_functions();
  public:
  const ::tint::core::ir::binary::pb::Function& functions(int index) const;
  ::tint::core::ir::binary::pb::Function* PROTOBUF_NONNULL add_functions();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>& functions() const;
  // repeated .tint.core.ir.binary.pb.Block blocks = 5;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;

  public:
  void clear_blocks() ;
  ::tint::core::ir::binary::pb::Block* PROTOBUF_NONNULL mutable_blocks(int index);
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>* PROTOBUF_NONNULL mutable_blocks();

  private:
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>& _internal_blocks() const;
  ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>* PROTOBUF_NONNULL _internal_mutable_blocks();
  public:
  const ::tint::core::ir::binary::pb::Block& blocks(int index) const;
  ::tint::core::ir::binary::pb::Block* PROTOBUF_NONNULL add_blocks();
  const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>& blocks() const;
  // uint32 root_block = 6;
  void clear_root_block() ;
  ::uint32_t root_block() const;
  void set_root_block(::uint32_t value);

  private:
  ::uint32_t _internal_root_block() const;
  void _internal_set_root_block(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tint.core.ir.binary.pb.Module)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   5, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Module& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::Type > types_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::Value > values_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::ConstantValue > constant_values_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::Function > functions_;
    ::google::protobuf::RepeatedPtrField< ::tint::core::ir::binary::pb::Block > blocks_;
    ::uint32_t root_block_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_src_2ftint_2futils_2fprotos_2fir_2fir_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Module_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Module

// repeated .tint.core.ir.binary.pb.Type types = 1;
inline int Module::_internal_types_size() const {
  return _internal_types().size();
}
inline int Module::types_size() const {
  return _internal_types_size();
}
inline void Module::clear_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.types_.Clear();
}
inline ::tint::core::ir::binary::pb::Type* PROTOBUF_NONNULL Module::mutable_types(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Module.types)
  return _internal_mutable_types()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>* PROTOBUF_NONNULL Module::mutable_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Module.types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_types();
}
inline const ::tint::core::ir::binary::pb::Type& Module::types(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Module.types)
  return _internal_types().Get(index);
}
inline ::tint::core::ir::binary::pb::Type* PROTOBUF_NONNULL Module::add_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::Type* _add = _internal_mutable_types()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Module.types)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>& Module::types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Module.types)
  return _internal_types();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>&
Module::_internal_types() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.types_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Type>* PROTOBUF_NONNULL
Module::_internal_mutable_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.types_;
}

// repeated .tint.core.ir.binary.pb.Value values = 2;
inline int Module::_internal_values_size() const {
  return _internal_values().size();
}
inline int Module::values_size() const {
  return _internal_values_size();
}
inline void Module::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::tint::core::ir::binary::pb::Value* PROTOBUF_NONNULL Module::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Module.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>* PROTOBUF_NONNULL Module::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Module.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::tint::core::ir::binary::pb::Value& Module::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Module.values)
  return _internal_values().Get(index);
}
inline ::tint::core::ir::binary::pb::Value* PROTOBUF_NONNULL Module::add_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::Value* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Module.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>& Module::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Module.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>&
Module::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Value>* PROTOBUF_NONNULL
Module::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// repeated .tint.core.ir.binary.pb.ConstantValue constant_values = 3;
inline int Module::_internal_constant_values_size() const {
  return _internal_constant_values().size();
}
inline int Module::constant_values_size() const {
  return _internal_constant_values_size();
}
inline void Module::clear_constant_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constant_values_.Clear();
}
inline ::tint::core::ir::binary::pb::ConstantValue* PROTOBUF_NONNULL Module::mutable_constant_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Module.constant_values)
  return _internal_mutable_constant_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>* PROTOBUF_NONNULL Module::mutable_constant_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Module.constant_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_constant_values();
}
inline const ::tint::core::ir::binary::pb::ConstantValue& Module::constant_values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Module.constant_values)
  return _internal_constant_values().Get(index);
}
inline ::tint::core::ir::binary::pb::ConstantValue* PROTOBUF_NONNULL Module::add_constant_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::ConstantValue* _add = _internal_mutable_constant_values()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Module.constant_values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>& Module::constant_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Module.constant_values)
  return _internal_constant_values();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>&
Module::_internal_constant_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constant_values_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::ConstantValue>* PROTOBUF_NONNULL
Module::_internal_mutable_constant_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.constant_values_;
}

// repeated .tint.core.ir.binary.pb.Function functions = 4;
inline int Module::_internal_functions_size() const {
  return _internal_functions().size();
}
inline int Module::functions_size() const {
  return _internal_functions_size();
}
inline void Module::clear_functions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.functions_.Clear();
}
inline ::tint::core::ir::binary::pb::Function* PROTOBUF_NONNULL Module::mutable_functions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Module.functions)
  return _internal_mutable_functions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>* PROTOBUF_NONNULL Module::mutable_functions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Module.functions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_functions();
}
inline const ::tint::core::ir::binary::pb::Function& Module::functions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Module.functions)
  return _internal_functions().Get(index);
}
inline ::tint::core::ir::binary::pb::Function* PROTOBUF_NONNULL Module::add_functions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::Function* _add = _internal_mutable_functions()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Module.functions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>& Module::functions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Module.functions)
  return _internal_functions();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>&
Module::_internal_functions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.functions_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Function>* PROTOBUF_NONNULL
Module::_internal_mutable_functions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.functions_;
}

// repeated .tint.core.ir.binary.pb.Block blocks = 5;
inline int Module::_internal_blocks_size() const {
  return _internal_blocks().size();
}
inline int Module::blocks_size() const {
  return _internal_blocks_size();
}
inline void Module::clear_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blocks_.Clear();
}
inline ::tint::core::ir::binary::pb::Block* PROTOBUF_NONNULL Module::mutable_blocks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Module.blocks)
  return _internal_mutable_blocks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>* PROTOBUF_NONNULL Module::mutable_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Module.blocks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_blocks();
}
inline const ::tint::core::ir::binary::pb::Block& Module::blocks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Module.blocks)
  return _internal_blocks().Get(index);
}
inline ::tint::core::ir::binary::pb::Block* PROTOBUF_NONNULL Module::add_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::Block* _add = _internal_mutable_blocks()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Module.blocks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>& Module::blocks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Module.blocks)
  return _internal_blocks();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>&
Module::_internal_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Block>* PROTOBUF_NONNULL
Module::_internal_mutable_blocks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.blocks_;
}

// uint32 root_block = 6;
inline void Module::clear_root_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_block_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t Module::root_block() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Module.root_block)
  return _internal_root_block();
}
inline void Module::set_root_block(::uint32_t value) {
  _internal_set_root_block(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Module.root_block)
}
inline ::uint32_t Module::_internal_root_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.root_block_;
}
inline void Module::_internal_set_root_block(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_block_ = value;
}

// -------------------------------------------------------------------

// Type

// .tint.core.ir.binary.pb.TypeBasic basic = 1;
inline bool Type::has_basic() const {
  return kind_case() == kBasic;
}
inline void Type::set_has_basic() {
  _impl_._oneof_case_[0] = kBasic;
}
inline void Type::clear_basic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBasic) {
    _impl_.kind_.basic_ = 0;
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeBasic Type::basic() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.basic)
  return _internal_basic();
}
inline void Type::set_basic(::tint::core::ir::binary::pb::TypeBasic value) {
  if (kind_case() != kBasic) {
    clear_kind();
    set_has_basic();
  }
  _impl_.kind_.basic_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Type.basic)
}
inline ::tint::core::ir::binary::pb::TypeBasic Type::_internal_basic() const {
  if (kind_case() == kBasic) {
    return static_cast<::tint::core::ir::binary::pb::TypeBasic>(_impl_.kind_.basic_);
  }
  return static_cast<::tint::core::ir::binary::pb::TypeBasic>(0);
}

// .tint.core.ir.binary.pb.TypeVector vector = 2;
inline bool Type::has_vector() const {
  return kind_case() == kVector;
}
inline bool Type::_internal_has_vector() const {
  return kind_case() == kVector;
}
inline void Type::set_has_vector() {
  _impl_._oneof_case_[0] = kVector;
}
inline void Type::clear_vector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kVector) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.vector_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.vector_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE Type::release_vector() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.vector)
  if (kind_case() == kVector) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeVector*>(_impl_.kind_.vector_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeVector& Type::_internal_vector() const {
  return kind_case() == kVector ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeVector*>(_impl_.kind_.vector_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeVector&>(::tint::core::ir::binary::pb::_TypeVector_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeVector& Type::vector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.vector)
  return _internal_vector();
}
inline ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE Type::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.vector)
  if (kind_case() == kVector) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeVector*>(_impl_.kind_.vector_);
    _impl_.kind_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_vector(
    ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_vector();
    _impl_.kind_.vector_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.vector)
}
inline ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NONNULL Type::_internal_mutable_vector() {
  if (kind_case() != kVector) {
    clear_kind();
    set_has_vector();
    _impl_.kind_.vector_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeVector>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeVector*>(_impl_.kind_.vector_);
}
inline ::tint::core::ir::binary::pb::TypeVector* PROTOBUF_NONNULL Type::mutable_vector()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeVector* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.vector)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeMatrix matrix = 3;
inline bool Type::has_matrix() const {
  return kind_case() == kMatrix;
}
inline bool Type::_internal_has_matrix() const {
  return kind_case() == kMatrix;
}
inline void Type::set_has_matrix() {
  _impl_._oneof_case_[0] = kMatrix;
}
inline void Type::clear_matrix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kMatrix) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.matrix_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.matrix_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE Type::release_matrix() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.matrix)
  if (kind_case() == kMatrix) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeMatrix*>(_impl_.kind_.matrix_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.matrix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeMatrix& Type::_internal_matrix() const {
  return kind_case() == kMatrix ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeMatrix*>(_impl_.kind_.matrix_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeMatrix&>(::tint::core::ir::binary::pb::_TypeMatrix_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeMatrix& Type::matrix() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.matrix)
  return _internal_matrix();
}
inline ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE Type::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.matrix)
  if (kind_case() == kMatrix) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeMatrix*>(_impl_.kind_.matrix_);
    _impl_.kind_.matrix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_matrix(
    ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_matrix();
    _impl_.kind_.matrix_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.matrix)
}
inline ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NONNULL Type::_internal_mutable_matrix() {
  if (kind_case() != kMatrix) {
    clear_kind();
    set_has_matrix();
    _impl_.kind_.matrix_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeMatrix>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeMatrix*>(_impl_.kind_.matrix_);
}
inline ::tint::core::ir::binary::pb::TypeMatrix* PROTOBUF_NONNULL Type::mutable_matrix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeMatrix* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.matrix)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeArray array = 4;
inline bool Type::has_array() const {
  return kind_case() == kArray;
}
inline bool Type::_internal_has_array() const {
  return kind_case() == kArray;
}
inline void Type::set_has_array() {
  _impl_._oneof_case_[0] = kArray;
}
inline void Type::clear_array() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kArray) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.array_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.array_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE Type::release_array() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.array)
  if (kind_case() == kArray) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeArray*>(_impl_.kind_.array_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeArray& Type::_internal_array() const {
  return kind_case() == kArray ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeArray*>(_impl_.kind_.array_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeArray&>(::tint::core::ir::binary::pb::_TypeArray_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeArray& Type::array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.array)
  return _internal_array();
}
inline ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE Type::unsafe_arena_release_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.array)
  if (kind_case() == kArray) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeArray*>(_impl_.kind_.array_);
    _impl_.kind_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_array(
    ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_array();
    _impl_.kind_.array_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.array)
}
inline ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NONNULL Type::_internal_mutable_array() {
  if (kind_case() != kArray) {
    clear_kind();
    set_has_array();
    _impl_.kind_.array_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeArray>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeArray*>(_impl_.kind_.array_);
}
inline ::tint::core::ir::binary::pb::TypeArray* PROTOBUF_NONNULL Type::mutable_array()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeArray* _msg = _internal_mutable_array();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.array)
  return _msg;
}

// .tint.core.ir.binary.pb.TypePointer pointer = 5;
inline bool Type::has_pointer() const {
  return kind_case() == kPointer;
}
inline bool Type::_internal_has_pointer() const {
  return kind_case() == kPointer;
}
inline void Type::set_has_pointer() {
  _impl_._oneof_case_[0] = kPointer;
}
inline void Type::clear_pointer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPointer) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.pointer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.pointer_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE Type::release_pointer() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.pointer)
  if (kind_case() == kPointer) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypePointer*>(_impl_.kind_.pointer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.pointer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypePointer& Type::_internal_pointer() const {
  return kind_case() == kPointer ? *reinterpret_cast<::tint::core::ir::binary::pb::TypePointer*>(_impl_.kind_.pointer_) : reinterpret_cast<::tint::core::ir::binary::pb::TypePointer&>(::tint::core::ir::binary::pb::_TypePointer_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypePointer& Type::pointer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.pointer)
  return _internal_pointer();
}
inline ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE Type::unsafe_arena_release_pointer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.pointer)
  if (kind_case() == kPointer) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypePointer*>(_impl_.kind_.pointer_);
    _impl_.kind_.pointer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_pointer(
    ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_pointer();
    _impl_.kind_.pointer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.pointer)
}
inline ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NONNULL Type::_internal_mutable_pointer() {
  if (kind_case() != kPointer) {
    clear_kind();
    set_has_pointer();
    _impl_.kind_.pointer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypePointer>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypePointer*>(_impl_.kind_.pointer_);
}
inline ::tint::core::ir::binary::pb::TypePointer* PROTOBUF_NONNULL Type::mutable_pointer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypePointer* _msg = _internal_mutable_pointer();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.pointer)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeStruct struct = 6;
inline bool Type::has_struct_() const {
  return kind_case() == kStruct;
}
inline bool Type::_internal_has_struct_() const {
  return kind_case() == kStruct;
}
inline void Type::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline void Type::clear_struct_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStruct) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.struct__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.struct__);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE Type::release_struct_() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.struct)
  if (kind_case() == kStruct) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeStruct*>(_impl_.kind_.struct__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeStruct& Type::_internal_struct_() const {
  return kind_case() == kStruct ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeStruct*>(_impl_.kind_.struct__) : reinterpret_cast<::tint::core::ir::binary::pb::TypeStruct&>(::tint::core::ir::binary::pb::_TypeStruct_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeStruct& Type::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.struct)
  return _internal_struct_();
}
inline ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE Type::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.struct)
  if (kind_case() == kStruct) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeStruct*>(_impl_.kind_.struct__);
    _impl_.kind_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_struct_(
    ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_struct_();
    _impl_.kind_.struct__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.struct)
}
inline ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NONNULL Type::_internal_mutable_struct_() {
  if (kind_case() != kStruct) {
    clear_kind();
    set_has_struct_();
    _impl_.kind_.struct__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeStruct>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeStruct*>(_impl_.kind_.struct__);
}
inline ::tint::core::ir::binary::pb::TypeStruct* PROTOBUF_NONNULL Type::mutable_struct_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeStruct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.struct)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeAtomic atomic = 7;
inline bool Type::has_atomic() const {
  return kind_case() == kAtomic;
}
inline bool Type::_internal_has_atomic() const {
  return kind_case() == kAtomic;
}
inline void Type::set_has_atomic() {
  _impl_._oneof_case_[0] = kAtomic;
}
inline void Type::clear_atomic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kAtomic) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.atomic_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.atomic_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE Type::release_atomic() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.atomic)
  if (kind_case() == kAtomic) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeAtomic*>(_impl_.kind_.atomic_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.atomic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeAtomic& Type::_internal_atomic() const {
  return kind_case() == kAtomic ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeAtomic*>(_impl_.kind_.atomic_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeAtomic&>(::tint::core::ir::binary::pb::_TypeAtomic_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeAtomic& Type::atomic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.atomic)
  return _internal_atomic();
}
inline ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE Type::unsafe_arena_release_atomic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.atomic)
  if (kind_case() == kAtomic) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeAtomic*>(_impl_.kind_.atomic_);
    _impl_.kind_.atomic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_atomic(
    ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_atomic();
    _impl_.kind_.atomic_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.atomic)
}
inline ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NONNULL Type::_internal_mutable_atomic() {
  if (kind_case() != kAtomic) {
    clear_kind();
    set_has_atomic();
    _impl_.kind_.atomic_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeAtomic>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeAtomic*>(_impl_.kind_.atomic_);
}
inline ::tint::core::ir::binary::pb::TypeAtomic* PROTOBUF_NONNULL Type::mutable_atomic()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeAtomic* _msg = _internal_mutable_atomic();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.atomic)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeDepthTexture depth_texture = 8;
inline bool Type::has_depth_texture() const {
  return kind_case() == kDepthTexture;
}
inline bool Type::_internal_has_depth_texture() const {
  return kind_case() == kDepthTexture;
}
inline void Type::set_has_depth_texture() {
  _impl_._oneof_case_[0] = kDepthTexture;
}
inline void Type::clear_depth_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kDepthTexture) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.depth_texture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.depth_texture_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE Type::release_depth_texture() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.depth_texture)
  if (kind_case() == kDepthTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthTexture*>(_impl_.kind_.depth_texture_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.depth_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeDepthTexture& Type::_internal_depth_texture() const {
  return kind_case() == kDepthTexture ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthTexture*>(_impl_.kind_.depth_texture_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthTexture&>(::tint::core::ir::binary::pb::_TypeDepthTexture_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeDepthTexture& Type::depth_texture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.depth_texture)
  return _internal_depth_texture();
}
inline ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE Type::unsafe_arena_release_depth_texture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.depth_texture)
  if (kind_case() == kDepthTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthTexture*>(_impl_.kind_.depth_texture_);
    _impl_.kind_.depth_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_depth_texture(
    ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_depth_texture();
    _impl_.kind_.depth_texture_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.depth_texture)
}
inline ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NONNULL Type::_internal_mutable_depth_texture() {
  if (kind_case() != kDepthTexture) {
    clear_kind();
    set_has_depth_texture();
    _impl_.kind_.depth_texture_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeDepthTexture>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthTexture*>(_impl_.kind_.depth_texture_);
}
inline ::tint::core::ir::binary::pb::TypeDepthTexture* PROTOBUF_NONNULL Type::mutable_depth_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeDepthTexture* _msg = _internal_mutable_depth_texture();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.depth_texture)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeSampledTexture sampled_texture = 9;
inline bool Type::has_sampled_texture() const {
  return kind_case() == kSampledTexture;
}
inline bool Type::_internal_has_sampled_texture() const {
  return kind_case() == kSampledTexture;
}
inline void Type::set_has_sampled_texture() {
  _impl_._oneof_case_[0] = kSampledTexture;
}
inline void Type::clear_sampled_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSampledTexture) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.sampled_texture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.sampled_texture_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE Type::release_sampled_texture() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.sampled_texture)
  if (kind_case() == kSampledTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSampledTexture*>(_impl_.kind_.sampled_texture_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.sampled_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeSampledTexture& Type::_internal_sampled_texture() const {
  return kind_case() == kSampledTexture ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeSampledTexture*>(_impl_.kind_.sampled_texture_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeSampledTexture&>(::tint::core::ir::binary::pb::_TypeSampledTexture_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeSampledTexture& Type::sampled_texture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.sampled_texture)
  return _internal_sampled_texture();
}
inline ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE Type::unsafe_arena_release_sampled_texture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.sampled_texture)
  if (kind_case() == kSampledTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSampledTexture*>(_impl_.kind_.sampled_texture_);
    _impl_.kind_.sampled_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_sampled_texture(
    ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_sampled_texture();
    _impl_.kind_.sampled_texture_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.sampled_texture)
}
inline ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NONNULL Type::_internal_mutable_sampled_texture() {
  if (kind_case() != kSampledTexture) {
    clear_kind();
    set_has_sampled_texture();
    _impl_.kind_.sampled_texture_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeSampledTexture>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeSampledTexture*>(_impl_.kind_.sampled_texture_);
}
inline ::tint::core::ir::binary::pb::TypeSampledTexture* PROTOBUF_NONNULL Type::mutable_sampled_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeSampledTexture* _msg = _internal_mutable_sampled_texture();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.sampled_texture)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeMultisampledTexture multisampled_texture = 10;
inline bool Type::has_multisampled_texture() const {
  return kind_case() == kMultisampledTexture;
}
inline bool Type::_internal_has_multisampled_texture() const {
  return kind_case() == kMultisampledTexture;
}
inline void Type::set_has_multisampled_texture() {
  _impl_._oneof_case_[0] = kMultisampledTexture;
}
inline void Type::clear_multisampled_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kMultisampledTexture) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.multisampled_texture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.multisampled_texture_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE Type::release_multisampled_texture() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.multisampled_texture)
  if (kind_case() == kMultisampledTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeMultisampledTexture*>(_impl_.kind_.multisampled_texture_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.multisampled_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeMultisampledTexture& Type::_internal_multisampled_texture() const {
  return kind_case() == kMultisampledTexture ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeMultisampledTexture*>(_impl_.kind_.multisampled_texture_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeMultisampledTexture&>(::tint::core::ir::binary::pb::_TypeMultisampledTexture_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeMultisampledTexture& Type::multisampled_texture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.multisampled_texture)
  return _internal_multisampled_texture();
}
inline ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE Type::unsafe_arena_release_multisampled_texture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.multisampled_texture)
  if (kind_case() == kMultisampledTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeMultisampledTexture*>(_impl_.kind_.multisampled_texture_);
    _impl_.kind_.multisampled_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_multisampled_texture(
    ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_multisampled_texture();
    _impl_.kind_.multisampled_texture_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.multisampled_texture)
}
inline ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NONNULL Type::_internal_mutable_multisampled_texture() {
  if (kind_case() != kMultisampledTexture) {
    clear_kind();
    set_has_multisampled_texture();
    _impl_.kind_.multisampled_texture_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeMultisampledTexture>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeMultisampledTexture*>(_impl_.kind_.multisampled_texture_);
}
inline ::tint::core::ir::binary::pb::TypeMultisampledTexture* PROTOBUF_NONNULL Type::mutable_multisampled_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeMultisampledTexture* _msg = _internal_mutable_multisampled_texture();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.multisampled_texture)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeDepthMultisampledTexture depth_multisampled_texture = 11;
inline bool Type::has_depth_multisampled_texture() const {
  return kind_case() == kDepthMultisampledTexture;
}
inline bool Type::_internal_has_depth_multisampled_texture() const {
  return kind_case() == kDepthMultisampledTexture;
}
inline void Type::set_has_depth_multisampled_texture() {
  _impl_._oneof_case_[0] = kDepthMultisampledTexture;
}
inline void Type::clear_depth_multisampled_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kDepthMultisampledTexture) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.depth_multisampled_texture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.depth_multisampled_texture_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE Type::release_depth_multisampled_texture() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.depth_multisampled_texture)
  if (kind_case() == kDepthMultisampledTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthMultisampledTexture*>(_impl_.kind_.depth_multisampled_texture_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.depth_multisampled_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture& Type::_internal_depth_multisampled_texture() const {
  return kind_case() == kDepthMultisampledTexture ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthMultisampledTexture*>(_impl_.kind_.depth_multisampled_texture_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthMultisampledTexture&>(::tint::core::ir::binary::pb::_TypeDepthMultisampledTexture_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture& Type::depth_multisampled_texture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.depth_multisampled_texture)
  return _internal_depth_multisampled_texture();
}
inline ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE Type::unsafe_arena_release_depth_multisampled_texture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.depth_multisampled_texture)
  if (kind_case() == kDepthMultisampledTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthMultisampledTexture*>(_impl_.kind_.depth_multisampled_texture_);
    _impl_.kind_.depth_multisampled_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_depth_multisampled_texture(
    ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_depth_multisampled_texture();
    _impl_.kind_.depth_multisampled_texture_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.depth_multisampled_texture)
}
inline ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NONNULL Type::_internal_mutable_depth_multisampled_texture() {
  if (kind_case() != kDepthMultisampledTexture) {
    clear_kind();
    set_has_depth_multisampled_texture();
    _impl_.kind_.depth_multisampled_texture_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeDepthMultisampledTexture>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeDepthMultisampledTexture*>(_impl_.kind_.depth_multisampled_texture_);
}
inline ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* PROTOBUF_NONNULL Type::mutable_depth_multisampled_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeDepthMultisampledTexture* _msg = _internal_mutable_depth_multisampled_texture();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.depth_multisampled_texture)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeStorageTexture storage_texture = 12;
inline bool Type::has_storage_texture() const {
  return kind_case() == kStorageTexture;
}
inline bool Type::_internal_has_storage_texture() const {
  return kind_case() == kStorageTexture;
}
inline void Type::set_has_storage_texture() {
  _impl_._oneof_case_[0] = kStorageTexture;
}
inline void Type::clear_storage_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStorageTexture) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.storage_texture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.storage_texture_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE Type::release_storage_texture() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.storage_texture)
  if (kind_case() == kStorageTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeStorageTexture*>(_impl_.kind_.storage_texture_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.storage_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeStorageTexture& Type::_internal_storage_texture() const {
  return kind_case() == kStorageTexture ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeStorageTexture*>(_impl_.kind_.storage_texture_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeStorageTexture&>(::tint::core::ir::binary::pb::_TypeStorageTexture_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeStorageTexture& Type::storage_texture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.storage_texture)
  return _internal_storage_texture();
}
inline ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE Type::unsafe_arena_release_storage_texture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.storage_texture)
  if (kind_case() == kStorageTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeStorageTexture*>(_impl_.kind_.storage_texture_);
    _impl_.kind_.storage_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_storage_texture(
    ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_storage_texture();
    _impl_.kind_.storage_texture_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.storage_texture)
}
inline ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NONNULL Type::_internal_mutable_storage_texture() {
  if (kind_case() != kStorageTexture) {
    clear_kind();
    set_has_storage_texture();
    _impl_.kind_.storage_texture_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeStorageTexture>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeStorageTexture*>(_impl_.kind_.storage_texture_);
}
inline ::tint::core::ir::binary::pb::TypeStorageTexture* PROTOBUF_NONNULL Type::mutable_storage_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeStorageTexture* _msg = _internal_mutable_storage_texture();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.storage_texture)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeExternalTexture external_texture = 13;
inline bool Type::has_external_texture() const {
  return kind_case() == kExternalTexture;
}
inline bool Type::_internal_has_external_texture() const {
  return kind_case() == kExternalTexture;
}
inline void Type::set_has_external_texture() {
  _impl_._oneof_case_[0] = kExternalTexture;
}
inline void Type::clear_external_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kExternalTexture) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.external_texture_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.external_texture_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE Type::release_external_texture() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.external_texture)
  if (kind_case() == kExternalTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeExternalTexture*>(_impl_.kind_.external_texture_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.external_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeExternalTexture& Type::_internal_external_texture() const {
  return kind_case() == kExternalTexture ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeExternalTexture*>(_impl_.kind_.external_texture_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeExternalTexture&>(::tint::core::ir::binary::pb::_TypeExternalTexture_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeExternalTexture& Type::external_texture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.external_texture)
  return _internal_external_texture();
}
inline ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE Type::unsafe_arena_release_external_texture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.external_texture)
  if (kind_case() == kExternalTexture) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeExternalTexture*>(_impl_.kind_.external_texture_);
    _impl_.kind_.external_texture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_external_texture(
    ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_external_texture();
    _impl_.kind_.external_texture_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.external_texture)
}
inline ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NONNULL Type::_internal_mutable_external_texture() {
  if (kind_case() != kExternalTexture) {
    clear_kind();
    set_has_external_texture();
    _impl_.kind_.external_texture_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeExternalTexture>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeExternalTexture*>(_impl_.kind_.external_texture_);
}
inline ::tint::core::ir::binary::pb::TypeExternalTexture* PROTOBUF_NONNULL Type::mutable_external_texture()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeExternalTexture* _msg = _internal_mutable_external_texture();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.external_texture)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeSampler sampler = 14;
inline bool Type::has_sampler() const {
  return kind_case() == kSampler;
}
inline bool Type::_internal_has_sampler() const {
  return kind_case() == kSampler;
}
inline void Type::set_has_sampler() {
  _impl_._oneof_case_[0] = kSampler;
}
inline void Type::clear_sampler() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSampler) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.sampler_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.sampler_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE Type::release_sampler() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.sampler)
  if (kind_case() == kSampler) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSampler*>(_impl_.kind_.sampler_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.sampler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeSampler& Type::_internal_sampler() const {
  return kind_case() == kSampler ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeSampler*>(_impl_.kind_.sampler_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeSampler&>(::tint::core::ir::binary::pb::_TypeSampler_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeSampler& Type::sampler() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.sampler)
  return _internal_sampler();
}
inline ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE Type::unsafe_arena_release_sampler() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.sampler)
  if (kind_case() == kSampler) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSampler*>(_impl_.kind_.sampler_);
    _impl_.kind_.sampler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_sampler(
    ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_sampler();
    _impl_.kind_.sampler_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.sampler)
}
inline ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NONNULL Type::_internal_mutable_sampler() {
  if (kind_case() != kSampler) {
    clear_kind();
    set_has_sampler();
    _impl_.kind_.sampler_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeSampler>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeSampler*>(_impl_.kind_.sampler_);
}
inline ::tint::core::ir::binary::pb::TypeSampler* PROTOBUF_NONNULL Type::mutable_sampler()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeSampler* _msg = _internal_mutable_sampler();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.sampler)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeInputAttachment input_attachment = 15;
inline bool Type::has_input_attachment() const {
  return kind_case() == kInputAttachment;
}
inline bool Type::_internal_has_input_attachment() const {
  return kind_case() == kInputAttachment;
}
inline void Type::set_has_input_attachment() {
  _impl_._oneof_case_[0] = kInputAttachment;
}
inline void Type::clear_input_attachment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kInputAttachment) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.input_attachment_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.input_attachment_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE Type::release_input_attachment() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.input_attachment)
  if (kind_case() == kInputAttachment) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeInputAttachment*>(_impl_.kind_.input_attachment_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.input_attachment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeInputAttachment& Type::_internal_input_attachment() const {
  return kind_case() == kInputAttachment ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeInputAttachment*>(_impl_.kind_.input_attachment_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeInputAttachment&>(::tint::core::ir::binary::pb::_TypeInputAttachment_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeInputAttachment& Type::input_attachment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.input_attachment)
  return _internal_input_attachment();
}
inline ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE Type::unsafe_arena_release_input_attachment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.input_attachment)
  if (kind_case() == kInputAttachment) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeInputAttachment*>(_impl_.kind_.input_attachment_);
    _impl_.kind_.input_attachment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_input_attachment(
    ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_input_attachment();
    _impl_.kind_.input_attachment_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.input_attachment)
}
inline ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NONNULL Type::_internal_mutable_input_attachment() {
  if (kind_case() != kInputAttachment) {
    clear_kind();
    set_has_input_attachment();
    _impl_.kind_.input_attachment_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeInputAttachment>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeInputAttachment*>(_impl_.kind_.input_attachment_);
}
inline ::tint::core::ir::binary::pb::TypeInputAttachment* PROTOBUF_NONNULL Type::mutable_input_attachment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeInputAttachment* _msg = _internal_mutable_input_attachment();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.input_attachment)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeSubgroupMatrix subgroup_matrix_left = 16;
inline bool Type::has_subgroup_matrix_left() const {
  return kind_case() == kSubgroupMatrixLeft;
}
inline bool Type::_internal_has_subgroup_matrix_left() const {
  return kind_case() == kSubgroupMatrixLeft;
}
inline void Type::set_has_subgroup_matrix_left() {
  _impl_._oneof_case_[0] = kSubgroupMatrixLeft;
}
inline void Type::clear_subgroup_matrix_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSubgroupMatrixLeft) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.subgroup_matrix_left_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.subgroup_matrix_left_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE Type::release_subgroup_matrix_left() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.subgroup_matrix_left)
  if (kind_case() == kSubgroupMatrixLeft) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_left_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.subgroup_matrix_left_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& Type::_internal_subgroup_matrix_left() const {
  return kind_case() == kSubgroupMatrixLeft ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_left_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix&>(::tint::core::ir::binary::pb::_TypeSubgroupMatrix_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& Type::subgroup_matrix_left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.subgroup_matrix_left)
  return _internal_subgroup_matrix_left();
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE Type::unsafe_arena_release_subgroup_matrix_left() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.subgroup_matrix_left)
  if (kind_case() == kSubgroupMatrixLeft) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_left_);
    _impl_.kind_.subgroup_matrix_left_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_subgroup_matrix_left(
    ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_subgroup_matrix_left();
    _impl_.kind_.subgroup_matrix_left_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.subgroup_matrix_left)
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL Type::_internal_mutable_subgroup_matrix_left() {
  if (kind_case() != kSubgroupMatrixLeft) {
    clear_kind();
    set_has_subgroup_matrix_left();
    _impl_.kind_.subgroup_matrix_left_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeSubgroupMatrix>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_left_);
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL Type::mutable_subgroup_matrix_left()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* _msg = _internal_mutable_subgroup_matrix_left();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.subgroup_matrix_left)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeSubgroupMatrix subgroup_matrix_right = 17;
inline bool Type::has_subgroup_matrix_right() const {
  return kind_case() == kSubgroupMatrixRight;
}
inline bool Type::_internal_has_subgroup_matrix_right() const {
  return kind_case() == kSubgroupMatrixRight;
}
inline void Type::set_has_subgroup_matrix_right() {
  _impl_._oneof_case_[0] = kSubgroupMatrixRight;
}
inline void Type::clear_subgroup_matrix_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSubgroupMatrixRight) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.subgroup_matrix_right_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.subgroup_matrix_right_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE Type::release_subgroup_matrix_right() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.subgroup_matrix_right)
  if (kind_case() == kSubgroupMatrixRight) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_right_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.subgroup_matrix_right_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& Type::_internal_subgroup_matrix_right() const {
  return kind_case() == kSubgroupMatrixRight ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_right_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix&>(::tint::core::ir::binary::pb::_TypeSubgroupMatrix_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& Type::subgroup_matrix_right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.subgroup_matrix_right)
  return _internal_subgroup_matrix_right();
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE Type::unsafe_arena_release_subgroup_matrix_right() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.subgroup_matrix_right)
  if (kind_case() == kSubgroupMatrixRight) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_right_);
    _impl_.kind_.subgroup_matrix_right_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_subgroup_matrix_right(
    ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_subgroup_matrix_right();
    _impl_.kind_.subgroup_matrix_right_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.subgroup_matrix_right)
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL Type::_internal_mutable_subgroup_matrix_right() {
  if (kind_case() != kSubgroupMatrixRight) {
    clear_kind();
    set_has_subgroup_matrix_right();
    _impl_.kind_.subgroup_matrix_right_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeSubgroupMatrix>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_right_);
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL Type::mutable_subgroup_matrix_right()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* _msg = _internal_mutable_subgroup_matrix_right();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.subgroup_matrix_right)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeSubgroupMatrix subgroup_matrix_result = 18;
inline bool Type::has_subgroup_matrix_result() const {
  return kind_case() == kSubgroupMatrixResult;
}
inline bool Type::_internal_has_subgroup_matrix_result() const {
  return kind_case() == kSubgroupMatrixResult;
}
inline void Type::set_has_subgroup_matrix_result() {
  _impl_._oneof_case_[0] = kSubgroupMatrixResult;
}
inline void Type::clear_subgroup_matrix_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSubgroupMatrixResult) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.subgroup_matrix_result_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.subgroup_matrix_result_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE Type::release_subgroup_matrix_result() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.subgroup_matrix_result)
  if (kind_case() == kSubgroupMatrixResult) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_result_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.subgroup_matrix_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& Type::_internal_subgroup_matrix_result() const {
  return kind_case() == kSubgroupMatrixResult ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_result_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix&>(::tint::core::ir::binary::pb::_TypeSubgroupMatrix_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeSubgroupMatrix& Type::subgroup_matrix_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.subgroup_matrix_result)
  return _internal_subgroup_matrix_result();
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE Type::unsafe_arena_release_subgroup_matrix_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.subgroup_matrix_result)
  if (kind_case() == kSubgroupMatrixResult) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_result_);
    _impl_.kind_.subgroup_matrix_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_subgroup_matrix_result(
    ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_subgroup_matrix_result();
    _impl_.kind_.subgroup_matrix_result_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.subgroup_matrix_result)
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL Type::_internal_mutable_subgroup_matrix_result() {
  if (kind_case() != kSubgroupMatrixResult) {
    clear_kind();
    set_has_subgroup_matrix_result();
    _impl_.kind_.subgroup_matrix_result_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeSubgroupMatrix>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeSubgroupMatrix*>(_impl_.kind_.subgroup_matrix_result_);
}
inline ::tint::core::ir::binary::pb::TypeSubgroupMatrix* PROTOBUF_NONNULL Type::mutable_subgroup_matrix_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeSubgroupMatrix* _msg = _internal_mutable_subgroup_matrix_result();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.subgroup_matrix_result)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeBuiltinStruct builtin_struct = 19;
inline bool Type::has_builtin_struct() const {
  return kind_case() == kBuiltinStruct;
}
inline void Type::set_has_builtin_struct() {
  _impl_._oneof_case_[0] = kBuiltinStruct;
}
inline void Type::clear_builtin_struct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBuiltinStruct) {
    _impl_.kind_.builtin_struct_ = 0;
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeBuiltinStruct Type::builtin_struct() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.builtin_struct)
  return _internal_builtin_struct();
}
inline void Type::set_builtin_struct(::tint::core::ir::binary::pb::TypeBuiltinStruct value) {
  if (kind_case() != kBuiltinStruct) {
    clear_kind();
    set_has_builtin_struct();
  }
  _impl_.kind_.builtin_struct_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Type.builtin_struct)
}
inline ::tint::core::ir::binary::pb::TypeBuiltinStruct Type::_internal_builtin_struct() const {
  if (kind_case() == kBuiltinStruct) {
    return static_cast<::tint::core::ir::binary::pb::TypeBuiltinStruct>(_impl_.kind_.builtin_struct_);
  }
  return static_cast<::tint::core::ir::binary::pb::TypeBuiltinStruct>(0);
}

// .tint.core.ir.binary.pb.TypeBindingArray binding_array = 20;
inline bool Type::has_binding_array() const {
  return kind_case() == kBindingArray;
}
inline bool Type::_internal_has_binding_array() const {
  return kind_case() == kBindingArray;
}
inline void Type::set_has_binding_array() {
  _impl_._oneof_case_[0] = kBindingArray;
}
inline void Type::clear_binding_array() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBindingArray) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.binding_array_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.binding_array_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE Type::release_binding_array() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.binding_array)
  if (kind_case() == kBindingArray) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeBindingArray*>(_impl_.kind_.binding_array_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.binding_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeBindingArray& Type::_internal_binding_array() const {
  return kind_case() == kBindingArray ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeBindingArray*>(_impl_.kind_.binding_array_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeBindingArray&>(::tint::core::ir::binary::pb::_TypeBindingArray_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeBindingArray& Type::binding_array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.binding_array)
  return _internal_binding_array();
}
inline ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE Type::unsafe_arena_release_binding_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.binding_array)
  if (kind_case() == kBindingArray) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeBindingArray*>(_impl_.kind_.binding_array_);
    _impl_.kind_.binding_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_binding_array(
    ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_binding_array();
    _impl_.kind_.binding_array_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.binding_array)
}
inline ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NONNULL Type::_internal_mutable_binding_array() {
  if (kind_case() != kBindingArray) {
    clear_kind();
    set_has_binding_array();
    _impl_.kind_.binding_array_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeBindingArray>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeBindingArray*>(_impl_.kind_.binding_array_);
}
inline ::tint::core::ir::binary::pb::TypeBindingArray* PROTOBUF_NONNULL Type::mutable_binding_array()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeBindingArray* _msg = _internal_mutable_binding_array();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.binding_array)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeTexelBuffer texel_buffer = 21;
inline bool Type::has_texel_buffer() const {
  return kind_case() == kTexelBuffer;
}
inline bool Type::_internal_has_texel_buffer() const {
  return kind_case() == kTexelBuffer;
}
inline void Type::set_has_texel_buffer() {
  _impl_._oneof_case_[0] = kTexelBuffer;
}
inline void Type::clear_texel_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTexelBuffer) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.texel_buffer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.texel_buffer_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE Type::release_texel_buffer() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.texel_buffer)
  if (kind_case() == kTexelBuffer) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeTexelBuffer*>(_impl_.kind_.texel_buffer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.texel_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeTexelBuffer& Type::_internal_texel_buffer() const {
  return kind_case() == kTexelBuffer ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeTexelBuffer*>(_impl_.kind_.texel_buffer_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeTexelBuffer&>(::tint::core::ir::binary::pb::_TypeTexelBuffer_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeTexelBuffer& Type::texel_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.texel_buffer)
  return _internal_texel_buffer();
}
inline ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE Type::unsafe_arena_release_texel_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.texel_buffer)
  if (kind_case() == kTexelBuffer) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeTexelBuffer*>(_impl_.kind_.texel_buffer_);
    _impl_.kind_.texel_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_texel_buffer(
    ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_texel_buffer();
    _impl_.kind_.texel_buffer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.texel_buffer)
}
inline ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NONNULL Type::_internal_mutable_texel_buffer() {
  if (kind_case() != kTexelBuffer) {
    clear_kind();
    set_has_texel_buffer();
    _impl_.kind_.texel_buffer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeTexelBuffer>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeTexelBuffer*>(_impl_.kind_.texel_buffer_);
}
inline ::tint::core::ir::binary::pb::TypeTexelBuffer* PROTOBUF_NONNULL Type::mutable_texel_buffer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeTexelBuffer* _msg = _internal_mutable_texel_buffer();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.texel_buffer)
  return _msg;
}

// .tint.core.ir.binary.pb.TypeBuffer buffer = 23;
inline bool Type::has_buffer() const {
  return kind_case() == kBuffer;
}
inline bool Type::_internal_has_buffer() const {
  return kind_case() == kBuffer;
}
inline void Type::set_has_buffer() {
  _impl_._oneof_case_[0] = kBuffer;
}
inline void Type::clear_buffer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBuffer) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.buffer_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.buffer_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE Type::release_buffer() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Type.buffer)
  if (kind_case() == kBuffer) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeBuffer*>(_impl_.kind_.buffer_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::TypeBuffer& Type::_internal_buffer() const {
  return kind_case() == kBuffer ? *reinterpret_cast<::tint::core::ir::binary::pb::TypeBuffer*>(_impl_.kind_.buffer_) : reinterpret_cast<::tint::core::ir::binary::pb::TypeBuffer&>(::tint::core::ir::binary::pb::_TypeBuffer_default_instance_);
}
inline const ::tint::core::ir::binary::pb::TypeBuffer& Type::buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Type.buffer)
  return _internal_buffer();
}
inline ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE Type::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Type.buffer)
  if (kind_case() == kBuffer) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::TypeBuffer*>(_impl_.kind_.buffer_);
    _impl_.kind_.buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Type::unsafe_arena_set_allocated_buffer(
    ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_buffer();
    _impl_.kind_.buffer_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Type.buffer)
}
inline ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NONNULL Type::_internal_mutable_buffer() {
  if (kind_case() != kBuffer) {
    clear_kind();
    set_has_buffer();
    _impl_.kind_.buffer_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::TypeBuffer>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::TypeBuffer*>(_impl_.kind_.buffer_);
}
inline ::tint::core::ir::binary::pb::TypeBuffer* PROTOBUF_NONNULL Type::mutable_buffer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::TypeBuffer* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Type.buffer)
  return _msg;
}

inline bool Type::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Type::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Type::KindCase Type::kind_case() const {
  return Type::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TypeVector

// uint32 width = 1;
inline void TypeVector::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeVector::width() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeVector.width)
  return _internal_width();
}
inline void TypeVector::set_width(::uint32_t value) {
  _internal_set_width(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeVector.width)
}
inline ::uint32_t TypeVector::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void TypeVector::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 element_type = 2;
inline void TypeVector::clear_element_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeVector::element_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeVector.element_type)
  return _internal_element_type();
}
inline void TypeVector::set_element_type(::uint32_t value) {
  _internal_set_element_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeVector.element_type)
}
inline ::uint32_t TypeVector::_internal_element_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.element_type_;
}
inline void TypeVector::_internal_set_element_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_type_ = value;
}

// -------------------------------------------------------------------

// TypeMatrix

// uint32 num_columns = 1;
inline void TypeMatrix::clear_num_columns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_columns_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeMatrix::num_columns() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeMatrix.num_columns)
  return _internal_num_columns();
}
inline void TypeMatrix::set_num_columns(::uint32_t value) {
  _internal_set_num_columns(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeMatrix.num_columns)
}
inline ::uint32_t TypeMatrix::_internal_num_columns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_columns_;
}
inline void TypeMatrix::_internal_set_num_columns(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_columns_ = value;
}

// uint32 num_rows = 2;
inline void TypeMatrix::clear_num_rows() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeMatrix::num_rows() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeMatrix.num_rows)
  return _internal_num_rows();
}
inline void TypeMatrix::set_num_rows(::uint32_t value) {
  _internal_set_num_rows(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeMatrix.num_rows)
}
inline ::uint32_t TypeMatrix::_internal_num_rows() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_rows_;
}
inline void TypeMatrix::_internal_set_num_rows(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_rows_ = value;
}

// uint32 element_type = 3;
inline void TypeMatrix::clear_element_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t TypeMatrix::element_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeMatrix.element_type)
  return _internal_element_type();
}
inline void TypeMatrix::set_element_type(::uint32_t value) {
  _internal_set_element_type(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeMatrix.element_type)
}
inline ::uint32_t TypeMatrix::_internal_element_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.element_type_;
}
inline void TypeMatrix::_internal_set_element_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_type_ = value;
}

// -------------------------------------------------------------------

// TypeArray

// uint32 element = 1;
inline void TypeArray::clear_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeArray::element() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeArray.element)
  return _internal_element();
}
inline void TypeArray::set_element(::uint32_t value) {
  _internal_set_element(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeArray.element)
}
inline ::uint32_t TypeArray::_internal_element() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.element_;
}
inline void TypeArray::_internal_set_element(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_ = value;
}

// uint32 count = 3;
inline void TypeArray::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeArray::count() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeArray.count)
  return _internal_count();
}
inline void TypeArray::set_count(::uint32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeArray.count)
}
inline ::uint32_t TypeArray::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void TypeArray::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TypeBindingArray

// uint32 element = 1;
inline void TypeBindingArray::clear_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeBindingArray::element() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeBindingArray.element)
  return _internal_element();
}
inline void TypeBindingArray::set_element(::uint32_t value) {
  _internal_set_element(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeBindingArray.element)
}
inline ::uint32_t TypeBindingArray::_internal_element() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.element_;
}
inline void TypeBindingArray::_internal_set_element(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.element_ = value;
}

// uint32 count = 2;
inline void TypeBindingArray::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeBindingArray::count() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeBindingArray.count)
  return _internal_count();
}
inline void TypeBindingArray::set_count(::uint32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeBindingArray.count)
}
inline ::uint32_t TypeBindingArray::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void TypeBindingArray::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TypePointer

// .tint.core.ir.binary.pb.AddressSpace address_space = 1;
inline void TypePointer::clear_address_space() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_space_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::AddressSpace TypePointer::address_space() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypePointer.address_space)
  return _internal_address_space();
}
inline void TypePointer::set_address_space(::tint::core::ir::binary::pb::AddressSpace value) {
  _internal_set_address_space(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypePointer.address_space)
}
inline ::tint::core::ir::binary::pb::AddressSpace TypePointer::_internal_address_space() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::AddressSpace>(_impl_.address_space_);
}
inline void TypePointer::_internal_set_address_space(::tint::core::ir::binary::pb::AddressSpace value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_space_ = value;
}

// uint32 store_type = 2;
inline void TypePointer::clear_store_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.store_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypePointer::store_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypePointer.store_type)
  return _internal_store_type();
}
inline void TypePointer::set_store_type(::uint32_t value) {
  _internal_set_store_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypePointer.store_type)
}
inline ::uint32_t TypePointer::_internal_store_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.store_type_;
}
inline void TypePointer::_internal_set_store_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.store_type_ = value;
}

// .tint.core.ir.binary.pb.AccessControl access = 3;
inline void TypePointer::clear_access() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::tint::core::ir::binary::pb::AccessControl TypePointer::access() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypePointer.access)
  return _internal_access();
}
inline void TypePointer::set_access(::tint::core::ir::binary::pb::AccessControl value) {
  _internal_set_access(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypePointer.access)
}
inline ::tint::core::ir::binary::pb::AccessControl TypePointer::_internal_access() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::AccessControl>(_impl_.access_);
}
inline void TypePointer::_internal_set_access(::tint::core::ir::binary::pb::AccessControl value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_ = value;
}

// -------------------------------------------------------------------

// TypeStruct

// string name = 1;
inline void TypeStruct::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& TypeStruct::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStruct.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TypeStruct::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStruct.name)
}
inline ::std::string* PROTOBUF_NONNULL TypeStruct::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.TypeStruct.name)
  return _s;
}
inline const ::std::string& TypeStruct::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void TypeStruct::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TypeStruct::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TypeStruct::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.TypeStruct.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void TypeStruct::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.TypeStruct.name)
}

// repeated .tint.core.ir.binary.pb.TypeStructMember member = 2;
inline int TypeStruct::_internal_member_size() const {
  return _internal_member().size();
}
inline int TypeStruct::member_size() const {
  return _internal_member_size();
}
inline void TypeStruct::clear_member() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.member_.Clear();
}
inline ::tint::core::ir::binary::pb::TypeStructMember* PROTOBUF_NONNULL TypeStruct::mutable_member(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.TypeStruct.member)
  return _internal_mutable_member()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>* PROTOBUF_NONNULL TypeStruct::mutable_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.TypeStruct.member)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_member();
}
inline const ::tint::core::ir::binary::pb::TypeStructMember& TypeStruct::member(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStruct.member)
  return _internal_member().Get(index);
}
inline ::tint::core::ir::binary::pb::TypeStructMember* PROTOBUF_NONNULL TypeStruct::add_member()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::TypeStructMember* _add = _internal_mutable_member()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.TypeStruct.member)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>& TypeStruct::member() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.TypeStruct.member)
  return _internal_member();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>&
TypeStruct::_internal_member() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.member_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::TypeStructMember>* PROTOBUF_NONNULL
TypeStruct::_internal_mutable_member() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.member_;
}

// -------------------------------------------------------------------

// TypeStructMember

// string name = 1;
inline void TypeStructMember::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& TypeStructMember::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStructMember.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TypeStructMember::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStructMember.name)
}
inline ::std::string* PROTOBUF_NONNULL TypeStructMember::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.TypeStructMember.name)
  return _s;
}
inline const ::std::string& TypeStructMember::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void TypeStructMember::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TypeStructMember::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TypeStructMember::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.TypeStructMember.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void TypeStructMember::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.TypeStructMember.name)
}

// uint32 type = 2;
inline void TypeStructMember::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t TypeStructMember::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStructMember.type)
  return _internal_type();
}
inline void TypeStructMember::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStructMember.type)
}
inline ::uint32_t TypeStructMember::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void TypeStructMember::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// uint32 size = 3;
inline void TypeStructMember::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t TypeStructMember::size() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStructMember.size)
  return _internal_size();
}
inline void TypeStructMember::set_size(::uint32_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStructMember.size)
}
inline ::uint32_t TypeStructMember::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void TypeStructMember::_internal_set_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// uint32 align = 4;
inline void TypeStructMember::clear_align() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.align_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::uint32_t TypeStructMember::align() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStructMember.align)
  return _internal_align();
}
inline void TypeStructMember::set_align(::uint32_t value) {
  _internal_set_align(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStructMember.align)
}
inline ::uint32_t TypeStructMember::_internal_align() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.align_;
}
inline void TypeStructMember::_internal_set_align(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.align_ = value;
}

// optional .tint.core.ir.binary.pb.AttributesStructMember attributes = 5;
inline bool TypeStructMember::has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attributes_ != nullptr);
  return value;
}
inline void TypeStructMember::clear_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attributes_ != nullptr) _impl_.attributes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::tint::core::ir::binary::pb::AttributesStructMember& TypeStructMember::_internal_attributes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::AttributesStructMember* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::AttributesStructMember&>(::tint::core::ir::binary::pb::_AttributesStructMember_default_instance_);
}
inline const ::tint::core::ir::binary::pb::AttributesStructMember& TypeStructMember::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStructMember.attributes)
  return _internal_attributes();
}
inline void TypeStructMember::unsafe_arena_set_allocated_attributes(
    ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = reinterpret_cast<::tint::core::ir::binary::pb::AttributesStructMember*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.TypeStructMember.attributes)
}
inline ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE TypeStructMember::release_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::AttributesStructMember* released = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE TypeStructMember::unsafe_arena_release_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.TypeStructMember.attributes)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::AttributesStructMember* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NONNULL TypeStructMember::_internal_mutable_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attributes_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::AttributesStructMember>(GetArena());
    _impl_.attributes_ = reinterpret_cast<::tint::core::ir::binary::pb::AttributesStructMember*>(p);
  }
  return _impl_.attributes_;
}
inline ::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NONNULL TypeStructMember::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::tint::core::ir::binary::pb::AttributesStructMember* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.TypeStructMember.attributes)
  return _msg;
}
inline void TypeStructMember::set_allocated_attributes(::tint::core::ir::binary::pb::AttributesStructMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.attributes_ = reinterpret_cast<::tint::core::ir::binary::pb::AttributesStructMember*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.TypeStructMember.attributes)
}

// -------------------------------------------------------------------

// TypeAtomic

// uint32 type = 1;
inline void TypeAtomic::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeAtomic::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeAtomic.type)
  return _internal_type();
}
inline void TypeAtomic::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeAtomic.type)
}
inline ::uint32_t TypeAtomic::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void TypeAtomic::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// TypeDepthTexture

// .tint.core.ir.binary.pb.TextureDimension dimension = 1;
inline void TypeDepthTexture::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeDepthTexture::dimension() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeDepthTexture.dimension)
  return _internal_dimension();
}
inline void TypeDepthTexture::set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  _internal_set_dimension(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeDepthTexture.dimension)
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeDepthTexture::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TextureDimension>(_impl_.dimension_);
}
inline void TypeDepthTexture::_internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = value;
}

// -------------------------------------------------------------------

// TypeSampledTexture

// .tint.core.ir.binary.pb.TextureDimension dimension = 1;
inline void TypeSampledTexture::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeSampledTexture::dimension() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeSampledTexture.dimension)
  return _internal_dimension();
}
inline void TypeSampledTexture::set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  _internal_set_dimension(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeSampledTexture.dimension)
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeSampledTexture::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TextureDimension>(_impl_.dimension_);
}
inline void TypeSampledTexture::_internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = value;
}

// uint32 sub_type = 2;
inline void TypeSampledTexture::clear_sub_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeSampledTexture::sub_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeSampledTexture.sub_type)
  return _internal_sub_type();
}
inline void TypeSampledTexture::set_sub_type(::uint32_t value) {
  _internal_set_sub_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeSampledTexture.sub_type)
}
inline ::uint32_t TypeSampledTexture::_internal_sub_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_type_;
}
inline void TypeSampledTexture::_internal_set_sub_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = value;
}

// -------------------------------------------------------------------

// TypeMultisampledTexture

// .tint.core.ir.binary.pb.TextureDimension dimension = 1;
inline void TypeMultisampledTexture::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeMultisampledTexture::dimension() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeMultisampledTexture.dimension)
  return _internal_dimension();
}
inline void TypeMultisampledTexture::set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  _internal_set_dimension(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeMultisampledTexture.dimension)
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeMultisampledTexture::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TextureDimension>(_impl_.dimension_);
}
inline void TypeMultisampledTexture::_internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = value;
}

// uint32 sub_type = 2;
inline void TypeMultisampledTexture::clear_sub_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeMultisampledTexture::sub_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeMultisampledTexture.sub_type)
  return _internal_sub_type();
}
inline void TypeMultisampledTexture::set_sub_type(::uint32_t value) {
  _internal_set_sub_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeMultisampledTexture.sub_type)
}
inline ::uint32_t TypeMultisampledTexture::_internal_sub_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_type_;
}
inline void TypeMultisampledTexture::_internal_set_sub_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = value;
}

// -------------------------------------------------------------------

// TypeDepthMultisampledTexture

// .tint.core.ir.binary.pb.TextureDimension dimension = 1;
inline void TypeDepthMultisampledTexture::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeDepthMultisampledTexture::dimension() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeDepthMultisampledTexture.dimension)
  return _internal_dimension();
}
inline void TypeDepthMultisampledTexture::set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  _internal_set_dimension(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeDepthMultisampledTexture.dimension)
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeDepthMultisampledTexture::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TextureDimension>(_impl_.dimension_);
}
inline void TypeDepthMultisampledTexture::_internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = value;
}

// -------------------------------------------------------------------

// TypeStorageTexture

// .tint.core.ir.binary.pb.TextureDimension dimension = 1;
inline void TypeStorageTexture::clear_dimension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeStorageTexture::dimension() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStorageTexture.dimension)
  return _internal_dimension();
}
inline void TypeStorageTexture::set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  _internal_set_dimension(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStorageTexture.dimension)
}
inline ::tint::core::ir::binary::pb::TextureDimension TypeStorageTexture::_internal_dimension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TextureDimension>(_impl_.dimension_);
}
inline void TypeStorageTexture::_internal_set_dimension(::tint::core::ir::binary::pb::TextureDimension value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimension_ = value;
}

// .tint.core.ir.binary.pb.TexelFormat texel_format = 2;
inline void TypeStorageTexture::clear_texel_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texel_format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::tint::core::ir::binary::pb::TexelFormat TypeStorageTexture::texel_format() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStorageTexture.texel_format)
  return _internal_texel_format();
}
inline void TypeStorageTexture::set_texel_format(::tint::core::ir::binary::pb::TexelFormat value) {
  _internal_set_texel_format(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStorageTexture.texel_format)
}
inline ::tint::core::ir::binary::pb::TexelFormat TypeStorageTexture::_internal_texel_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TexelFormat>(_impl_.texel_format_);
}
inline void TypeStorageTexture::_internal_set_texel_format(::tint::core::ir::binary::pb::TexelFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texel_format_ = value;
}

// .tint.core.ir.binary.pb.AccessControl access = 3;
inline void TypeStorageTexture::clear_access() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::tint::core::ir::binary::pb::AccessControl TypeStorageTexture::access() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeStorageTexture.access)
  return _internal_access();
}
inline void TypeStorageTexture::set_access(::tint::core::ir::binary::pb::AccessControl value) {
  _internal_set_access(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeStorageTexture.access)
}
inline ::tint::core::ir::binary::pb::AccessControl TypeStorageTexture::_internal_access() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::AccessControl>(_impl_.access_);
}
inline void TypeStorageTexture::_internal_set_access(::tint::core::ir::binary::pb::AccessControl value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_ = value;
}

// -------------------------------------------------------------------

// TypeResourceBinding

// -------------------------------------------------------------------

// TypeExternalTexture

// -------------------------------------------------------------------

// TypeSampler

// .tint.core.ir.binary.pb.SamplerKind kind = 1;
inline void TypeSampler::clear_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::SamplerKind TypeSampler::kind() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeSampler.kind)
  return _internal_kind();
}
inline void TypeSampler::set_kind(::tint::core::ir::binary::pb::SamplerKind value) {
  _internal_set_kind(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeSampler.kind)
}
inline ::tint::core::ir::binary::pb::SamplerKind TypeSampler::_internal_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::SamplerKind>(_impl_.kind_);
}
inline void TypeSampler::_internal_set_kind(::tint::core::ir::binary::pb::SamplerKind value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_ = value;
}

// -------------------------------------------------------------------

// TypeInputAttachment

// uint32 sub_type = 1;
inline void TypeInputAttachment::clear_sub_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeInputAttachment::sub_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeInputAttachment.sub_type)
  return _internal_sub_type();
}
inline void TypeInputAttachment::set_sub_type(::uint32_t value) {
  _internal_set_sub_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeInputAttachment.sub_type)
}
inline ::uint32_t TypeInputAttachment::_internal_sub_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_type_;
}
inline void TypeInputAttachment::_internal_set_sub_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = value;
}

// -------------------------------------------------------------------

// TypeSubgroupMatrix

// uint32 sub_type = 1;
inline void TypeSubgroupMatrix::clear_sub_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeSubgroupMatrix::sub_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeSubgroupMatrix.sub_type)
  return _internal_sub_type();
}
inline void TypeSubgroupMatrix::set_sub_type(::uint32_t value) {
  _internal_set_sub_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeSubgroupMatrix.sub_type)
}
inline ::uint32_t TypeSubgroupMatrix::_internal_sub_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sub_type_;
}
inline void TypeSubgroupMatrix::_internal_set_sub_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sub_type_ = value;
}

// uint32 rows = 2;
inline void TypeSubgroupMatrix::clear_rows() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t TypeSubgroupMatrix::rows() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeSubgroupMatrix.rows)
  return _internal_rows();
}
inline void TypeSubgroupMatrix::set_rows(::uint32_t value) {
  _internal_set_rows(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeSubgroupMatrix.rows)
}
inline ::uint32_t TypeSubgroupMatrix::_internal_rows() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rows_;
}
inline void TypeSubgroupMatrix::_internal_set_rows(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rows_ = value;
}

// uint32 columns = 3;
inline void TypeSubgroupMatrix::clear_columns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.columns_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t TypeSubgroupMatrix::columns() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeSubgroupMatrix.columns)
  return _internal_columns();
}
inline void TypeSubgroupMatrix::set_columns(::uint32_t value) {
  _internal_set_columns(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeSubgroupMatrix.columns)
}
inline ::uint32_t TypeSubgroupMatrix::_internal_columns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.columns_;
}
inline void TypeSubgroupMatrix::_internal_set_columns(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.columns_ = value;
}

// -------------------------------------------------------------------

// TypeBuffer

// uint32 count = 1;
inline void TypeBuffer::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t TypeBuffer::count() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeBuffer.count)
  return _internal_count();
}
inline void TypeBuffer::set_count(::uint32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeBuffer.count)
}
inline ::uint32_t TypeBuffer::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void TypeBuffer::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// TypeTexelBuffer

// .tint.core.ir.binary.pb.TexelFormat texel_format = 1;
inline void TypeTexelBuffer::clear_texel_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texel_format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::TexelFormat TypeTexelBuffer::texel_format() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeTexelBuffer.texel_format)
  return _internal_texel_format();
}
inline void TypeTexelBuffer::set_texel_format(::tint::core::ir::binary::pb::TexelFormat value) {
  _internal_set_texel_format(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeTexelBuffer.texel_format)
}
inline ::tint::core::ir::binary::pb::TexelFormat TypeTexelBuffer::_internal_texel_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::TexelFormat>(_impl_.texel_format_);
}
inline void TypeTexelBuffer::_internal_set_texel_format(::tint::core::ir::binary::pb::TexelFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.texel_format_ = value;
}

// .tint.core.ir.binary.pb.AccessControl access = 2;
inline void TypeTexelBuffer::clear_access() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::tint::core::ir::binary::pb::AccessControl TypeTexelBuffer::access() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.TypeTexelBuffer.access)
  return _internal_access();
}
inline void TypeTexelBuffer::set_access(::tint::core::ir::binary::pb::AccessControl value) {
  _internal_set_access(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.TypeTexelBuffer.access)
}
inline ::tint::core::ir::binary::pb::AccessControl TypeTexelBuffer::_internal_access() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::AccessControl>(_impl_.access_);
}
inline void TypeTexelBuffer::_internal_set_access(::tint::core::ir::binary::pb::AccessControl value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_ = value;
}

// -------------------------------------------------------------------

// Value

// uint32 function = 1;
inline bool Value::has_function() const {
  return kind_case() == kFunction;
}
inline void Value::set_has_function() {
  _impl_._oneof_case_[0] = kFunction;
}
inline void Value::clear_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kFunction) {
    _impl_.kind_.function_ = 0u;
    clear_has_kind();
  }
}
inline ::uint32_t Value::function() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Value.function)
  return _internal_function();
}
inline void Value::set_function(::uint32_t value) {
  if (kind_case() != kFunction) {
    clear_kind();
    set_has_function();
  }
  _impl_.kind_.function_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Value.function)
}
inline ::uint32_t Value::_internal_function() const {
  if (kind_case() == kFunction) {
    return _impl_.kind_.function_;
  }
  return 0u;
}

// .tint.core.ir.binary.pb.InstructionResult instruction_result = 2;
inline bool Value::has_instruction_result() const {
  return kind_case() == kInstructionResult;
}
inline bool Value::_internal_has_instruction_result() const {
  return kind_case() == kInstructionResult;
}
inline void Value::set_has_instruction_result() {
  _impl_._oneof_case_[0] = kInstructionResult;
}
inline void Value::clear_instruction_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kInstructionResult) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.instruction_result_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.instruction_result_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE Value::release_instruction_result() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Value.instruction_result)
  if (kind_case() == kInstructionResult) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionResult*>(_impl_.kind_.instruction_result_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.instruction_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionResult& Value::_internal_instruction_result() const {
  return kind_case() == kInstructionResult ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionResult*>(_impl_.kind_.instruction_result_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionResult&>(::tint::core::ir::binary::pb::_InstructionResult_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionResult& Value::instruction_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Value.instruction_result)
  return _internal_instruction_result();
}
inline ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE Value::unsafe_arena_release_instruction_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Value.instruction_result)
  if (kind_case() == kInstructionResult) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionResult*>(_impl_.kind_.instruction_result_);
    _impl_.kind_.instruction_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_instruction_result(
    ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_instruction_result();
    _impl_.kind_.instruction_result_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Value.instruction_result)
}
inline ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NONNULL Value::_internal_mutable_instruction_result() {
  if (kind_case() != kInstructionResult) {
    clear_kind();
    set_has_instruction_result();
    _impl_.kind_.instruction_result_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionResult>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionResult*>(_impl_.kind_.instruction_result_);
}
inline ::tint::core::ir::binary::pb::InstructionResult* PROTOBUF_NONNULL Value::mutable_instruction_result()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionResult* _msg = _internal_mutable_instruction_result();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Value.instruction_result)
  return _msg;
}

// .tint.core.ir.binary.pb.FunctionParameter function_parameter = 3;
inline bool Value::has_function_parameter() const {
  return kind_case() == kFunctionParameter;
}
inline bool Value::_internal_has_function_parameter() const {
  return kind_case() == kFunctionParameter;
}
inline void Value::set_has_function_parameter() {
  _impl_._oneof_case_[0] = kFunctionParameter;
}
inline void Value::clear_function_parameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kFunctionParameter) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.function_parameter_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.function_parameter_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE Value::release_function_parameter() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Value.function_parameter)
  if (kind_case() == kFunctionParameter) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::FunctionParameter*>(_impl_.kind_.function_parameter_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.function_parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::FunctionParameter& Value::_internal_function_parameter() const {
  return kind_case() == kFunctionParameter ? *reinterpret_cast<::tint::core::ir::binary::pb::FunctionParameter*>(_impl_.kind_.function_parameter_) : reinterpret_cast<::tint::core::ir::binary::pb::FunctionParameter&>(::tint::core::ir::binary::pb::_FunctionParameter_default_instance_);
}
inline const ::tint::core::ir::binary::pb::FunctionParameter& Value::function_parameter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Value.function_parameter)
  return _internal_function_parameter();
}
inline ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE Value::unsafe_arena_release_function_parameter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Value.function_parameter)
  if (kind_case() == kFunctionParameter) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::FunctionParameter*>(_impl_.kind_.function_parameter_);
    _impl_.kind_.function_parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_function_parameter(
    ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_function_parameter();
    _impl_.kind_.function_parameter_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Value.function_parameter)
}
inline ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NONNULL Value::_internal_mutable_function_parameter() {
  if (kind_case() != kFunctionParameter) {
    clear_kind();
    set_has_function_parameter();
    _impl_.kind_.function_parameter_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::FunctionParameter>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::FunctionParameter*>(_impl_.kind_.function_parameter_);
}
inline ::tint::core::ir::binary::pb::FunctionParameter* PROTOBUF_NONNULL Value::mutable_function_parameter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::FunctionParameter* _msg = _internal_mutable_function_parameter();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Value.function_parameter)
  return _msg;
}

// .tint.core.ir.binary.pb.BlockParameter block_parameter = 4;
inline bool Value::has_block_parameter() const {
  return kind_case() == kBlockParameter;
}
inline bool Value::_internal_has_block_parameter() const {
  return kind_case() == kBlockParameter;
}
inline void Value::set_has_block_parameter() {
  _impl_._oneof_case_[0] = kBlockParameter;
}
inline void Value::clear_block_parameter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBlockParameter) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.block_parameter_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.block_parameter_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE Value::release_block_parameter() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Value.block_parameter)
  if (kind_case() == kBlockParameter) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::BlockParameter*>(_impl_.kind_.block_parameter_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::BlockParameter& Value::_internal_block_parameter() const {
  return kind_case() == kBlockParameter ? *reinterpret_cast<::tint::core::ir::binary::pb::BlockParameter*>(_impl_.kind_.block_parameter_) : reinterpret_cast<::tint::core::ir::binary::pb::BlockParameter&>(::tint::core::ir::binary::pb::_BlockParameter_default_instance_);
}
inline const ::tint::core::ir::binary::pb::BlockParameter& Value::block_parameter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Value.block_parameter)
  return _internal_block_parameter();
}
inline ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE Value::unsafe_arena_release_block_parameter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Value.block_parameter)
  if (kind_case() == kBlockParameter) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::BlockParameter*>(_impl_.kind_.block_parameter_);
    _impl_.kind_.block_parameter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_block_parameter(
    ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_block_parameter();
    _impl_.kind_.block_parameter_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Value.block_parameter)
}
inline ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NONNULL Value::_internal_mutable_block_parameter() {
  if (kind_case() != kBlockParameter) {
    clear_kind();
    set_has_block_parameter();
    _impl_.kind_.block_parameter_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::BlockParameter>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::BlockParameter*>(_impl_.kind_.block_parameter_);
}
inline ::tint::core::ir::binary::pb::BlockParameter* PROTOBUF_NONNULL Value::mutable_block_parameter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::BlockParameter* _msg = _internal_mutable_block_parameter();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Value.block_parameter)
  return _msg;
}

// uint32 constant = 5;
inline bool Value::has_constant() const {
  return kind_case() == kConstant;
}
inline void Value::set_has_constant() {
  _impl_._oneof_case_[0] = kConstant;
}
inline void Value::clear_constant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kConstant) {
    _impl_.kind_.constant_ = 0u;
    clear_has_kind();
  }
}
inline ::uint32_t Value::constant() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Value.constant)
  return _internal_constant();
}
inline void Value::set_constant(::uint32_t value) {
  if (kind_case() != kConstant) {
    clear_kind();
    set_has_constant();
  }
  _impl_.kind_.constant_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Value.constant)
}
inline ::uint32_t Value::_internal_constant() const {
  if (kind_case() == kConstant) {
    return _impl_.kind_.constant_;
  }
  return 0u;
}

inline bool Value::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Value::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Value::KindCase Value::kind_case() const {
  return Value::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InstructionResult

// uint32 type = 1;
inline void InstructionResult::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t InstructionResult::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionResult.type)
  return _internal_type();
}
inline void InstructionResult::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionResult.type)
}
inline ::uint32_t InstructionResult::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void InstructionResult::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// optional string name = 2;
inline bool InstructionResult::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void InstructionResult::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& InstructionResult::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionResult.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InstructionResult::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionResult.name)
}
inline ::std::string* PROTOBUF_NONNULL InstructionResult::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.InstructionResult.name)
  return _s;
}
inline const ::std::string& InstructionResult::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void InstructionResult::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InstructionResult::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InstructionResult::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.InstructionResult.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void InstructionResult::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.InstructionResult.name)
}

// -------------------------------------------------------------------

// FunctionParameter

// uint32 type = 1;
inline void FunctionParameter::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t FunctionParameter::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.FunctionParameter.type)
  return _internal_type();
}
inline void FunctionParameter::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.FunctionParameter.type)
}
inline ::uint32_t FunctionParameter::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void FunctionParameter::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// optional string name = 2;
inline bool FunctionParameter::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void FunctionParameter::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& FunctionParameter::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.FunctionParameter.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FunctionParameter::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.FunctionParameter.name)
}
inline ::std::string* PROTOBUF_NONNULL FunctionParameter::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.FunctionParameter.name)
  return _s;
}
inline const ::std::string& FunctionParameter::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void FunctionParameter::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FunctionParameter::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FunctionParameter::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.FunctionParameter.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void FunctionParameter::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.FunctionParameter.name)
}

// optional .tint.core.ir.binary.pb.AttributesFunctionParameter attributes = 3;
inline bool FunctionParameter::has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attributes_ != nullptr);
  return value;
}
inline void FunctionParameter::clear_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attributes_ != nullptr) _impl_.attributes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::tint::core::ir::binary::pb::AttributesFunctionParameter& FunctionParameter::_internal_attributes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::AttributesFunctionParameter* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::AttributesFunctionParameter&>(::tint::core::ir::binary::pb::_AttributesFunctionParameter_default_instance_);
}
inline const ::tint::core::ir::binary::pb::AttributesFunctionParameter& FunctionParameter::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.FunctionParameter.attributes)
  return _internal_attributes();
}
inline void FunctionParameter::unsafe_arena_set_allocated_attributes(
    ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = reinterpret_cast<::tint::core::ir::binary::pb::AttributesFunctionParameter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.FunctionParameter.attributes)
}
inline ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE FunctionParameter::release_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::AttributesFunctionParameter* released = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE FunctionParameter::unsafe_arena_release_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.FunctionParameter.attributes)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::AttributesFunctionParameter* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NONNULL FunctionParameter::_internal_mutable_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attributes_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::AttributesFunctionParameter>(GetArena());
    _impl_.attributes_ = reinterpret_cast<::tint::core::ir::binary::pb::AttributesFunctionParameter*>(p);
  }
  return _impl_.attributes_;
}
inline ::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NONNULL FunctionParameter::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::tint::core::ir::binary::pb::AttributesFunctionParameter* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.FunctionParameter.attributes)
  return _msg;
}
inline void FunctionParameter::set_allocated_attributes(::tint::core::ir::binary::pb::AttributesFunctionParameter* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.attributes_ = reinterpret_cast<::tint::core::ir::binary::pb::AttributesFunctionParameter*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.FunctionParameter.attributes)
}

// -------------------------------------------------------------------

// BlockParameter

// uint32 type = 1;
inline void BlockParameter::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t BlockParameter::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.BlockParameter.type)
  return _internal_type();
}
inline void BlockParameter::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.BlockParameter.type)
}
inline ::uint32_t BlockParameter::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void BlockParameter::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// optional string name = 2;
inline bool BlockParameter::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void BlockParameter::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& BlockParameter::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.BlockParameter.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BlockParameter::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.BlockParameter.name)
}
inline ::std::string* PROTOBUF_NONNULL BlockParameter::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.BlockParameter.name)
  return _s;
}
inline const ::std::string& BlockParameter::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void BlockParameter::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL BlockParameter::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE BlockParameter::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.BlockParameter.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void BlockParameter::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.BlockParameter.name)
}

// -------------------------------------------------------------------

// ConstantValue

// .tint.core.ir.binary.pb.ConstantValueScalar scalar = 1;
inline bool ConstantValue::has_scalar() const {
  return kind_case() == kScalar;
}
inline bool ConstantValue::_internal_has_scalar() const {
  return kind_case() == kScalar;
}
inline void ConstantValue::set_has_scalar() {
  _impl_._oneof_case_[0] = kScalar;
}
inline void ConstantValue::clear_scalar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kScalar) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.scalar_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.scalar_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE ConstantValue::release_scalar() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.ConstantValue.scalar)
  if (kind_case() == kScalar) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueScalar*>(_impl_.kind_.scalar_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::ConstantValueScalar& ConstantValue::_internal_scalar() const {
  return kind_case() == kScalar ? *reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueScalar*>(_impl_.kind_.scalar_) : reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueScalar&>(::tint::core::ir::binary::pb::_ConstantValueScalar_default_instance_);
}
inline const ::tint::core::ir::binary::pb::ConstantValueScalar& ConstantValue::scalar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValue.scalar)
  return _internal_scalar();
}
inline ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE ConstantValue::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.ConstantValue.scalar)
  if (kind_case() == kScalar) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueScalar*>(_impl_.kind_.scalar_);
    _impl_.kind_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstantValue::unsafe_arena_set_allocated_scalar(
    ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_scalar();
    _impl_.kind_.scalar_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.ConstantValue.scalar)
}
inline ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NONNULL ConstantValue::_internal_mutable_scalar() {
  if (kind_case() != kScalar) {
    clear_kind();
    set_has_scalar();
    _impl_.kind_.scalar_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::ConstantValueScalar>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueScalar*>(_impl_.kind_.scalar_);
}
inline ::tint::core::ir::binary::pb::ConstantValueScalar* PROTOBUF_NONNULL ConstantValue::mutable_scalar()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::ConstantValueScalar* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.ConstantValue.scalar)
  return _msg;
}

// .tint.core.ir.binary.pb.ConstantValueComposite composite = 2;
inline bool ConstantValue::has_composite() const {
  return kind_case() == kComposite;
}
inline bool ConstantValue::_internal_has_composite() const {
  return kind_case() == kComposite;
}
inline void ConstantValue::set_has_composite() {
  _impl_._oneof_case_[0] = kComposite;
}
inline void ConstantValue::clear_composite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kComposite) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.composite_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.composite_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE ConstantValue::release_composite() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.ConstantValue.composite)
  if (kind_case() == kComposite) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueComposite*>(_impl_.kind_.composite_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::ConstantValueComposite& ConstantValue::_internal_composite() const {
  return kind_case() == kComposite ? *reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueComposite*>(_impl_.kind_.composite_) : reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueComposite&>(::tint::core::ir::binary::pb::_ConstantValueComposite_default_instance_);
}
inline const ::tint::core::ir::binary::pb::ConstantValueComposite& ConstantValue::composite() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValue.composite)
  return _internal_composite();
}
inline ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE ConstantValue::unsafe_arena_release_composite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.ConstantValue.composite)
  if (kind_case() == kComposite) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueComposite*>(_impl_.kind_.composite_);
    _impl_.kind_.composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstantValue::unsafe_arena_set_allocated_composite(
    ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_composite();
    _impl_.kind_.composite_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.ConstantValue.composite)
}
inline ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NONNULL ConstantValue::_internal_mutable_composite() {
  if (kind_case() != kComposite) {
    clear_kind();
    set_has_composite();
    _impl_.kind_.composite_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::ConstantValueComposite>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueComposite*>(_impl_.kind_.composite_);
}
inline ::tint::core::ir::binary::pb::ConstantValueComposite* PROTOBUF_NONNULL ConstantValue::mutable_composite()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::ConstantValueComposite* _msg = _internal_mutable_composite();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.ConstantValue.composite)
  return _msg;
}

// .tint.core.ir.binary.pb.ConstantValueSplat splat = 3;
inline bool ConstantValue::has_splat() const {
  return kind_case() == kSplat;
}
inline bool ConstantValue::_internal_has_splat() const {
  return kind_case() == kSplat;
}
inline void ConstantValue::set_has_splat() {
  _impl_._oneof_case_[0] = kSplat;
}
inline void ConstantValue::clear_splat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSplat) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.splat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.splat_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE ConstantValue::release_splat() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.ConstantValue.splat)
  if (kind_case() == kSplat) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueSplat*>(_impl_.kind_.splat_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.splat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::ConstantValueSplat& ConstantValue::_internal_splat() const {
  return kind_case() == kSplat ? *reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueSplat*>(_impl_.kind_.splat_) : reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueSplat&>(::tint::core::ir::binary::pb::_ConstantValueSplat_default_instance_);
}
inline const ::tint::core::ir::binary::pb::ConstantValueSplat& ConstantValue::splat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValue.splat)
  return _internal_splat();
}
inline ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE ConstantValue::unsafe_arena_release_splat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.ConstantValue.splat)
  if (kind_case() == kSplat) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueSplat*>(_impl_.kind_.splat_);
    _impl_.kind_.splat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstantValue::unsafe_arena_set_allocated_splat(
    ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_splat();
    _impl_.kind_.splat_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.ConstantValue.splat)
}
inline ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NONNULL ConstantValue::_internal_mutable_splat() {
  if (kind_case() != kSplat) {
    clear_kind();
    set_has_splat();
    _impl_.kind_.splat_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::ConstantValueSplat>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::ConstantValueSplat*>(_impl_.kind_.splat_);
}
inline ::tint::core::ir::binary::pb::ConstantValueSplat* PROTOBUF_NONNULL ConstantValue::mutable_splat()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::ConstantValueSplat* _msg = _internal_mutable_splat();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.ConstantValue.splat)
  return _msg;
}

inline bool ConstantValue::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ConstantValue::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline ConstantValue::KindCase ConstantValue::kind_case() const {
  return ConstantValue::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstantValueScalar

// bool bool = 1;
inline bool ConstantValueScalar::has_bool_() const {
  return kind_case() == kBool;
}
inline void ConstantValueScalar::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void ConstantValueScalar::clear_bool_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBool) {
    _impl_.kind_.bool__ = false;
    clear_has_kind();
  }
}
inline bool ConstantValueScalar::bool_() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueScalar.bool)
  return _internal_bool_();
}
inline void ConstantValueScalar::set_bool_(bool value) {
  if (kind_case() != kBool) {
    clear_kind();
    set_has_bool_();
  }
  _impl_.kind_.bool__ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueScalar.bool)
}
inline bool ConstantValueScalar::_internal_bool_() const {
  if (kind_case() == kBool) {
    return _impl_.kind_.bool__;
  }
  return false;
}

// int32 i32 = 2;
inline bool ConstantValueScalar::has_i32() const {
  return kind_case() == kI32;
}
inline void ConstantValueScalar::set_has_i32() {
  _impl_._oneof_case_[0] = kI32;
}
inline void ConstantValueScalar::clear_i32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kI32) {
    _impl_.kind_.i32_ = 0;
    clear_has_kind();
  }
}
inline ::int32_t ConstantValueScalar::i32() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueScalar.i32)
  return _internal_i32();
}
inline void ConstantValueScalar::set_i32(::int32_t value) {
  if (kind_case() != kI32) {
    clear_kind();
    set_has_i32();
  }
  _impl_.kind_.i32_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueScalar.i32)
}
inline ::int32_t ConstantValueScalar::_internal_i32() const {
  if (kind_case() == kI32) {
    return _impl_.kind_.i32_;
  }
  return 0;
}

// uint32 u32 = 3;
inline bool ConstantValueScalar::has_u32() const {
  return kind_case() == kU32;
}
inline void ConstantValueScalar::set_has_u32() {
  _impl_._oneof_case_[0] = kU32;
}
inline void ConstantValueScalar::clear_u32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kU32) {
    _impl_.kind_.u32_ = 0u;
    clear_has_kind();
  }
}
inline ::uint32_t ConstantValueScalar::u32() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueScalar.u32)
  return _internal_u32();
}
inline void ConstantValueScalar::set_u32(::uint32_t value) {
  if (kind_case() != kU32) {
    clear_kind();
    set_has_u32();
  }
  _impl_.kind_.u32_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueScalar.u32)
}
inline ::uint32_t ConstantValueScalar::_internal_u32() const {
  if (kind_case() == kU32) {
    return _impl_.kind_.u32_;
  }
  return 0u;
}

// float f32 = 4;
inline bool ConstantValueScalar::has_f32() const {
  return kind_case() == kF32;
}
inline void ConstantValueScalar::set_has_f32() {
  _impl_._oneof_case_[0] = kF32;
}
inline void ConstantValueScalar::clear_f32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kF32) {
    _impl_.kind_.f32_ = 0;
    clear_has_kind();
  }
}
inline float ConstantValueScalar::f32() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueScalar.f32)
  return _internal_f32();
}
inline void ConstantValueScalar::set_f32(float value) {
  if (kind_case() != kF32) {
    clear_kind();
    set_has_f32();
  }
  _impl_.kind_.f32_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueScalar.f32)
}
inline float ConstantValueScalar::_internal_f32() const {
  if (kind_case() == kF32) {
    return _impl_.kind_.f32_;
  }
  return 0;
}

// float f16 = 5;
inline bool ConstantValueScalar::has_f16() const {
  return kind_case() == kF16;
}
inline void ConstantValueScalar::set_has_f16() {
  _impl_._oneof_case_[0] = kF16;
}
inline void ConstantValueScalar::clear_f16() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kF16) {
    _impl_.kind_.f16_ = 0;
    clear_has_kind();
  }
}
inline float ConstantValueScalar::f16() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueScalar.f16)
  return _internal_f16();
}
inline void ConstantValueScalar::set_f16(float value) {
  if (kind_case() != kF16) {
    clear_kind();
    set_has_f16();
  }
  _impl_.kind_.f16_ = value;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueScalar.f16)
}
inline float ConstantValueScalar::_internal_f16() const {
  if (kind_case() == kF16) {
    return _impl_.kind_.f16_;
  }
  return 0;
}

inline bool ConstantValueScalar::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ConstantValueScalar::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline ConstantValueScalar::KindCase ConstantValueScalar::kind_case() const {
  return ConstantValueScalar::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstantValueComposite

// uint32 type = 1;
inline void ConstantValueComposite::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t ConstantValueComposite::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueComposite.type)
  return _internal_type();
}
inline void ConstantValueComposite::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueComposite.type)
}
inline ::uint32_t ConstantValueComposite::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void ConstantValueComposite::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// repeated uint32 elements = 2;
inline int ConstantValueComposite::_internal_elements_size() const {
  return _internal_elements().size();
}
inline int ConstantValueComposite::elements_size() const {
  return _internal_elements_size();
}
inline void ConstantValueComposite::clear_elements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elements_.Clear();
}
inline ::uint32_t ConstantValueComposite::elements(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueComposite.elements)
  return _internal_elements().Get(index);
}
inline void ConstantValueComposite::set_elements(int index, ::uint32_t value) {
  _internal_mutable_elements()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueComposite.elements)
}
inline void ConstantValueComposite::add_elements(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_elements()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.ConstantValueComposite.elements)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ConstantValueComposite::elements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.ConstantValueComposite.elements)
  return _internal_elements();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL ConstantValueComposite::mutable_elements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.ConstantValueComposite.elements)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_elements();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
ConstantValueComposite::_internal_elements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elements_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
ConstantValueComposite::_internal_mutable_elements() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.elements_;
}

// -------------------------------------------------------------------

// ConstantValueSplat

// uint32 type = 1;
inline void ConstantValueSplat::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t ConstantValueSplat::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueSplat.type)
  return _internal_type();
}
inline void ConstantValueSplat::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueSplat.type)
}
inline ::uint32_t ConstantValueSplat::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void ConstantValueSplat::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// uint32 elements = 2;
inline void ConstantValueSplat::clear_elements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elements_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t ConstantValueSplat::elements() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueSplat.elements)
  return _internal_elements();
}
inline void ConstantValueSplat::set_elements(::uint32_t value) {
  _internal_set_elements(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueSplat.elements)
}
inline ::uint32_t ConstantValueSplat::_internal_elements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.elements_;
}
inline void ConstantValueSplat::_internal_set_elements(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.elements_ = value;
}

// uint32 count = 3;
inline void ConstantValueSplat::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t ConstantValueSplat::count() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.ConstantValueSplat.count)
  return _internal_count();
}
inline void ConstantValueSplat::set_count(::uint32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.ConstantValueSplat.count)
}
inline ::uint32_t ConstantValueSplat::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void ConstantValueSplat::_internal_set_count(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// -------------------------------------------------------------------

// Function

// uint32 return_type = 1;
inline void Function::clear_return_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t Function::return_type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.return_type)
  return _internal_return_type();
}
inline void Function::set_return_type(::uint32_t value) {
  _internal_set_return_type(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.return_type)
}
inline ::uint32_t Function::_internal_return_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.return_type_;
}
inline void Function::_internal_set_return_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_type_ = value;
}

// uint32 block = 2;
inline void Function::clear_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::uint32_t Function::block() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.block)
  return _internal_block();
}
inline void Function::set_block(::uint32_t value) {
  _internal_set_block(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.block)
}
inline ::uint32_t Function::_internal_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_;
}
inline void Function::_internal_set_block(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_ = value;
}

// optional string name = 3;
inline bool Function::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void Function::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& Function::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Function::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.name)
}
inline ::std::string* PROTOBUF_NONNULL Function::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Function.name)
  return _s;
}
inline const ::std::string& Function::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Function::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Function::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Function::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Function.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void Function::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.Function.name)
}

// optional .tint.core.ir.binary.pb.PipelineStage pipeline_stage = 4;
inline bool Function::has_pipeline_stage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020U) != 0;
  return value;
}
inline void Function::clear_pipeline_stage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_stage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline ::tint::core::ir::binary::pb::PipelineStage Function::pipeline_stage() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.pipeline_stage)
  return _internal_pipeline_stage();
}
inline void Function::set_pipeline_stage(::tint::core::ir::binary::pb::PipelineStage value) {
  _internal_set_pipeline_stage(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.pipeline_stage)
}
inline ::tint::core::ir::binary::pb::PipelineStage Function::_internal_pipeline_stage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::PipelineStage>(_impl_.pipeline_stage_);
}
inline void Function::_internal_set_pipeline_stage(::tint::core::ir::binary::pb::PipelineStage value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pipeline_stage_ = value;
}

// optional .tint.core.ir.binary.pb.WorkgroupSize workgroup_size = 5;
inline bool Function::has_workgroup_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.workgroup_size_ != nullptr);
  return value;
}
inline void Function::clear_workgroup_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.workgroup_size_ != nullptr) _impl_.workgroup_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::tint::core::ir::binary::pb::WorkgroupSize& Function::_internal_workgroup_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::WorkgroupSize* p = _impl_.workgroup_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::WorkgroupSize&>(::tint::core::ir::binary::pb::_WorkgroupSize_default_instance_);
}
inline const ::tint::core::ir::binary::pb::WorkgroupSize& Function::workgroup_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.workgroup_size)
  return _internal_workgroup_size();
}
inline void Function::unsafe_arena_set_allocated_workgroup_size(
    ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.workgroup_size_);
  }
  _impl_.workgroup_size_ = reinterpret_cast<::tint::core::ir::binary::pb::WorkgroupSize*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Function.workgroup_size)
}
inline ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE Function::release_workgroup_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::WorkgroupSize* released = _impl_.workgroup_size_;
  _impl_.workgroup_size_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE Function::unsafe_arena_release_workgroup_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Function.workgroup_size)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::WorkgroupSize* temp = _impl_.workgroup_size_;
  _impl_.workgroup_size_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NONNULL Function::_internal_mutable_workgroup_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.workgroup_size_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::WorkgroupSize>(GetArena());
    _impl_.workgroup_size_ = reinterpret_cast<::tint::core::ir::binary::pb::WorkgroupSize*>(p);
  }
  return _impl_.workgroup_size_;
}
inline ::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NONNULL Function::mutable_workgroup_size()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::tint::core::ir::binary::pb::WorkgroupSize* _msg = _internal_mutable_workgroup_size();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Function.workgroup_size)
  return _msg;
}
inline void Function::set_allocated_workgroup_size(::tint::core::ir::binary::pb::WorkgroupSize* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.workgroup_size_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.workgroup_size_ = reinterpret_cast<::tint::core::ir::binary::pb::WorkgroupSize*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.Function.workgroup_size)
}

// repeated uint32 parameters = 6;
inline int Function::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int Function::parameters_size() const {
  return _internal_parameters_size();
}
inline void Function::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parameters_.Clear();
}
inline ::uint32_t Function::parameters(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.parameters)
  return _internal_parameters().Get(index);
}
inline void Function::set_parameters(int index, ::uint32_t value) {
  _internal_mutable_parameters()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.parameters)
}
inline void Function::add_parameters(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_parameters()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Function.parameters)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Function::parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Function.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Function::mutable_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Function.parameters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_parameters();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Function::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parameters_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Function::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.parameters_;
}

// optional uint32 return_location = 7;
inline bool Function::has_return_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040U) != 0;
  return value;
}
inline void Function::clear_return_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040U;
}
inline ::uint32_t Function::return_location() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.return_location)
  return _internal_return_location();
}
inline void Function::set_return_location(::uint32_t value) {
  _internal_set_return_location(value);
  _impl_._has_bits_[0] |= 0x00000040U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.return_location)
}
inline ::uint32_t Function::_internal_return_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.return_location_;
}
inline void Function::_internal_set_return_location(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_location_ = value;
}

// optional .tint.core.ir.binary.pb.Interpolation return_interpolation = 8;
inline bool Function::has_return_interpolation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.return_interpolation_ != nullptr);
  return value;
}
inline void Function::clear_return_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.return_interpolation_ != nullptr) _impl_.return_interpolation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::tint::core::ir::binary::pb::Interpolation& Function::_internal_return_interpolation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::Interpolation* p = _impl_.return_interpolation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::Interpolation&>(::tint::core::ir::binary::pb::_Interpolation_default_instance_);
}
inline const ::tint::core::ir::binary::pb::Interpolation& Function::return_interpolation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.return_interpolation)
  return _internal_return_interpolation();
}
inline void Function::unsafe_arena_set_allocated_return_interpolation(
    ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.return_interpolation_);
  }
  _impl_.return_interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Function.return_interpolation)
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE Function::release_return_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::tint::core::ir::binary::pb::Interpolation* released = _impl_.return_interpolation_;
  _impl_.return_interpolation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE Function::unsafe_arena_release_return_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Function.return_interpolation)

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::tint::core::ir::binary::pb::Interpolation* temp = _impl_.return_interpolation_;
  _impl_.return_interpolation_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL Function::_internal_mutable_return_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.return_interpolation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::Interpolation>(GetArena());
    _impl_.return_interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(p);
  }
  return _impl_.return_interpolation_;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL Function::mutable_return_interpolation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004U;
  ::tint::core::ir::binary::pb::Interpolation* _msg = _internal_mutable_return_interpolation();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Function.return_interpolation)
  return _msg;
}
inline void Function::set_allocated_return_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.return_interpolation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }

  _impl_.return_interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.Function.return_interpolation)
}

// optional .tint.core.ir.binary.pb.BuiltinValue return_builtin = 9;
inline bool Function::has_return_builtin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080U) != 0;
  return value;
}
inline void Function::clear_return_builtin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_builtin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080U;
}
inline ::tint::core::ir::binary::pb::BuiltinValue Function::return_builtin() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.return_builtin)
  return _internal_return_builtin();
}
inline void Function::set_return_builtin(::tint::core::ir::binary::pb::BuiltinValue value) {
  _internal_set_return_builtin(value);
  _impl_._has_bits_[0] |= 0x00000080U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.return_builtin)
}
inline ::tint::core::ir::binary::pb::BuiltinValue Function::_internal_return_builtin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::BuiltinValue>(_impl_.return_builtin_);
}
inline void Function::_internal_set_return_builtin(::tint::core::ir::binary::pb::BuiltinValue value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_builtin_ = value;
}

// bool return_invariant = 10;
inline void Function::clear_return_invariant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_invariant_ = false;
  _impl_._has_bits_[0] &= ~0x00000100U;
}
inline bool Function::return_invariant() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.return_invariant)
  return _internal_return_invariant();
}
inline void Function::set_return_invariant(bool value) {
  _internal_set_return_invariant(value);
  _impl_._has_bits_[0] |= 0x00000100U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.return_invariant)
}
inline bool Function::_internal_return_invariant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.return_invariant_;
}
inline void Function::_internal_set_return_invariant(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.return_invariant_ = value;
}

// optional uint32 subgroup_size = 11;
inline bool Function::has_subgroup_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200U) != 0;
  return value;
}
inline void Function::clear_subgroup_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subgroup_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200U;
}
inline ::uint32_t Function::subgroup_size() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Function.subgroup_size)
  return _internal_subgroup_size();
}
inline void Function::set_subgroup_size(::uint32_t value) {
  _internal_set_subgroup_size(value);
  _impl_._has_bits_[0] |= 0x00000200U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Function.subgroup_size)
}
inline ::uint32_t Function::_internal_subgroup_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subgroup_size_;
}
inline void Function::_internal_set_subgroup_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subgroup_size_ = value;
}

// -------------------------------------------------------------------

// WorkgroupSize

// uint32 x = 1;
inline void WorkgroupSize::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t WorkgroupSize::x() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.WorkgroupSize.x)
  return _internal_x();
}
inline void WorkgroupSize::set_x(::uint32_t value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.WorkgroupSize.x)
}
inline ::uint32_t WorkgroupSize::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void WorkgroupSize::_internal_set_x(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// uint32 y = 2;
inline void WorkgroupSize::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t WorkgroupSize::y() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.WorkgroupSize.y)
  return _internal_y();
}
inline void WorkgroupSize::set_y(::uint32_t value) {
  _internal_set_y(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.WorkgroupSize.y)
}
inline ::uint32_t WorkgroupSize::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void WorkgroupSize::_internal_set_y(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// uint32 z = 3;
inline void WorkgroupSize::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t WorkgroupSize::z() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.WorkgroupSize.z)
  return _internal_z();
}
inline void WorkgroupSize::set_z(::uint32_t value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.WorkgroupSize.z)
}
inline ::uint32_t WorkgroupSize::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void WorkgroupSize::_internal_set_z(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Block

// repeated uint32 parameters = 1;
inline int Block::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int Block::parameters_size() const {
  return _internal_parameters_size();
}
inline void Block::clear_parameters() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parameters_.Clear();
}
inline ::uint32_t Block::parameters(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Block.parameters)
  return _internal_parameters().Get(index);
}
inline void Block::set_parameters(int index, ::uint32_t value) {
  _internal_mutable_parameters()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Block.parameters)
}
inline void Block::add_parameters(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_parameters()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Block.parameters)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Block::parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Block.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Block::mutable_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Block.parameters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_parameters();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Block::_internal_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parameters_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Block::_internal_mutable_parameters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.parameters_;
}

// repeated .tint.core.ir.binary.pb.Instruction instructions = 2;
inline int Block::_internal_instructions_size() const {
  return _internal_instructions().size();
}
inline int Block::instructions_size() const {
  return _internal_instructions_size();
}
inline void Block::clear_instructions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.instructions_.Clear();
}
inline ::tint::core::ir::binary::pb::Instruction* PROTOBUF_NONNULL Block::mutable_instructions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Block.instructions)
  return _internal_mutable_instructions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>* PROTOBUF_NONNULL Block::mutable_instructions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Block.instructions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_instructions();
}
inline const ::tint::core::ir::binary::pb::Instruction& Block::instructions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Block.instructions)
  return _internal_instructions().Get(index);
}
inline ::tint::core::ir::binary::pb::Instruction* PROTOBUF_NONNULL Block::add_instructions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::Instruction* _add = _internal_mutable_instructions()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Block.instructions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>& Block::instructions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Block.instructions)
  return _internal_instructions();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>&
Block::_internal_instructions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.instructions_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::Instruction>* PROTOBUF_NONNULL
Block::_internal_mutable_instructions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.instructions_;
}

// bool is_multi_in = 3;
inline void Block::clear_is_multi_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_multi_in_ = false;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline bool Block::is_multi_in() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Block.is_multi_in)
  return _internal_is_multi_in();
}
inline void Block::set_is_multi_in(bool value) {
  _internal_set_is_multi_in(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Block.is_multi_in)
}
inline bool Block::_internal_is_multi_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_multi_in_;
}
inline void Block::_internal_set_is_multi_in(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_multi_in_ = value;
}

// -------------------------------------------------------------------

// Instruction

// repeated uint32 operands = 1;
inline int Instruction::_internal_operands_size() const {
  return _internal_operands().size();
}
inline int Instruction::operands_size() const {
  return _internal_operands_size();
}
inline void Instruction::clear_operands() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operands_.Clear();
}
inline ::uint32_t Instruction::operands(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.operands)
  return _internal_operands().Get(index);
}
inline void Instruction::set_operands(int index, ::uint32_t value) {
  _internal_mutable_operands()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Instruction.operands)
}
inline void Instruction::add_operands(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_operands()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Instruction.operands)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Instruction::operands() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Instruction.operands)
  return _internal_operands();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Instruction::mutable_operands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Instruction.operands)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_operands();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Instruction::_internal_operands() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operands_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Instruction::_internal_mutable_operands() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.operands_;
}

// repeated uint32 results = 2;
inline int Instruction::_internal_results_size() const {
  return _internal_results().size();
}
inline int Instruction::results_size() const {
  return _internal_results_size();
}
inline void Instruction::clear_results() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.results_.Clear();
}
inline ::uint32_t Instruction::results(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.results)
  return _internal_results().Get(index);
}
inline void Instruction::set_results(int index, ::uint32_t value) {
  _internal_mutable_results()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Instruction.results)
}
inline void Instruction::add_results(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_results()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.Instruction.results)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Instruction::results() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.Instruction.results)
  return _internal_results();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Instruction::mutable_results()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.Instruction.results)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_results();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Instruction::_internal_results() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.results_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Instruction::_internal_mutable_results() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.results_;
}

// .tint.core.ir.binary.pb.InstructionReturn return = 3;
inline bool Instruction::has_return_() const {
  return kind_case() == kReturn;
}
inline bool Instruction::_internal_has_return_() const {
  return kind_case() == kReturn;
}
inline void Instruction::set_has_return_() {
  _impl_._oneof_case_[0] = kReturn;
}
inline void Instruction::clear_return_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kReturn) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.return__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.return__);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE Instruction::release_return_() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.return)
  if (kind_case() == kReturn) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionReturn*>(_impl_.kind_.return__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.return__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionReturn& Instruction::_internal_return_() const {
  return kind_case() == kReturn ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionReturn*>(_impl_.kind_.return__) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionReturn&>(::tint::core::ir::binary::pb::_InstructionReturn_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionReturn& Instruction::return_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.return)
  return _internal_return_();
}
inline ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_return_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.return)
  if (kind_case() == kReturn) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionReturn*>(_impl_.kind_.return__);
    _impl_.kind_.return__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_return_(
    ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_return_();
    _impl_.kind_.return__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.return)
}
inline ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NONNULL Instruction::_internal_mutable_return_() {
  if (kind_case() != kReturn) {
    clear_kind();
    set_has_return_();
    _impl_.kind_.return__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionReturn>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionReturn*>(_impl_.kind_.return__);
}
inline ::tint::core::ir::binary::pb::InstructionReturn* PROTOBUF_NONNULL Instruction::mutable_return_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionReturn* _msg = _internal_mutable_return_();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.return)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionUnary unary = 4;
inline bool Instruction::has_unary() const {
  return kind_case() == kUnary;
}
inline bool Instruction::_internal_has_unary() const {
  return kind_case() == kUnary;
}
inline void Instruction::set_has_unary() {
  _impl_._oneof_case_[0] = kUnary;
}
inline void Instruction::clear_unary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUnary) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.unary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.unary_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE Instruction::release_unary() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.unary)
  if (kind_case() == kUnary) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnary*>(_impl_.kind_.unary_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionUnary& Instruction::_internal_unary() const {
  return kind_case() == kUnary ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnary*>(_impl_.kind_.unary_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnary&>(::tint::core::ir::binary::pb::_InstructionUnary_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionUnary& Instruction::unary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.unary)
  return _internal_unary();
}
inline ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_unary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.unary)
  if (kind_case() == kUnary) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnary*>(_impl_.kind_.unary_);
    _impl_.kind_.unary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_unary(
    ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_unary();
    _impl_.kind_.unary_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.unary)
}
inline ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NONNULL Instruction::_internal_mutable_unary() {
  if (kind_case() != kUnary) {
    clear_kind();
    set_has_unary();
    _impl_.kind_.unary_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionUnary>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnary*>(_impl_.kind_.unary_);
}
inline ::tint::core::ir::binary::pb::InstructionUnary* PROTOBUF_NONNULL Instruction::mutable_unary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionUnary* _msg = _internal_mutable_unary();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.unary)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionBinary binary = 5;
inline bool Instruction::has_binary() const {
  return kind_case() == kBinary;
}
inline bool Instruction::_internal_has_binary() const {
  return kind_case() == kBinary;
}
inline void Instruction::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void Instruction::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.binary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.binary_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE Instruction::release_binary() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.binary)
  if (kind_case() == kBinary) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBinary*>(_impl_.kind_.binary_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionBinary& Instruction::_internal_binary() const {
  return kind_case() == kBinary ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionBinary*>(_impl_.kind_.binary_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionBinary&>(::tint::core::ir::binary::pb::_InstructionBinary_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionBinary& Instruction::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.binary)
  return _internal_binary();
}
inline ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.binary)
  if (kind_case() == kBinary) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBinary*>(_impl_.kind_.binary_);
    _impl_.kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_binary(
    ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_binary();
    _impl_.kind_.binary_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.binary)
}
inline ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NONNULL Instruction::_internal_mutable_binary() {
  if (kind_case() != kBinary) {
    clear_kind();
    set_has_binary();
    _impl_.kind_.binary_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionBinary>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionBinary*>(_impl_.kind_.binary_);
}
inline ::tint::core::ir::binary::pb::InstructionBinary* PROTOBUF_NONNULL Instruction::mutable_binary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionBinary* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.binary)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionDiscard discard = 6;
inline bool Instruction::has_discard() const {
  return kind_case() == kDiscard;
}
inline bool Instruction::_internal_has_discard() const {
  return kind_case() == kDiscard;
}
inline void Instruction::set_has_discard() {
  _impl_._oneof_case_[0] = kDiscard;
}
inline void Instruction::clear_discard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kDiscard) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.discard_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.discard_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE Instruction::release_discard() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.discard)
  if (kind_case() == kDiscard) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionDiscard*>(_impl_.kind_.discard_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.discard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionDiscard& Instruction::_internal_discard() const {
  return kind_case() == kDiscard ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionDiscard*>(_impl_.kind_.discard_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionDiscard&>(::tint::core::ir::binary::pb::_InstructionDiscard_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionDiscard& Instruction::discard() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.discard)
  return _internal_discard();
}
inline ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_discard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.discard)
  if (kind_case() == kDiscard) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionDiscard*>(_impl_.kind_.discard_);
    _impl_.kind_.discard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_discard(
    ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_discard();
    _impl_.kind_.discard_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.discard)
}
inline ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NONNULL Instruction::_internal_mutable_discard() {
  if (kind_case() != kDiscard) {
    clear_kind();
    set_has_discard();
    _impl_.kind_.discard_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionDiscard>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionDiscard*>(_impl_.kind_.discard_);
}
inline ::tint::core::ir::binary::pb::InstructionDiscard* PROTOBUF_NONNULL Instruction::mutable_discard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionDiscard* _msg = _internal_mutable_discard();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.discard)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionLet let = 7;
inline bool Instruction::has_let() const {
  return kind_case() == kLet;
}
inline bool Instruction::_internal_has_let() const {
  return kind_case() == kLet;
}
inline void Instruction::set_has_let() {
  _impl_._oneof_case_[0] = kLet;
}
inline void Instruction::clear_let() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kLet) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.let_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.let_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE Instruction::release_let() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.let)
  if (kind_case() == kLet) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLet*>(_impl_.kind_.let_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.let_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionLet& Instruction::_internal_let() const {
  return kind_case() == kLet ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionLet*>(_impl_.kind_.let_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionLet&>(::tint::core::ir::binary::pb::_InstructionLet_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionLet& Instruction::let() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.let)
  return _internal_let();
}
inline ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_let() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.let)
  if (kind_case() == kLet) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLet*>(_impl_.kind_.let_);
    _impl_.kind_.let_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_let(
    ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_let();
    _impl_.kind_.let_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.let)
}
inline ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NONNULL Instruction::_internal_mutable_let() {
  if (kind_case() != kLet) {
    clear_kind();
    set_has_let();
    _impl_.kind_.let_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionLet>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionLet*>(_impl_.kind_.let_);
}
inline ::tint::core::ir::binary::pb::InstructionLet* PROTOBUF_NONNULL Instruction::mutable_let()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionLet* _msg = _internal_mutable_let();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.let)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionVar var = 8;
inline bool Instruction::has_var() const {
  return kind_case() == kVar;
}
inline bool Instruction::_internal_has_var() const {
  return kind_case() == kVar;
}
inline void Instruction::set_has_var() {
  _impl_._oneof_case_[0] = kVar;
}
inline void Instruction::clear_var() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kVar) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.var_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.var_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE Instruction::release_var() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.var)
  if (kind_case() == kVar) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionVar*>(_impl_.kind_.var_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionVar& Instruction::_internal_var() const {
  return kind_case() == kVar ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionVar*>(_impl_.kind_.var_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionVar&>(::tint::core::ir::binary::pb::_InstructionVar_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionVar& Instruction::var() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.var)
  return _internal_var();
}
inline ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.var)
  if (kind_case() == kVar) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionVar*>(_impl_.kind_.var_);
    _impl_.kind_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_var(
    ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_var();
    _impl_.kind_.var_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.var)
}
inline ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NONNULL Instruction::_internal_mutable_var() {
  if (kind_case() != kVar) {
    clear_kind();
    set_has_var();
    _impl_.kind_.var_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionVar>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionVar*>(_impl_.kind_.var_);
}
inline ::tint::core::ir::binary::pb::InstructionVar* PROTOBUF_NONNULL Instruction::mutable_var()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionVar* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.var)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionBitcast bitcast = 9;
inline bool Instruction::has_bitcast() const {
  return kind_case() == kBitcast;
}
inline bool Instruction::_internal_has_bitcast() const {
  return kind_case() == kBitcast;
}
inline void Instruction::set_has_bitcast() {
  _impl_._oneof_case_[0] = kBitcast;
}
inline void Instruction::clear_bitcast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBitcast) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.bitcast_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.bitcast_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE Instruction::release_bitcast() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.bitcast)
  if (kind_case() == kBitcast) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBitcast*>(_impl_.kind_.bitcast_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.bitcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionBitcast& Instruction::_internal_bitcast() const {
  return kind_case() == kBitcast ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionBitcast*>(_impl_.kind_.bitcast_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionBitcast&>(::tint::core::ir::binary::pb::_InstructionBitcast_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionBitcast& Instruction::bitcast() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.bitcast)
  return _internal_bitcast();
}
inline ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_bitcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.bitcast)
  if (kind_case() == kBitcast) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBitcast*>(_impl_.kind_.bitcast_);
    _impl_.kind_.bitcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_bitcast(
    ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_bitcast();
    _impl_.kind_.bitcast_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.bitcast)
}
inline ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NONNULL Instruction::_internal_mutable_bitcast() {
  if (kind_case() != kBitcast) {
    clear_kind();
    set_has_bitcast();
    _impl_.kind_.bitcast_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionBitcast>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionBitcast*>(_impl_.kind_.bitcast_);
}
inline ::tint::core::ir::binary::pb::InstructionBitcast* PROTOBUF_NONNULL Instruction::mutable_bitcast()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionBitcast* _msg = _internal_mutable_bitcast();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.bitcast)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionConstruct construct = 10;
inline bool Instruction::has_construct() const {
  return kind_case() == kConstruct;
}
inline bool Instruction::_internal_has_construct() const {
  return kind_case() == kConstruct;
}
inline void Instruction::set_has_construct() {
  _impl_._oneof_case_[0] = kConstruct;
}
inline void Instruction::clear_construct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kConstruct) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.construct_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.construct_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE Instruction::release_construct() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.construct)
  if (kind_case() == kConstruct) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionConstruct*>(_impl_.kind_.construct_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.construct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionConstruct& Instruction::_internal_construct() const {
  return kind_case() == kConstruct ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionConstruct*>(_impl_.kind_.construct_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionConstruct&>(::tint::core::ir::binary::pb::_InstructionConstruct_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionConstruct& Instruction::construct() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.construct)
  return _internal_construct();
}
inline ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_construct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.construct)
  if (kind_case() == kConstruct) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionConstruct*>(_impl_.kind_.construct_);
    _impl_.kind_.construct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_construct(
    ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_construct();
    _impl_.kind_.construct_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.construct)
}
inline ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NONNULL Instruction::_internal_mutable_construct() {
  if (kind_case() != kConstruct) {
    clear_kind();
    set_has_construct();
    _impl_.kind_.construct_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionConstruct>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionConstruct*>(_impl_.kind_.construct_);
}
inline ::tint::core::ir::binary::pb::InstructionConstruct* PROTOBUF_NONNULL Instruction::mutable_construct()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionConstruct* _msg = _internal_mutable_construct();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.construct)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionConvert convert = 11;
inline bool Instruction::has_convert() const {
  return kind_case() == kConvert;
}
inline bool Instruction::_internal_has_convert() const {
  return kind_case() == kConvert;
}
inline void Instruction::set_has_convert() {
  _impl_._oneof_case_[0] = kConvert;
}
inline void Instruction::clear_convert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kConvert) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.convert_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.convert_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE Instruction::release_convert() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.convert)
  if (kind_case() == kConvert) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionConvert*>(_impl_.kind_.convert_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.convert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionConvert& Instruction::_internal_convert() const {
  return kind_case() == kConvert ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionConvert*>(_impl_.kind_.convert_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionConvert&>(::tint::core::ir::binary::pb::_InstructionConvert_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionConvert& Instruction::convert() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.convert)
  return _internal_convert();
}
inline ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_convert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.convert)
  if (kind_case() == kConvert) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionConvert*>(_impl_.kind_.convert_);
    _impl_.kind_.convert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_convert(
    ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_convert();
    _impl_.kind_.convert_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.convert)
}
inline ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NONNULL Instruction::_internal_mutable_convert() {
  if (kind_case() != kConvert) {
    clear_kind();
    set_has_convert();
    _impl_.kind_.convert_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionConvert>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionConvert*>(_impl_.kind_.convert_);
}
inline ::tint::core::ir::binary::pb::InstructionConvert* PROTOBUF_NONNULL Instruction::mutable_convert()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionConvert* _msg = _internal_mutable_convert();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.convert)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionAccess access = 12;
inline bool Instruction::has_access() const {
  return kind_case() == kAccess;
}
inline bool Instruction::_internal_has_access() const {
  return kind_case() == kAccess;
}
inline void Instruction::set_has_access() {
  _impl_._oneof_case_[0] = kAccess;
}
inline void Instruction::clear_access() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kAccess) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.access_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.access_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE Instruction::release_access() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.access)
  if (kind_case() == kAccess) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionAccess*>(_impl_.kind_.access_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.access_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionAccess& Instruction::_internal_access() const {
  return kind_case() == kAccess ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionAccess*>(_impl_.kind_.access_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionAccess&>(::tint::core::ir::binary::pb::_InstructionAccess_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionAccess& Instruction::access() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.access)
  return _internal_access();
}
inline ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_access() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.access)
  if (kind_case() == kAccess) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionAccess*>(_impl_.kind_.access_);
    _impl_.kind_.access_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_access(
    ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_access();
    _impl_.kind_.access_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.access)
}
inline ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NONNULL Instruction::_internal_mutable_access() {
  if (kind_case() != kAccess) {
    clear_kind();
    set_has_access();
    _impl_.kind_.access_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionAccess>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionAccess*>(_impl_.kind_.access_);
}
inline ::tint::core::ir::binary::pb::InstructionAccess* PROTOBUF_NONNULL Instruction::mutable_access()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionAccess* _msg = _internal_mutable_access();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.access)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionUserCall user_call = 13;
inline bool Instruction::has_user_call() const {
  return kind_case() == kUserCall;
}
inline bool Instruction::_internal_has_user_call() const {
  return kind_case() == kUserCall;
}
inline void Instruction::set_has_user_call() {
  _impl_._oneof_case_[0] = kUserCall;
}
inline void Instruction::clear_user_call() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUserCall) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.user_call_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.user_call_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE Instruction::release_user_call() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.user_call)
  if (kind_case() == kUserCall) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionUserCall*>(_impl_.kind_.user_call_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.user_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionUserCall& Instruction::_internal_user_call() const {
  return kind_case() == kUserCall ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionUserCall*>(_impl_.kind_.user_call_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionUserCall&>(::tint::core::ir::binary::pb::_InstructionUserCall_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionUserCall& Instruction::user_call() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.user_call)
  return _internal_user_call();
}
inline ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_user_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.user_call)
  if (kind_case() == kUserCall) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionUserCall*>(_impl_.kind_.user_call_);
    _impl_.kind_.user_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_user_call(
    ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_user_call();
    _impl_.kind_.user_call_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.user_call)
}
inline ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NONNULL Instruction::_internal_mutable_user_call() {
  if (kind_case() != kUserCall) {
    clear_kind();
    set_has_user_call();
    _impl_.kind_.user_call_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionUserCall>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionUserCall*>(_impl_.kind_.user_call_);
}
inline ::tint::core::ir::binary::pb::InstructionUserCall* PROTOBUF_NONNULL Instruction::mutable_user_call()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionUserCall* _msg = _internal_mutable_user_call();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.user_call)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionBuiltinCall builtin_call = 14;
inline bool Instruction::has_builtin_call() const {
  return kind_case() == kBuiltinCall;
}
inline bool Instruction::_internal_has_builtin_call() const {
  return kind_case() == kBuiltinCall;
}
inline void Instruction::set_has_builtin_call() {
  _impl_._oneof_case_[0] = kBuiltinCall;
}
inline void Instruction::clear_builtin_call() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBuiltinCall) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.builtin_call_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.builtin_call_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE Instruction::release_builtin_call() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.builtin_call)
  if (kind_case() == kBuiltinCall) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBuiltinCall*>(_impl_.kind_.builtin_call_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionBuiltinCall& Instruction::_internal_builtin_call() const {
  return kind_case() == kBuiltinCall ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionBuiltinCall*>(_impl_.kind_.builtin_call_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionBuiltinCall&>(::tint::core::ir::binary::pb::_InstructionBuiltinCall_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionBuiltinCall& Instruction::builtin_call() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.builtin_call)
  return _internal_builtin_call();
}
inline ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_builtin_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.builtin_call)
  if (kind_case() == kBuiltinCall) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBuiltinCall*>(_impl_.kind_.builtin_call_);
    _impl_.kind_.builtin_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_builtin_call(
    ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_builtin_call();
    _impl_.kind_.builtin_call_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.builtin_call)
}
inline ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NONNULL Instruction::_internal_mutable_builtin_call() {
  if (kind_case() != kBuiltinCall) {
    clear_kind();
    set_has_builtin_call();
    _impl_.kind_.builtin_call_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionBuiltinCall>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionBuiltinCall*>(_impl_.kind_.builtin_call_);
}
inline ::tint::core::ir::binary::pb::InstructionBuiltinCall* PROTOBUF_NONNULL Instruction::mutable_builtin_call()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionBuiltinCall* _msg = _internal_mutable_builtin_call();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.builtin_call)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionLoad load = 15;
inline bool Instruction::has_load() const {
  return kind_case() == kLoad;
}
inline bool Instruction::_internal_has_load() const {
  return kind_case() == kLoad;
}
inline void Instruction::set_has_load() {
  _impl_._oneof_case_[0] = kLoad;
}
inline void Instruction::clear_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kLoad) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.load_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.load_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE Instruction::release_load() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.load)
  if (kind_case() == kLoad) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoad*>(_impl_.kind_.load_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.load_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionLoad& Instruction::_internal_load() const {
  return kind_case() == kLoad ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoad*>(_impl_.kind_.load_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoad&>(::tint::core::ir::binary::pb::_InstructionLoad_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionLoad& Instruction::load() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.load)
  return _internal_load();
}
inline ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_load() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.load)
  if (kind_case() == kLoad) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoad*>(_impl_.kind_.load_);
    _impl_.kind_.load_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_load(
    ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_load();
    _impl_.kind_.load_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.load)
}
inline ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NONNULL Instruction::_internal_mutable_load() {
  if (kind_case() != kLoad) {
    clear_kind();
    set_has_load();
    _impl_.kind_.load_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionLoad>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoad*>(_impl_.kind_.load_);
}
inline ::tint::core::ir::binary::pb::InstructionLoad* PROTOBUF_NONNULL Instruction::mutable_load()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionLoad* _msg = _internal_mutable_load();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.load)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionStore store = 16;
inline bool Instruction::has_store() const {
  return kind_case() == kStore;
}
inline bool Instruction::_internal_has_store() const {
  return kind_case() == kStore;
}
inline void Instruction::set_has_store() {
  _impl_._oneof_case_[0] = kStore;
}
inline void Instruction::clear_store() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStore) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.store_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.store_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE Instruction::release_store() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.store)
  if (kind_case() == kStore) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionStore*>(_impl_.kind_.store_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.store_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionStore& Instruction::_internal_store() const {
  return kind_case() == kStore ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionStore*>(_impl_.kind_.store_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionStore&>(::tint::core::ir::binary::pb::_InstructionStore_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionStore& Instruction::store() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.store)
  return _internal_store();
}
inline ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_store() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.store)
  if (kind_case() == kStore) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionStore*>(_impl_.kind_.store_);
    _impl_.kind_.store_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_store(
    ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_store();
    _impl_.kind_.store_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.store)
}
inline ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NONNULL Instruction::_internal_mutable_store() {
  if (kind_case() != kStore) {
    clear_kind();
    set_has_store();
    _impl_.kind_.store_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionStore>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionStore*>(_impl_.kind_.store_);
}
inline ::tint::core::ir::binary::pb::InstructionStore* PROTOBUF_NONNULL Instruction::mutable_store()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionStore* _msg = _internal_mutable_store();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.store)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionLoadVectorElement load_vector_element = 17;
inline bool Instruction::has_load_vector_element() const {
  return kind_case() == kLoadVectorElement;
}
inline bool Instruction::_internal_has_load_vector_element() const {
  return kind_case() == kLoadVectorElement;
}
inline void Instruction::set_has_load_vector_element() {
  _impl_._oneof_case_[0] = kLoadVectorElement;
}
inline void Instruction::clear_load_vector_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kLoadVectorElement) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.load_vector_element_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.load_vector_element_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE Instruction::release_load_vector_element() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.load_vector_element)
  if (kind_case() == kLoadVectorElement) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoadVectorElement*>(_impl_.kind_.load_vector_element_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.load_vector_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionLoadVectorElement& Instruction::_internal_load_vector_element() const {
  return kind_case() == kLoadVectorElement ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoadVectorElement*>(_impl_.kind_.load_vector_element_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoadVectorElement&>(::tint::core::ir::binary::pb::_InstructionLoadVectorElement_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionLoadVectorElement& Instruction::load_vector_element() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.load_vector_element)
  return _internal_load_vector_element();
}
inline ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_load_vector_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.load_vector_element)
  if (kind_case() == kLoadVectorElement) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoadVectorElement*>(_impl_.kind_.load_vector_element_);
    _impl_.kind_.load_vector_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_load_vector_element(
    ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_load_vector_element();
    _impl_.kind_.load_vector_element_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.load_vector_element)
}
inline ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NONNULL Instruction::_internal_mutable_load_vector_element() {
  if (kind_case() != kLoadVectorElement) {
    clear_kind();
    set_has_load_vector_element();
    _impl_.kind_.load_vector_element_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionLoadVectorElement>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoadVectorElement*>(_impl_.kind_.load_vector_element_);
}
inline ::tint::core::ir::binary::pb::InstructionLoadVectorElement* PROTOBUF_NONNULL Instruction::mutable_load_vector_element()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionLoadVectorElement* _msg = _internal_mutable_load_vector_element();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.load_vector_element)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionStoreVectorElement store_vector_element = 18;
inline bool Instruction::has_store_vector_element() const {
  return kind_case() == kStoreVectorElement;
}
inline bool Instruction::_internal_has_store_vector_element() const {
  return kind_case() == kStoreVectorElement;
}
inline void Instruction::set_has_store_vector_element() {
  _impl_._oneof_case_[0] = kStoreVectorElement;
}
inline void Instruction::clear_store_vector_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStoreVectorElement) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.store_vector_element_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.store_vector_element_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE Instruction::release_store_vector_element() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.store_vector_element)
  if (kind_case() == kStoreVectorElement) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionStoreVectorElement*>(_impl_.kind_.store_vector_element_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.store_vector_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionStoreVectorElement& Instruction::_internal_store_vector_element() const {
  return kind_case() == kStoreVectorElement ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionStoreVectorElement*>(_impl_.kind_.store_vector_element_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionStoreVectorElement&>(::tint::core::ir::binary::pb::_InstructionStoreVectorElement_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionStoreVectorElement& Instruction::store_vector_element() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.store_vector_element)
  return _internal_store_vector_element();
}
inline ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_store_vector_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.store_vector_element)
  if (kind_case() == kStoreVectorElement) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionStoreVectorElement*>(_impl_.kind_.store_vector_element_);
    _impl_.kind_.store_vector_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_store_vector_element(
    ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_store_vector_element();
    _impl_.kind_.store_vector_element_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.store_vector_element)
}
inline ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NONNULL Instruction::_internal_mutable_store_vector_element() {
  if (kind_case() != kStoreVectorElement) {
    clear_kind();
    set_has_store_vector_element();
    _impl_.kind_.store_vector_element_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionStoreVectorElement>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionStoreVectorElement*>(_impl_.kind_.store_vector_element_);
}
inline ::tint::core::ir::binary::pb::InstructionStoreVectorElement* PROTOBUF_NONNULL Instruction::mutable_store_vector_element()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionStoreVectorElement* _msg = _internal_mutable_store_vector_element();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.store_vector_element)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionSwizzle swizzle = 19;
inline bool Instruction::has_swizzle() const {
  return kind_case() == kSwizzle;
}
inline bool Instruction::_internal_has_swizzle() const {
  return kind_case() == kSwizzle;
}
inline void Instruction::set_has_swizzle() {
  _impl_._oneof_case_[0] = kSwizzle;
}
inline void Instruction::clear_swizzle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSwizzle) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.swizzle_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.swizzle_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE Instruction::release_swizzle() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.swizzle)
  if (kind_case() == kSwizzle) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwizzle*>(_impl_.kind_.swizzle_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.swizzle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionSwizzle& Instruction::_internal_swizzle() const {
  return kind_case() == kSwizzle ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwizzle*>(_impl_.kind_.swizzle_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwizzle&>(::tint::core::ir::binary::pb::_InstructionSwizzle_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionSwizzle& Instruction::swizzle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.swizzle)
  return _internal_swizzle();
}
inline ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_swizzle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.swizzle)
  if (kind_case() == kSwizzle) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwizzle*>(_impl_.kind_.swizzle_);
    _impl_.kind_.swizzle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_swizzle(
    ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_swizzle();
    _impl_.kind_.swizzle_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.swizzle)
}
inline ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NONNULL Instruction::_internal_mutable_swizzle() {
  if (kind_case() != kSwizzle) {
    clear_kind();
    set_has_swizzle();
    _impl_.kind_.swizzle_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionSwizzle>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwizzle*>(_impl_.kind_.swizzle_);
}
inline ::tint::core::ir::binary::pb::InstructionSwizzle* PROTOBUF_NONNULL Instruction::mutable_swizzle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionSwizzle* _msg = _internal_mutable_swizzle();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.swizzle)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionIf if = 20;
inline bool Instruction::has_if_() const {
  return kind_case() == kIf;
}
inline bool Instruction::_internal_has_if_() const {
  return kind_case() == kIf;
}
inline void Instruction::set_has_if_() {
  _impl_._oneof_case_[0] = kIf;
}
inline void Instruction::clear_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kIf) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.if__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.if__);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE Instruction::release_if_() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.if)
  if (kind_case() == kIf) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionIf*>(_impl_.kind_.if__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.if__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionIf& Instruction::_internal_if_() const {
  return kind_case() == kIf ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionIf*>(_impl_.kind_.if__) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionIf&>(::tint::core::ir::binary::pb::_InstructionIf_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionIf& Instruction::if_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.if)
  return _internal_if_();
}
inline ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_if_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.if)
  if (kind_case() == kIf) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionIf*>(_impl_.kind_.if__);
    _impl_.kind_.if__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_if_(
    ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_if_();
    _impl_.kind_.if__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.if)
}
inline ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NONNULL Instruction::_internal_mutable_if_() {
  if (kind_case() != kIf) {
    clear_kind();
    set_has_if_();
    _impl_.kind_.if__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionIf>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionIf*>(_impl_.kind_.if__);
}
inline ::tint::core::ir::binary::pb::InstructionIf* PROTOBUF_NONNULL Instruction::mutable_if_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionIf* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.if)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionSwitch switch = 21;
inline bool Instruction::has_switch_() const {
  return kind_case() == kSwitch;
}
inline bool Instruction::_internal_has_switch_() const {
  return kind_case() == kSwitch;
}
inline void Instruction::set_has_switch_() {
  _impl_._oneof_case_[0] = kSwitch;
}
inline void Instruction::clear_switch_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSwitch) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.switch__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.switch__);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE Instruction::release_switch_() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.switch)
  if (kind_case() == kSwitch) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwitch*>(_impl_.kind_.switch__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.switch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionSwitch& Instruction::_internal_switch_() const {
  return kind_case() == kSwitch ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwitch*>(_impl_.kind_.switch__) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwitch&>(::tint::core::ir::binary::pb::_InstructionSwitch_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionSwitch& Instruction::switch_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.switch)
  return _internal_switch_();
}
inline ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_switch_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.switch)
  if (kind_case() == kSwitch) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwitch*>(_impl_.kind_.switch__);
    _impl_.kind_.switch__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_switch_(
    ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_switch_();
    _impl_.kind_.switch__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.switch)
}
inline ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NONNULL Instruction::_internal_mutable_switch_() {
  if (kind_case() != kSwitch) {
    clear_kind();
    set_has_switch_();
    _impl_.kind_.switch__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionSwitch>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionSwitch*>(_impl_.kind_.switch__);
}
inline ::tint::core::ir::binary::pb::InstructionSwitch* PROTOBUF_NONNULL Instruction::mutable_switch_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionSwitch* _msg = _internal_mutable_switch_();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.switch)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionLoop loop = 22;
inline bool Instruction::has_loop() const {
  return kind_case() == kLoop;
}
inline bool Instruction::_internal_has_loop() const {
  return kind_case() == kLoop;
}
inline void Instruction::set_has_loop() {
  _impl_._oneof_case_[0] = kLoop;
}
inline void Instruction::clear_loop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kLoop) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.loop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.loop_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE Instruction::release_loop() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.loop)
  if (kind_case() == kLoop) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoop*>(_impl_.kind_.loop_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionLoop& Instruction::_internal_loop() const {
  return kind_case() == kLoop ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoop*>(_impl_.kind_.loop_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoop&>(::tint::core::ir::binary::pb::_InstructionLoop_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionLoop& Instruction::loop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.loop)
  return _internal_loop();
}
inline ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_loop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.loop)
  if (kind_case() == kLoop) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoop*>(_impl_.kind_.loop_);
    _impl_.kind_.loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_loop(
    ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_loop();
    _impl_.kind_.loop_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.loop)
}
inline ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NONNULL Instruction::_internal_mutable_loop() {
  if (kind_case() != kLoop) {
    clear_kind();
    set_has_loop();
    _impl_.kind_.loop_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionLoop>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionLoop*>(_impl_.kind_.loop_);
}
inline ::tint::core::ir::binary::pb::InstructionLoop* PROTOBUF_NONNULL Instruction::mutable_loop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionLoop* _msg = _internal_mutable_loop();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.loop)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionExitIf exit_if = 23;
inline bool Instruction::has_exit_if() const {
  return kind_case() == kExitIf;
}
inline bool Instruction::_internal_has_exit_if() const {
  return kind_case() == kExitIf;
}
inline void Instruction::set_has_exit_if() {
  _impl_._oneof_case_[0] = kExitIf;
}
inline void Instruction::clear_exit_if() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kExitIf) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.exit_if_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.exit_if_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE Instruction::release_exit_if() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.exit_if)
  if (kind_case() == kExitIf) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitIf*>(_impl_.kind_.exit_if_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.exit_if_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionExitIf& Instruction::_internal_exit_if() const {
  return kind_case() == kExitIf ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitIf*>(_impl_.kind_.exit_if_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitIf&>(::tint::core::ir::binary::pb::_InstructionExitIf_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionExitIf& Instruction::exit_if() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.exit_if)
  return _internal_exit_if();
}
inline ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_exit_if() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.exit_if)
  if (kind_case() == kExitIf) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitIf*>(_impl_.kind_.exit_if_);
    _impl_.kind_.exit_if_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_exit_if(
    ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_exit_if();
    _impl_.kind_.exit_if_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.exit_if)
}
inline ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NONNULL Instruction::_internal_mutable_exit_if() {
  if (kind_case() != kExitIf) {
    clear_kind();
    set_has_exit_if();
    _impl_.kind_.exit_if_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionExitIf>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitIf*>(_impl_.kind_.exit_if_);
}
inline ::tint::core::ir::binary::pb::InstructionExitIf* PROTOBUF_NONNULL Instruction::mutable_exit_if()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionExitIf* _msg = _internal_mutable_exit_if();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.exit_if)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionExitSwitch exit_switch = 24;
inline bool Instruction::has_exit_switch() const {
  return kind_case() == kExitSwitch;
}
inline bool Instruction::_internal_has_exit_switch() const {
  return kind_case() == kExitSwitch;
}
inline void Instruction::set_has_exit_switch() {
  _impl_._oneof_case_[0] = kExitSwitch;
}
inline void Instruction::clear_exit_switch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kExitSwitch) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.exit_switch_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.exit_switch_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE Instruction::release_exit_switch() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.exit_switch)
  if (kind_case() == kExitSwitch) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitSwitch*>(_impl_.kind_.exit_switch_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.exit_switch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionExitSwitch& Instruction::_internal_exit_switch() const {
  return kind_case() == kExitSwitch ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitSwitch*>(_impl_.kind_.exit_switch_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitSwitch&>(::tint::core::ir::binary::pb::_InstructionExitSwitch_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionExitSwitch& Instruction::exit_switch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.exit_switch)
  return _internal_exit_switch();
}
inline ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_exit_switch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.exit_switch)
  if (kind_case() == kExitSwitch) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitSwitch*>(_impl_.kind_.exit_switch_);
    _impl_.kind_.exit_switch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_exit_switch(
    ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_exit_switch();
    _impl_.kind_.exit_switch_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.exit_switch)
}
inline ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NONNULL Instruction::_internal_mutable_exit_switch() {
  if (kind_case() != kExitSwitch) {
    clear_kind();
    set_has_exit_switch();
    _impl_.kind_.exit_switch_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionExitSwitch>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitSwitch*>(_impl_.kind_.exit_switch_);
}
inline ::tint::core::ir::binary::pb::InstructionExitSwitch* PROTOBUF_NONNULL Instruction::mutable_exit_switch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionExitSwitch* _msg = _internal_mutable_exit_switch();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.exit_switch)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionExitLoop exit_loop = 25;
inline bool Instruction::has_exit_loop() const {
  return kind_case() == kExitLoop;
}
inline bool Instruction::_internal_has_exit_loop() const {
  return kind_case() == kExitLoop;
}
inline void Instruction::set_has_exit_loop() {
  _impl_._oneof_case_[0] = kExitLoop;
}
inline void Instruction::clear_exit_loop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kExitLoop) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.exit_loop_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.exit_loop_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE Instruction::release_exit_loop() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.exit_loop)
  if (kind_case() == kExitLoop) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitLoop*>(_impl_.kind_.exit_loop_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.exit_loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionExitLoop& Instruction::_internal_exit_loop() const {
  return kind_case() == kExitLoop ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitLoop*>(_impl_.kind_.exit_loop_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitLoop&>(::tint::core::ir::binary::pb::_InstructionExitLoop_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionExitLoop& Instruction::exit_loop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.exit_loop)
  return _internal_exit_loop();
}
inline ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_exit_loop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.exit_loop)
  if (kind_case() == kExitLoop) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitLoop*>(_impl_.kind_.exit_loop_);
    _impl_.kind_.exit_loop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_exit_loop(
    ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_exit_loop();
    _impl_.kind_.exit_loop_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.exit_loop)
}
inline ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NONNULL Instruction::_internal_mutable_exit_loop() {
  if (kind_case() != kExitLoop) {
    clear_kind();
    set_has_exit_loop();
    _impl_.kind_.exit_loop_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionExitLoop>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionExitLoop*>(_impl_.kind_.exit_loop_);
}
inline ::tint::core::ir::binary::pb::InstructionExitLoop* PROTOBUF_NONNULL Instruction::mutable_exit_loop()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionExitLoop* _msg = _internal_mutable_exit_loop();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.exit_loop)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionNextIteration next_iteration = 26;
inline bool Instruction::has_next_iteration() const {
  return kind_case() == kNextIteration;
}
inline bool Instruction::_internal_has_next_iteration() const {
  return kind_case() == kNextIteration;
}
inline void Instruction::set_has_next_iteration() {
  _impl_._oneof_case_[0] = kNextIteration;
}
inline void Instruction::clear_next_iteration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kNextIteration) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.next_iteration_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.next_iteration_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE Instruction::release_next_iteration() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.next_iteration)
  if (kind_case() == kNextIteration) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionNextIteration*>(_impl_.kind_.next_iteration_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.next_iteration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionNextIteration& Instruction::_internal_next_iteration() const {
  return kind_case() == kNextIteration ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionNextIteration*>(_impl_.kind_.next_iteration_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionNextIteration&>(::tint::core::ir::binary::pb::_InstructionNextIteration_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionNextIteration& Instruction::next_iteration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.next_iteration)
  return _internal_next_iteration();
}
inline ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_next_iteration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.next_iteration)
  if (kind_case() == kNextIteration) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionNextIteration*>(_impl_.kind_.next_iteration_);
    _impl_.kind_.next_iteration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_next_iteration(
    ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_next_iteration();
    _impl_.kind_.next_iteration_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.next_iteration)
}
inline ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NONNULL Instruction::_internal_mutable_next_iteration() {
  if (kind_case() != kNextIteration) {
    clear_kind();
    set_has_next_iteration();
    _impl_.kind_.next_iteration_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionNextIteration>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionNextIteration*>(_impl_.kind_.next_iteration_);
}
inline ::tint::core::ir::binary::pb::InstructionNextIteration* PROTOBUF_NONNULL Instruction::mutable_next_iteration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionNextIteration* _msg = _internal_mutable_next_iteration();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.next_iteration)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionContinue continue = 27;
inline bool Instruction::has_continue_() const {
  return kind_case() == kContinue;
}
inline bool Instruction::_internal_has_continue_() const {
  return kind_case() == kContinue;
}
inline void Instruction::set_has_continue_() {
  _impl_._oneof_case_[0] = kContinue;
}
inline void Instruction::clear_continue_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kContinue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.continue__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.continue__);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE Instruction::release_continue_() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.continue)
  if (kind_case() == kContinue) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionContinue*>(_impl_.kind_.continue__);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.continue__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionContinue& Instruction::_internal_continue_() const {
  return kind_case() == kContinue ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionContinue*>(_impl_.kind_.continue__) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionContinue&>(::tint::core::ir::binary::pb::_InstructionContinue_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionContinue& Instruction::continue_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.continue)
  return _internal_continue_();
}
inline ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_continue_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.continue)
  if (kind_case() == kContinue) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionContinue*>(_impl_.kind_.continue__);
    _impl_.kind_.continue__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_continue_(
    ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_continue_();
    _impl_.kind_.continue__ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.continue)
}
inline ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NONNULL Instruction::_internal_mutable_continue_() {
  if (kind_case() != kContinue) {
    clear_kind();
    set_has_continue_();
    _impl_.kind_.continue__ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionContinue>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionContinue*>(_impl_.kind_.continue__);
}
inline ::tint::core::ir::binary::pb::InstructionContinue* PROTOBUF_NONNULL Instruction::mutable_continue_()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionContinue* _msg = _internal_mutable_continue_();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.continue)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionBreakIf break_if = 28;
inline bool Instruction::has_break_if() const {
  return kind_case() == kBreakIf;
}
inline bool Instruction::_internal_has_break_if() const {
  return kind_case() == kBreakIf;
}
inline void Instruction::set_has_break_if() {
  _impl_._oneof_case_[0] = kBreakIf;
}
inline void Instruction::clear_break_if() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBreakIf) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.break_if_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.break_if_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE Instruction::release_break_if() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.break_if)
  if (kind_case() == kBreakIf) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBreakIf*>(_impl_.kind_.break_if_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.break_if_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionBreakIf& Instruction::_internal_break_if() const {
  return kind_case() == kBreakIf ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionBreakIf*>(_impl_.kind_.break_if_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionBreakIf&>(::tint::core::ir::binary::pb::_InstructionBreakIf_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionBreakIf& Instruction::break_if() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.break_if)
  return _internal_break_if();
}
inline ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_break_if() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.break_if)
  if (kind_case() == kBreakIf) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionBreakIf*>(_impl_.kind_.break_if_);
    _impl_.kind_.break_if_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_break_if(
    ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_break_if();
    _impl_.kind_.break_if_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.break_if)
}
inline ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NONNULL Instruction::_internal_mutable_break_if() {
  if (kind_case() != kBreakIf) {
    clear_kind();
    set_has_break_if();
    _impl_.kind_.break_if_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionBreakIf>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionBreakIf*>(_impl_.kind_.break_if_);
}
inline ::tint::core::ir::binary::pb::InstructionBreakIf* PROTOBUF_NONNULL Instruction::mutable_break_if()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionBreakIf* _msg = _internal_mutable_break_if();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.break_if)
  return _msg;
}

// .tint.core.ir.binary.pb.InstructionUnreachable unreachable = 29;
inline bool Instruction::has_unreachable() const {
  return kind_case() == kUnreachable;
}
inline bool Instruction::_internal_has_unreachable() const {
  return kind_case() == kUnreachable;
}
inline void Instruction::set_has_unreachable() {
  _impl_._oneof_case_[0] = kUnreachable;
}
inline void Instruction::clear_unreachable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUnreachable) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.unreachable_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.unreachable_);
    }
    clear_has_kind();
  }
}
inline ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE Instruction::release_unreachable() {
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.Instruction.unreachable)
  if (kind_case() == kUnreachable) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnreachable*>(_impl_.kind_.unreachable_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unreachable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tint::core::ir::binary::pb::InstructionUnreachable& Instruction::_internal_unreachable() const {
  return kind_case() == kUnreachable ? *reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnreachable*>(_impl_.kind_.unreachable_) : reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnreachable&>(::tint::core::ir::binary::pb::_InstructionUnreachable_default_instance_);
}
inline const ::tint::core::ir::binary::pb::InstructionUnreachable& Instruction::unreachable() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Instruction.unreachable)
  return _internal_unreachable();
}
inline ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE Instruction::unsafe_arena_release_unreachable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tint.core.ir.binary.pb.Instruction.unreachable)
  if (kind_case() == kUnreachable) {
    clear_has_kind();
    auto* temp = reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnreachable*>(_impl_.kind_.unreachable_);
    _impl_.kind_.unreachable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instruction::unsafe_arena_set_allocated_unreachable(
    ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_unreachable();
    _impl_.kind_.unreachable_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.Instruction.unreachable)
}
inline ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NONNULL Instruction::_internal_mutable_unreachable() {
  if (kind_case() != kUnreachable) {
    clear_kind();
    set_has_unreachable();
    _impl_.kind_.unreachable_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::InstructionUnreachable>(GetArena()));
  }
  return reinterpret_cast<::tint::core::ir::binary::pb::InstructionUnreachable*>(_impl_.kind_.unreachable_);
}
inline ::tint::core::ir::binary::pb::InstructionUnreachable* PROTOBUF_NONNULL Instruction::mutable_unreachable()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tint::core::ir::binary::pb::InstructionUnreachable* _msg = _internal_mutable_unreachable();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.Instruction.unreachable)
  return _msg;
}

inline bool Instruction::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Instruction::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Instruction::KindCase Instruction::kind_case() const {
  return Instruction::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InstructionReturn

// -------------------------------------------------------------------

// InstructionUnary

// .tint.core.ir.binary.pb.UnaryOp op = 1;
inline void InstructionUnary::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::UnaryOp InstructionUnary::op() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionUnary.op)
  return _internal_op();
}
inline void InstructionUnary::set_op(::tint::core::ir::binary::pb::UnaryOp value) {
  _internal_set_op(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionUnary.op)
}
inline ::tint::core::ir::binary::pb::UnaryOp InstructionUnary::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::UnaryOp>(_impl_.op_);
}
inline void InstructionUnary::_internal_set_op(::tint::core::ir::binary::pb::UnaryOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// -------------------------------------------------------------------

// InstructionBinary

// .tint.core.ir.binary.pb.BinaryOp op = 1;
inline void InstructionBinary::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::BinaryOp InstructionBinary::op() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionBinary.op)
  return _internal_op();
}
inline void InstructionBinary::set_op(::tint::core::ir::binary::pb::BinaryOp value) {
  _internal_set_op(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionBinary.op)
}
inline ::tint::core::ir::binary::pb::BinaryOp InstructionBinary::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::BinaryOp>(_impl_.op_);
}
inline void InstructionBinary::_internal_set_op(::tint::core::ir::binary::pb::BinaryOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// -------------------------------------------------------------------

// InstructionBitcast

// -------------------------------------------------------------------

// InstructionConstruct

// -------------------------------------------------------------------

// InstructionDiscard

// -------------------------------------------------------------------

// InstructionLet

// -------------------------------------------------------------------

// InstructionVar

// optional .tint.core.ir.binary.pb.BindingPoint binding_point = 1;
inline bool InstructionVar::has_binding_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.binding_point_ != nullptr);
  return value;
}
inline void InstructionVar::clear_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.binding_point_ != nullptr) _impl_.binding_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::tint::core::ir::binary::pb::BindingPoint& InstructionVar::_internal_binding_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::BindingPoint* p = _impl_.binding_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::BindingPoint&>(::tint::core::ir::binary::pb::_BindingPoint_default_instance_);
}
inline const ::tint::core::ir::binary::pb::BindingPoint& InstructionVar::binding_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionVar.binding_point)
  return _internal_binding_point();
}
inline void InstructionVar::unsafe_arena_set_allocated_binding_point(
    ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.binding_point_);
  }
  _impl_.binding_point_ = reinterpret_cast<::tint::core::ir::binary::pb::BindingPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.InstructionVar.binding_point)
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE InstructionVar::release_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::tint::core::ir::binary::pb::BindingPoint* released = _impl_.binding_point_;
  _impl_.binding_point_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE InstructionVar::unsafe_arena_release_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.InstructionVar.binding_point)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::tint::core::ir::binary::pb::BindingPoint* temp = _impl_.binding_point_;
  _impl_.binding_point_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL InstructionVar::_internal_mutable_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.binding_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::BindingPoint>(GetArena());
    _impl_.binding_point_ = reinterpret_cast<::tint::core::ir::binary::pb::BindingPoint*>(p);
  }
  return _impl_.binding_point_;
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL InstructionVar::mutable_binding_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::tint::core::ir::binary::pb::BindingPoint* _msg = _internal_mutable_binding_point();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.InstructionVar.binding_point)
  return _msg;
}
inline void InstructionVar::set_allocated_binding_point(::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.binding_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.binding_point_ = reinterpret_cast<::tint::core::ir::binary::pb::BindingPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.InstructionVar.binding_point)
}

// optional uint32 input_attachment_index = 2;
inline bool InstructionVar::has_input_attachment_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void InstructionVar::clear_input_attachment_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_attachment_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t InstructionVar::input_attachment_index() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionVar.input_attachment_index)
  return _internal_input_attachment_index();
}
inline void InstructionVar::set_input_attachment_index(::uint32_t value) {
  _internal_set_input_attachment_index(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionVar.input_attachment_index)
}
inline ::uint32_t InstructionVar::_internal_input_attachment_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_attachment_index_;
}
inline void InstructionVar::_internal_set_input_attachment_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_attachment_index_ = value;
}

// -------------------------------------------------------------------

// InstructionConvert

// -------------------------------------------------------------------

// InstructionAccess

// -------------------------------------------------------------------

// InstructionUserCall

// -------------------------------------------------------------------

// InstructionBuiltinCall

// .tint.core.ir.binary.pb.BuiltinFn builtin = 1;
inline void InstructionBuiltinCall::clear_builtin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.builtin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::BuiltinFn InstructionBuiltinCall::builtin() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionBuiltinCall.builtin)
  return _internal_builtin();
}
inline void InstructionBuiltinCall::set_builtin(::tint::core::ir::binary::pb::BuiltinFn value) {
  _internal_set_builtin(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionBuiltinCall.builtin)
}
inline ::tint::core::ir::binary::pb::BuiltinFn InstructionBuiltinCall::_internal_builtin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::BuiltinFn>(_impl_.builtin_);
}
inline void InstructionBuiltinCall::_internal_set_builtin(::tint::core::ir::binary::pb::BuiltinFn value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.builtin_ = value;
}

// repeated uint32 explicit_template_params = 2;
inline int InstructionBuiltinCall::_internal_explicit_template_params_size() const {
  return _internal_explicit_template_params().size();
}
inline int InstructionBuiltinCall::explicit_template_params_size() const {
  return _internal_explicit_template_params_size();
}
inline void InstructionBuiltinCall::clear_explicit_template_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.explicit_template_params_.Clear();
}
inline ::uint32_t InstructionBuiltinCall::explicit_template_params(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionBuiltinCall.explicit_template_params)
  return _internal_explicit_template_params().Get(index);
}
inline void InstructionBuiltinCall::set_explicit_template_params(int index, ::uint32_t value) {
  _internal_mutable_explicit_template_params()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionBuiltinCall.explicit_template_params)
}
inline void InstructionBuiltinCall::add_explicit_template_params(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_explicit_template_params()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.InstructionBuiltinCall.explicit_template_params)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& InstructionBuiltinCall::explicit_template_params() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.InstructionBuiltinCall.explicit_template_params)
  return _internal_explicit_template_params();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL InstructionBuiltinCall::mutable_explicit_template_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.InstructionBuiltinCall.explicit_template_params)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_explicit_template_params();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
InstructionBuiltinCall::_internal_explicit_template_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.explicit_template_params_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
InstructionBuiltinCall::_internal_mutable_explicit_template_params() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.explicit_template_params_;
}

// -------------------------------------------------------------------

// InstructionLoad

// -------------------------------------------------------------------

// InstructionStore

// -------------------------------------------------------------------

// InstructionLoadVectorElement

// -------------------------------------------------------------------

// InstructionStoreVectorElement

// -------------------------------------------------------------------

// InstructionSwizzle

// repeated uint32 indices = 1;
inline int InstructionSwizzle::_internal_indices_size() const {
  return _internal_indices().size();
}
inline int InstructionSwizzle::indices_size() const {
  return _internal_indices_size();
}
inline void InstructionSwizzle::clear_indices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.indices_.Clear();
}
inline ::uint32_t InstructionSwizzle::indices(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionSwizzle.indices)
  return _internal_indices().Get(index);
}
inline void InstructionSwizzle::set_indices(int index, ::uint32_t value) {
  _internal_mutable_indices()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionSwizzle.indices)
}
inline void InstructionSwizzle::add_indices(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_indices()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.InstructionSwizzle.indices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& InstructionSwizzle::indices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.InstructionSwizzle.indices)
  return _internal_indices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL InstructionSwizzle::mutable_indices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.InstructionSwizzle.indices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_indices();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
InstructionSwizzle::_internal_indices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.indices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
InstructionSwizzle::_internal_mutable_indices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.indices_;
}

// -------------------------------------------------------------------

// InstructionIf

// optional uint32 true = 1;
inline bool InstructionIf::has_true_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void InstructionIf::clear_true_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.true__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t InstructionIf::true_() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionIf.true)
  return _internal_true_();
}
inline void InstructionIf::set_true_(::uint32_t value) {
  _internal_set_true_(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionIf.true)
}
inline ::uint32_t InstructionIf::_internal_true_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.true__;
}
inline void InstructionIf::_internal_set_true_(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.true__ = value;
}

// optional uint32 false = 2;
inline bool InstructionIf::has_false_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void InstructionIf::clear_false_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.false__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t InstructionIf::false_() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionIf.false)
  return _internal_false_();
}
inline void InstructionIf::set_false_(::uint32_t value) {
  _internal_set_false_(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionIf.false)
}
inline ::uint32_t InstructionIf::_internal_false_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.false__;
}
inline void InstructionIf::_internal_set_false_(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.false__ = value;
}

// -------------------------------------------------------------------

// InstructionSwitch

// repeated .tint.core.ir.binary.pb.SwitchCase cases = 1;
inline int InstructionSwitch::_internal_cases_size() const {
  return _internal_cases().size();
}
inline int InstructionSwitch::cases_size() const {
  return _internal_cases_size();
}
inline void InstructionSwitch::clear_cases() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cases_.Clear();
}
inline ::tint::core::ir::binary::pb::SwitchCase* PROTOBUF_NONNULL InstructionSwitch::mutable_cases(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.InstructionSwitch.cases)
  return _internal_mutable_cases()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>* PROTOBUF_NONNULL InstructionSwitch::mutable_cases()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.InstructionSwitch.cases)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cases();
}
inline const ::tint::core::ir::binary::pb::SwitchCase& InstructionSwitch::cases(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionSwitch.cases)
  return _internal_cases().Get(index);
}
inline ::tint::core::ir::binary::pb::SwitchCase* PROTOBUF_NONNULL InstructionSwitch::add_cases()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tint::core::ir::binary::pb::SwitchCase* _add = _internal_mutable_cases()->Add();
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.InstructionSwitch.cases)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>& InstructionSwitch::cases() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.InstructionSwitch.cases)
  return _internal_cases();
}
inline const ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>&
InstructionSwitch::_internal_cases() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cases_;
}
inline ::google::protobuf::RepeatedPtrField<::tint::core::ir::binary::pb::SwitchCase>* PROTOBUF_NONNULL
InstructionSwitch::_internal_mutable_cases() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cases_;
}

// -------------------------------------------------------------------

// InstructionLoop

// optional uint32 initializer = 1;
inline bool InstructionLoop::has_initializer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  return value;
}
inline void InstructionLoop::clear_initializer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initializer_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t InstructionLoop::initializer() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionLoop.initializer)
  return _internal_initializer();
}
inline void InstructionLoop::set_initializer(::uint32_t value) {
  _internal_set_initializer(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionLoop.initializer)
}
inline ::uint32_t InstructionLoop::_internal_initializer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initializer_;
}
inline void InstructionLoop::_internal_set_initializer(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initializer_ = value;
}

// optional uint32 body = 2;
inline bool InstructionLoop::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void InstructionLoop::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t InstructionLoop::body() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionLoop.body)
  return _internal_body();
}
inline void InstructionLoop::set_body(::uint32_t value) {
  _internal_set_body(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionLoop.body)
}
inline ::uint32_t InstructionLoop::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.body_;
}
inline void InstructionLoop::_internal_set_body(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_ = value;
}

// optional uint32 continuing = 3;
inline bool InstructionLoop::has_continuing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void InstructionLoop::clear_continuing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.continuing_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t InstructionLoop::continuing() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionLoop.continuing)
  return _internal_continuing();
}
inline void InstructionLoop::set_continuing(::uint32_t value) {
  _internal_set_continuing(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionLoop.continuing)
}
inline ::uint32_t InstructionLoop::_internal_continuing() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.continuing_;
}
inline void InstructionLoop::_internal_set_continuing(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.continuing_ = value;
}

// -------------------------------------------------------------------

// InstructionExitIf

// -------------------------------------------------------------------

// InstructionExitSwitch

// -------------------------------------------------------------------

// InstructionExitLoop

// -------------------------------------------------------------------

// SwitchCase

// uint32 block = 1;
inline void SwitchCase::clear_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t SwitchCase::block() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.SwitchCase.block)
  return _internal_block();
}
inline void SwitchCase::set_block(::uint32_t value) {
  _internal_set_block(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.SwitchCase.block)
}
inline ::uint32_t SwitchCase::_internal_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_;
}
inline void SwitchCase::_internal_set_block(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_ = value;
}

// repeated uint32 selectors = 2;
inline int SwitchCase::_internal_selectors_size() const {
  return _internal_selectors().size();
}
inline int SwitchCase::selectors_size() const {
  return _internal_selectors_size();
}
inline void SwitchCase::clear_selectors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selectors_.Clear();
}
inline ::uint32_t SwitchCase::selectors(int index) const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.SwitchCase.selectors)
  return _internal_selectors().Get(index);
}
inline void SwitchCase::set_selectors(int index, ::uint32_t value) {
  _internal_mutable_selectors()->Set(index, value);
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.SwitchCase.selectors)
}
inline void SwitchCase::add_selectors(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_selectors()->Add(value);
  // @@protoc_insertion_point(field_add:tint.core.ir.binary.pb.SwitchCase.selectors)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& SwitchCase::selectors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tint.core.ir.binary.pb.SwitchCase.selectors)
  return _internal_selectors();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL SwitchCase::mutable_selectors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tint.core.ir.binary.pb.SwitchCase.selectors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_selectors();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
SwitchCase::_internal_selectors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.selectors_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
SwitchCase::_internal_mutable_selectors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.selectors_;
}

// bool is_default = 3;
inline void SwitchCase::clear_is_default() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = false;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline bool SwitchCase::is_default() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.SwitchCase.is_default)
  return _internal_is_default();
}
inline void SwitchCase::set_is_default(bool value) {
  _internal_set_is_default(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.SwitchCase.is_default)
}
inline bool SwitchCase::_internal_is_default() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_default_;
}
inline void SwitchCase::_internal_set_is_default(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_default_ = value;
}

// -------------------------------------------------------------------

// BindingPoint

// uint32 group = 1;
inline void BindingPoint::clear_group() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t BindingPoint::group() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.BindingPoint.group)
  return _internal_group();
}
inline void BindingPoint::set_group(::uint32_t value) {
  _internal_set_group(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.BindingPoint.group)
}
inline ::uint32_t BindingPoint::_internal_group() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.group_;
}
inline void BindingPoint::_internal_set_group(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.group_ = value;
}

// uint32 binding = 2;
inline void BindingPoint::clear_binding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.binding_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t BindingPoint::binding() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.BindingPoint.binding)
  return _internal_binding();
}
inline void BindingPoint::set_binding(::uint32_t value) {
  _internal_set_binding(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.BindingPoint.binding)
}
inline ::uint32_t BindingPoint::_internal_binding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.binding_;
}
inline void BindingPoint::_internal_set_binding(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.binding_ = value;
}

// -------------------------------------------------------------------

// InstructionNextIteration

// -------------------------------------------------------------------

// InstructionContinue

// -------------------------------------------------------------------

// InstructionBreakIf

// uint32 num_next_iter_values = 1;
inline void InstructionBreakIf::clear_num_next_iter_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_next_iter_values_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t InstructionBreakIf::num_next_iter_values() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.InstructionBreakIf.num_next_iter_values)
  return _internal_num_next_iter_values();
}
inline void InstructionBreakIf::set_num_next_iter_values(::uint32_t value) {
  _internal_set_num_next_iter_values(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.InstructionBreakIf.num_next_iter_values)
}
inline ::uint32_t InstructionBreakIf::_internal_num_next_iter_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_next_iter_values_;
}
inline void InstructionBreakIf::_internal_set_num_next_iter_values(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_next_iter_values_ = value;
}

// -------------------------------------------------------------------

// InstructionUnreachable

// -------------------------------------------------------------------

// AttributesStructMember

// optional uint32 location = 1;
inline bool AttributesStructMember::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void AttributesStructMember::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::uint32_t AttributesStructMember::location() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesStructMember.location)
  return _internal_location();
}
inline void AttributesStructMember::set_location(::uint32_t value) {
  _internal_set_location(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesStructMember.location)
}
inline ::uint32_t AttributesStructMember::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.location_;
}
inline void AttributesStructMember::_internal_set_location(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_ = value;
}

// optional uint32 blend_src = 2;
inline bool AttributesStructMember::has_blend_src() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void AttributesStructMember::clear_blend_src() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blend_src_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::uint32_t AttributesStructMember::blend_src() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesStructMember.blend_src)
  return _internal_blend_src();
}
inline void AttributesStructMember::set_blend_src(::uint32_t value) {
  _internal_set_blend_src(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesStructMember.blend_src)
}
inline ::uint32_t AttributesStructMember::_internal_blend_src() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blend_src_;
}
inline void AttributesStructMember::_internal_set_blend_src(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blend_src_ = value;
}

// optional uint32 color = 3;
inline bool AttributesStructMember::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  return value;
}
inline void AttributesStructMember::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t AttributesStructMember::color() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesStructMember.color)
  return _internal_color();
}
inline void AttributesStructMember::set_color(::uint32_t value) {
  _internal_set_color(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesStructMember.color)
}
inline ::uint32_t AttributesStructMember::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void AttributesStructMember::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// optional .tint.core.ir.binary.pb.BuiltinValue builtin = 4;
inline bool AttributesStructMember::has_builtin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010U) != 0;
  return value;
}
inline void AttributesStructMember::clear_builtin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.builtin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::tint::core::ir::binary::pb::BuiltinValue AttributesStructMember::builtin() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesStructMember.builtin)
  return _internal_builtin();
}
inline void AttributesStructMember::set_builtin(::tint::core::ir::binary::pb::BuiltinValue value) {
  _internal_set_builtin(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesStructMember.builtin)
}
inline ::tint::core::ir::binary::pb::BuiltinValue AttributesStructMember::_internal_builtin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::BuiltinValue>(_impl_.builtin_);
}
inline void AttributesStructMember::_internal_set_builtin(::tint::core::ir::binary::pb::BuiltinValue value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.builtin_ = value;
}

// optional .tint.core.ir.binary.pb.Interpolation interpolation = 5;
inline bool AttributesStructMember::has_interpolation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interpolation_ != nullptr);
  return value;
}
inline void AttributesStructMember::clear_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.interpolation_ != nullptr) _impl_.interpolation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::tint::core::ir::binary::pb::Interpolation& AttributesStructMember::_internal_interpolation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::Interpolation* p = _impl_.interpolation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::Interpolation&>(::tint::core::ir::binary::pb::_Interpolation_default_instance_);
}
inline const ::tint::core::ir::binary::pb::Interpolation& AttributesStructMember::interpolation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesStructMember.interpolation)
  return _internal_interpolation();
}
inline void AttributesStructMember::unsafe_arena_set_allocated_interpolation(
    ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interpolation_);
  }
  _impl_.interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.AttributesStructMember.interpolation)
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE AttributesStructMember::release_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::tint::core::ir::binary::pb::Interpolation* released = _impl_.interpolation_;
  _impl_.interpolation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE AttributesStructMember::unsafe_arena_release_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.AttributesStructMember.interpolation)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::tint::core::ir::binary::pb::Interpolation* temp = _impl_.interpolation_;
  _impl_.interpolation_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL AttributesStructMember::_internal_mutable_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.interpolation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::Interpolation>(GetArena());
    _impl_.interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(p);
  }
  return _impl_.interpolation_;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL AttributesStructMember::mutable_interpolation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::tint::core::ir::binary::pb::Interpolation* _msg = _internal_mutable_interpolation();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.AttributesStructMember.interpolation)
  return _msg;
}
inline void AttributesStructMember::set_allocated_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interpolation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.AttributesStructMember.interpolation)
}

// bool invariant = 6;
inline void AttributesStructMember::clear_invariant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invariant_ = false;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline bool AttributesStructMember::invariant() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesStructMember.invariant)
  return _internal_invariant();
}
inline void AttributesStructMember::set_invariant(bool value) {
  _internal_set_invariant(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesStructMember.invariant)
}
inline bool AttributesStructMember::_internal_invariant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invariant_;
}
inline void AttributesStructMember::_internal_set_invariant(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invariant_ = value;
}

// -------------------------------------------------------------------

// AttributesFunctionParameter

// optional .tint.core.ir.binary.pb.BuiltinValue builtin = 1;
inline bool AttributesFunctionParameter::has_builtin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  return value;
}
inline void AttributesFunctionParameter::clear_builtin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.builtin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::tint::core::ir::binary::pb::BuiltinValue AttributesFunctionParameter::builtin() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesFunctionParameter.builtin)
  return _internal_builtin();
}
inline void AttributesFunctionParameter::set_builtin(::tint::core::ir::binary::pb::BuiltinValue value) {
  _internal_set_builtin(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesFunctionParameter.builtin)
}
inline ::tint::core::ir::binary::pb::BuiltinValue AttributesFunctionParameter::_internal_builtin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::BuiltinValue>(_impl_.builtin_);
}
inline void AttributesFunctionParameter::_internal_set_builtin(::tint::core::ir::binary::pb::BuiltinValue value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.builtin_ = value;
}

// optional uint32 location = 2;
inline bool AttributesFunctionParameter::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  return value;
}
inline void AttributesFunctionParameter::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t AttributesFunctionParameter::location() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesFunctionParameter.location)
  return _internal_location();
}
inline void AttributesFunctionParameter::set_location(::uint32_t value) {
  _internal_set_location(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesFunctionParameter.location)
}
inline ::uint32_t AttributesFunctionParameter::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.location_;
}
inline void AttributesFunctionParameter::_internal_set_location(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_ = value;
}

// optional uint32 color = 3;
inline bool AttributesFunctionParameter::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010U) != 0;
  return value;
}
inline void AttributesFunctionParameter::clear_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::uint32_t AttributesFunctionParameter::color() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesFunctionParameter.color)
  return _internal_color();
}
inline void AttributesFunctionParameter::set_color(::uint32_t value) {
  _internal_set_color(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesFunctionParameter.color)
}
inline ::uint32_t AttributesFunctionParameter::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.color_;
}
inline void AttributesFunctionParameter::_internal_set_color(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.color_ = value;
}

// optional .tint.core.ir.binary.pb.Interpolation interpolation = 4;
inline bool AttributesFunctionParameter::has_interpolation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.interpolation_ != nullptr);
  return value;
}
inline void AttributesFunctionParameter::clear_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.interpolation_ != nullptr) _impl_.interpolation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::tint::core::ir::binary::pb::Interpolation& AttributesFunctionParameter::_internal_interpolation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::Interpolation* p = _impl_.interpolation_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::Interpolation&>(::tint::core::ir::binary::pb::_Interpolation_default_instance_);
}
inline const ::tint::core::ir::binary::pb::Interpolation& AttributesFunctionParameter::interpolation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesFunctionParameter.interpolation)
  return _internal_interpolation();
}
inline void AttributesFunctionParameter::unsafe_arena_set_allocated_interpolation(
    ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interpolation_);
  }
  _impl_.interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.AttributesFunctionParameter.interpolation)
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE AttributesFunctionParameter::release_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::tint::core::ir::binary::pb::Interpolation* released = _impl_.interpolation_;
  _impl_.interpolation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE AttributesFunctionParameter::unsafe_arena_release_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.AttributesFunctionParameter.interpolation)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::tint::core::ir::binary::pb::Interpolation* temp = _impl_.interpolation_;
  _impl_.interpolation_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL AttributesFunctionParameter::_internal_mutable_interpolation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.interpolation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::Interpolation>(GetArena());
    _impl_.interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(p);
  }
  return _impl_.interpolation_;
}
inline ::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NONNULL AttributesFunctionParameter::mutable_interpolation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::tint::core::ir::binary::pb::Interpolation* _msg = _internal_mutable_interpolation();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.AttributesFunctionParameter.interpolation)
  return _msg;
}
inline void AttributesFunctionParameter::set_allocated_interpolation(::tint::core::ir::binary::pb::Interpolation* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.interpolation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.interpolation_ = reinterpret_cast<::tint::core::ir::binary::pb::Interpolation*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.AttributesFunctionParameter.interpolation)
}

// optional .tint.core.ir.binary.pb.BindingPoint binding_point = 5;
inline bool AttributesFunctionParameter::has_binding_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.binding_point_ != nullptr);
  return value;
}
inline void AttributesFunctionParameter::clear_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.binding_point_ != nullptr) _impl_.binding_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::tint::core::ir::binary::pb::BindingPoint& AttributesFunctionParameter::_internal_binding_point() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tint::core::ir::binary::pb::BindingPoint* p = _impl_.binding_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::tint::core::ir::binary::pb::BindingPoint&>(::tint::core::ir::binary::pb::_BindingPoint_default_instance_);
}
inline const ::tint::core::ir::binary::pb::BindingPoint& AttributesFunctionParameter::binding_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesFunctionParameter.binding_point)
  return _internal_binding_point();
}
inline void AttributesFunctionParameter::unsafe_arena_set_allocated_binding_point(
    ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.binding_point_);
  }
  _impl_.binding_point_ = reinterpret_cast<::tint::core::ir::binary::pb::BindingPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tint.core.ir.binary.pb.AttributesFunctionParameter.binding_point)
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE AttributesFunctionParameter::release_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::BindingPoint* released = _impl_.binding_point_;
  _impl_.binding_point_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE AttributesFunctionParameter::unsafe_arena_release_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tint.core.ir.binary.pb.AttributesFunctionParameter.binding_point)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::tint::core::ir::binary::pb::BindingPoint* temp = _impl_.binding_point_;
  _impl_.binding_point_ = nullptr;
  return temp;
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL AttributesFunctionParameter::_internal_mutable_binding_point() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.binding_point_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tint::core::ir::binary::pb::BindingPoint>(GetArena());
    _impl_.binding_point_ = reinterpret_cast<::tint::core::ir::binary::pb::BindingPoint*>(p);
  }
  return _impl_.binding_point_;
}
inline ::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NONNULL AttributesFunctionParameter::mutable_binding_point()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::tint::core::ir::binary::pb::BindingPoint* _msg = _internal_mutable_binding_point();
  // @@protoc_insertion_point(field_mutable:tint.core.ir.binary.pb.AttributesFunctionParameter.binding_point)
  return _msg;
}
inline void AttributesFunctionParameter::set_allocated_binding_point(::tint::core::ir::binary::pb::BindingPoint* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.binding_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.binding_point_ = reinterpret_cast<::tint::core::ir::binary::pb::BindingPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:tint.core.ir.binary.pb.AttributesFunctionParameter.binding_point)
}

// bool invariant = 6;
inline void AttributesFunctionParameter::clear_invariant() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invariant_ = false;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline bool AttributesFunctionParameter::invariant() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.AttributesFunctionParameter.invariant)
  return _internal_invariant();
}
inline void AttributesFunctionParameter::set_invariant(bool value) {
  _internal_set_invariant(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.AttributesFunctionParameter.invariant)
}
inline bool AttributesFunctionParameter::_internal_invariant() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.invariant_;
}
inline void AttributesFunctionParameter::_internal_set_invariant(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invariant_ = value;
}

// -------------------------------------------------------------------

// Interpolation

// .tint.core.ir.binary.pb.InterpolationType type = 1;
inline void Interpolation::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::tint::core::ir::binary::pb::InterpolationType Interpolation::type() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Interpolation.type)
  return _internal_type();
}
inline void Interpolation::set_type(::tint::core::ir::binary::pb::InterpolationType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Interpolation.type)
}
inline ::tint::core::ir::binary::pb::InterpolationType Interpolation::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::InterpolationType>(_impl_.type_);
}
inline void Interpolation::_internal_set_type(::tint::core::ir::binary::pb::InterpolationType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// optional .tint.core.ir.binary.pb.InterpolationSampling sampling = 2;
inline bool Interpolation::has_sampling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  return value;
}
inline void Interpolation::clear_sampling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampling_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::tint::core::ir::binary::pb::InterpolationSampling Interpolation::sampling() const {
  // @@protoc_insertion_point(field_get:tint.core.ir.binary.pb.Interpolation.sampling)
  return _internal_sampling();
}
inline void Interpolation::set_sampling(::tint::core::ir::binary::pb::InterpolationSampling value) {
  _internal_set_sampling(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:tint.core.ir.binary.pb.Interpolation.sampling)
}
inline ::tint::core::ir::binary::pb::InterpolationSampling Interpolation::_internal_sampling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tint::core::ir::binary::pb::InterpolationSampling>(_impl_.sampling_);
}
inline void Interpolation::_internal_set_sampling(::tint::core::ir::binary::pb::InterpolationSampling value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampling_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace binary
}  // namespace ir
}  // namespace core
}  // namespace tint


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tint::core::ir::binary::pb::TypeBasic> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::TypeBasic>() {
  return ::tint::core::ir::binary::pb::TypeBasic_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::TypeBuiltinStruct> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::TypeBuiltinStruct>() {
  return ::tint::core::ir::binary::pb::TypeBuiltinStruct_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::PipelineStage> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::PipelineStage>() {
  return ::tint::core::ir::binary::pb::PipelineStage_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::AddressSpace> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::AddressSpace>() {
  return ::tint::core::ir::binary::pb::AddressSpace_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::AccessControl> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::AccessControl>() {
  return ::tint::core::ir::binary::pb::AccessControl_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::UnaryOp> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::UnaryOp>() {
  return ::tint::core::ir::binary::pb::UnaryOp_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::BinaryOp> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::BinaryOp>() {
  return ::tint::core::ir::binary::pb::BinaryOp_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::TextureDimension> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::TextureDimension>() {
  return ::tint::core::ir::binary::pb::TextureDimension_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::TexelFormat> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::TexelFormat>() {
  return ::tint::core::ir::binary::pb::TexelFormat_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::SamplerKind> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::SamplerKind>() {
  return ::tint::core::ir::binary::pb::SamplerKind_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::InterpolationType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::InterpolationType>() {
  return ::tint::core::ir::binary::pb::InterpolationType_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::InterpolationSampling> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::InterpolationSampling>() {
  return ::tint::core::ir::binary::pb::InterpolationSampling_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::BuiltinValue> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::BuiltinValue>() {
  return ::tint::core::ir::binary::pb::BuiltinValue_descriptor();
}
template <>
struct is_proto_enum<::tint::core::ir::binary::pb::BuiltinFn> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::tint::core::ir::binary::pb::BuiltinFn>() {
  return ::tint::core::ir::binary::pb::BuiltinFn_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // src_2ftint_2futils_2fprotos_2fir_2fir_2eproto_2epb_2eh
